//////////////////////////////////////////////////////////////////////
/// \mainpage RichTextBox Documentation
///
/// \section intro_sec Introduction
///
/// %RichTextBox is an ActiveX control that wraps the \c RichEdit50W window class. It is optimized for
/// Visual Basic 6.0, but should also work in any other environment that supports COM controls.
///
/// \section basics_sec Basics
///
/// The control superclasses the native rich text box window class of Windows: \c RichEdit50W. Although I
/// tried to wrap all features of this window class (status: Windows 10), some things may be missing. In
/// these cases you usually may use the Win32 API and handle the control as a native rich text box window.
/// One of my goals was it to create a rich text box control that may be controlled via API as well as via
/// the classes that I implemented.
///
/// \section reqs_sec Requirements
///
/// %RichTextBox ANSI runs on the following operating systems:
/// - Windows XP (SP3 or later)
/// - Windows Server 2003 (SP2 or later)
/// - Windows Vista (SP2 or later)
/// - Windows Server 2008 (SP2 or later)
/// - Windows 7 (SP1 or later)
/// - Windows Server 2008 R2 (SP1 or later)
/// - Windows 8
/// - Windows Server 2012
/// - Windows 8.1
/// - Windows Server 2012 R2
/// - Windows 10
/// - Windows Server 2016
///
/// Some features have additional requirements which are mentioned in the affected feature's
/// documentation.\n
/// Limited support means, that I won't invest much work to support those systems. If a feature works on
/// a system tagged with "limited support" - fine; if it does not and it's easy to fix, I'll fix it, but if
/// it's difficult to fix, I probably won't fix it. Also I will test the control much less on those systems.
///
/// \section support_sec Support
///
/// There's no entitlement to support. Period. However, you have good chances to get help if you post your
/// questions on <a href="https://github.com/TimoKunze/RichTextBoxControl">GitHub</a> or in the
/// <a href="https://www.timosoft-software.de/forum/viewforum.php?f=40">forums</a>.\n
/// Also the project is open source, so feel free to have a look at the source code. You may modify it, but
/// please consider sharing your changes with the rest of the world.
///
/// \section lic_sec License
///
/// <pre>
///      MIT License
///
///      Copyright (c) 2018 Timo Kunze
///
///      Permission is hereby granted, free of charge, to any person obtaining a copy
///      of this software and associated documentation files (the "Software"), to deal
///      in the Software without restriction, including without limitation the rights
///      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
///      copies of the Software, and to permit persons to whom the Software is
///      furnished to do so, subject to the following conditions:
///
///      The above copyright notice and this permission notice shall be included in all
///      copies or substantial portions of the Software.
///
///      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
///      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
///      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
///      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
///      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
///      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
///      SOFTWARE.
/// </pre>
///
/// \section acks_sec Acknowledgements
///
/// Thanks go to:
/// - <a href="https://www.winehq.com">Wine Headquarters</a>, because Wine helped me a lot on
///   understanding how Windows is working.
/// - Microsoft, for ATL, WTL and Visual Studio - great libraries and a great IDE
/// - <a href="https://www.geoffchappell.com">Geoff Chappell</a>, for his website about undocumented Win32
///   API stuff.
/// - Igor Tandetnik, for his great help on learning ATL and WTL
/// - Dimitri van Heesch, for Doxygen
/// - <a href="http://www.zabkat.com/">Nikos Bozinis</a>, for his awesome help with the Vista drag'n'drop
///   stuff.
/// - <a href="https://www.dateicommander.de">Christian Lütgens</a>, for his great work as beta-tester
///   and for his help when I needed a 2nd opinion on some decisions.
/// - All donators
/// - For great music: Heaven Shall Burn, Arch Enemy, Machine Head, Trivium, Deadlock, Draconian, Soulfly,
///   Delain, Lacuna Coil, Ensiferum, Epica, Sirenia, Tristania, Nightwish, Battlelore, Amon Amarth, Volbeat,
///   Guns N' Roses
///
/// \section faq_sec FAQ
///
/// <strong>1. Why is event xyz not fired?</strong>\n
/// Firing an event is relative time-consuming, even if the event isn't handled by the application at all.
/// Therefore I implemented a \c DisabledEvents property which can be used to deactivate certain events.\n
/// By default many events are deactivated.
///
/// <strong>2. Why so many properties don't seem to work?</strong>\n
/// Microsoft Office uses a text processor that has been heavily extended compared to the Windows Rich Text
/// control. Both implementations share the same API, but great parts of this API are not implemented in
/// the Windows Rich Text control. Even the Rich Text component of Microsoft Office supports only a few
/// more parts of the API, because the Office text processor depends on more components than just this
/// one.\n
/// However, in the past Microsoft did port some features of Microsoft Office to the Windows Rich Text
/// control. Also it is nearly impossible to test which feature is available under which conditions. So I
/// decided for the simple way and just implemented all features of the Rich Text API, knowing that some of
/// them won't work with current systems, some will work with future systems only, and some of them will
/// never work.\n
/// Some features that are known to NOT work on Windows 10:
/// - \c IRichTextFont::Animation
/// - \c IRichTextFont::Emboss
/// - \c IRichTextFont::Engrave
/// - \c IRichTextFont::Outline
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
/// \namespace RichTextBoxCtlLibA
/// \brief <em>Contains COM definitions for the control's public interface</em>
///
/// This is the ANSI version of the RichTextBox COM library.
//////////////////////////////////////////////////////////////////////


#include "olectl.h"
#include "CompilerFlags.h"
#include "DispIDs.h"

#ifndef DOXYGEN_SHOULD_SKIP_THIS
	// interface is not automation marshaling conformant, requires Windows NT 4.0 SP4 or greater
	midl_pragma warning(disable: 2039)
	// identifier length exceeds 31 characters
	midl_pragma warning(disable: 2111)
	// too many methods in the interface, requires Windows NT 4.0 SP3 or greater
	midl_pragma warning(disable: 2362)
#endif

import "oaidl.idl";
import "ocidl.idl";


[
	uuid(615602F5-ABB1-4073-8DD5-B46667E64ADF),
	version(1.0),
	helpstring("TimoSoft RichTextBox 1.0 (ANSI)")
]
library RichTextBoxCtlLibA
{
	importlib("stdole2.tlb");
	interface IRichOLEObject;
	interface IRichTextRange;
	interface IRichTable;
	interface IRichTableRow;


	/// \brief <em>Constants used with the \c IRichTextFont::AnimationType property</em>
	///
	/// \sa IRichTextFont::AnimationType
	[helpstring("Constants used with the 'TextFont.AnimationType' property.")]
	typedef enum AnimationTypeConstants {
		/// \brief The animation type is 'undefined'
		[helpstring("The animation type is 'undefined'.")]
		atUndefined = -9999999/*tomUndefined*/,
		/// \brief Text is not animated
		[helpstring("Text is not animated.")]
		atNoAnimation = 0/*tomNoAnimation*/,
		/// \brief Text is bordered by marquee lights that blink between the colors red, yellow, green, and blue
		[helpstring("Text is bordered by marquee lights that blink between the colors red, yellow, green, and blue.")]
		atLasVegasLights = 1/*tomLasVegasLights*/,
		/// \brief Text has a black background that blinks on and off
		[helpstring("Text has a black background that blinks on and off.")]
		atBlinkingBackground = 2/*tomBlinkingBackground*/,
		/// \brief Text is overlaid with multicolored stars that blink on and off at regular intervals
		[helpstring("Text is overlaid with multicolored stars that blink on and off at regular intervals.")]
		atSparkleText = 3/*tomSparkleText*/,
		/// \brief Text is surrounded by a black dashed-line border that is animated to appear to move clockwise around the text
		[helpstring("Text is surrounded by a black dashed-line border that is animated to appear to move clockwise around the text.")]
		atMarchingBlackAnts = 4/*tomMarchingBlackAnts*/,
		/// \brief Text is surrounded by a red dashed-line border that is animated to appear to move clockwise around the text
		[helpstring("Text is surrounded by a red dashed-line border that is animated to appear to move clockwise around the text.")]
		atMarchingRedAnts = 5/*tomMarchingRedAnts*/,
		/// \brief Text is alternately blurred and unblurred at regular intervals, to give the appearance of shimmering
		[helpstring("Text is alternately blurred and unblurred at regular intervals, to give the appearance of shimmering.")]
		atShimmer = 6/*tomShimmer*/,
		/// \brief Text appears gradually from the top down
		[helpstring("Text appears gradually from the top down.")]
		atWipeDown = 7/*tomWipeDown*/,
		/// \brief Text appears gradually from the bottom up
		[helpstring("Text appears gradually from the bottom up.")]
		atWipeRight = 8/*tomWipeRight*/
	} AnimationTypeConstants;

	/// \brief <em>Constants used with the \c Appearance property</em>
	///
	/// \sa IRichTextBox::Appearance
	[helpstring("Constants used with the 'Appearance' property.")]
	typedef enum AppearanceConstants {
		/// \brief The control is drawn with a flat border
		[helpstring("The control is drawn flat.")]
		a2D,
		/// \brief The control is drawn with a normal 3D border
		[helpstring("The control is drawn with a normal 3D border.")]
		a3D,
		/// \brief The control is drawn with a light 3D border
		[helpstring("The control is drawn with a light 3D border.")]
		a3DLight
	} AppearanceConstants;

	/// \brief <em>Flags used with the \c AutoDetectURLs property</em>
	///
	/// \sa IRichTextBox::AutoDetectURLs
	[helpstring("Flags used with the 'AutoDetectURLs' property. They can be combined.")]
	typedef enum AutoDetectURLsConstants {
		/// \brief Don't detect any kinds of URLs automatically
		[helpstring("Don't detect any kinds of URLs automatically.")]
		aduNone = 0,
		/// \brief Detect normal URLs in the user input and format them as links automatically
		[helpstring("Detect normal URLs in the user input and format them as links automatically.")]
		aduURLs = 1/*AURL_ENABLEURL*/,
		/// \brief Detect e-mail addresses in the user input and format them as links automatically
		[helpstring("Detect e-mail addresses in the user input and format them as links automatically.")]
		aduEMailAddresses = 2/*AURL_ENABLEEMAILADDR*/,
		/// \brief Detect telephone numbers in the user input and format them as links automatically
		[helpstring("Detect telephone numbers in the user input and format them as links automatically.")]
		aduPhoneNumbers = 4/*AURL_ENABLETELNO*/,
		/// \brief Detect URLs containing east-asian characters in the user input and format them as links automatically
		[helpstring("Detect URLs containing east-asian characters in the user input and format them as links automatically.")]
		aduURLsWithEastAsianCharacters = 8/*AURL_ENABLEEAURLS*/,
		/// \brief Detect fully qualified file paths like \c C:\Temp in the user input and format them as links automatically
		[helpstring("Detect fully qualified file paths like 'C:\\Temp' in the user input and format them as links automatically.")]
		aduFullyQualifierdFilePaths = 16/*AURL_ENABLEDRIVELETTERS*/,
		/// \brief Disable recognition of domain names that contain labels with characters belonging to more than one of the following scripts: Latin, Greek, and Cyrillic
		[helpstring("Disable recognition of domain names that contain labels with characters belonging to more than one of the following scripts: Latin, Greek, and Cyrillic.")]
		aduDisableRecognitionOnLatinGreekCyrillicMixture = 32/*AURL_DISABLEMIXEDLGC*/
	} AutoDetectURLsConstants;

	/// \brief <em>Flags used with the \c AutoScrolling property</em>
	///
	/// \sa IRichTextBox::AutoScrolling
	[helpstring("Flags used with the 'AutoScrolling' property. They can be combined.")]
	typedef enum AutoScrollingConstants {
		/// \brief Don't scroll automatically if the user types a character at the end of the line or presses the \c ENTER key at the last line
		[helpstring("Don't scroll automatically if the user types a character at the end of the line or presses the ENTER key at the last line.")]
		asNone = 0,
		/// \brief Scroll automatically if the user presses the \c ENTER key at the last line
		[helpstring("Scroll automatically if the user presses the \c ENTER key at the last line.")]
		asVertical = 1,
		/// \brief Scroll automatically if the user types a character at the end of the line
		[helpstring("Scroll automatically if the user types a character at the end of the line.")]
		asHorizontal = 2
	} AutoScrollingConstants;

	/// \brief <em>Constants used by boolean properties that also can have an 'undefined' state</em>
	///
	/// \sa IRichTextFont::AllCaps, IRichTextFont::Bold, IRichTextFont::CanChange, IRichTextFont::Emboss,
	///     IRichTextFont::Engrave, IRichTextFont::Hidden, IRichTextFont::Italic, IRichTextFont::Outline,
	///     IRichTextFont::Protected, IRichTextFont::Shadow, IRichTextFont::SmallCaps,
	///     IRichTextFont::StrikeThrough, IRichTextFont::Subscript, IRichTextFont::Superscript,
	///     IRichTextParagraph::Hyphenation, IRichTextParagraph::Numbered,
	///     IRichTextParagraph::PreventWidowsAndOrphans, IRichTextRange::CanEdit
	[helpstring("Constants used by boolean properties that also can have an 'Undefined' state.")]
	typedef enum BooleanPropertyValueConstants {
		/// \brief Toggle the current value of the boolean property
		///
		/// \remarks This value might not work for all boolean properties.
		[helpstring("Toggle the current value of the boolean property. This value might not work for all boolean properties.")]
		bpvToggle = -9999998/*tomToggle*/,
		/// \brief The value of the boolean property is 'undefined'
		[helpstring("The value of the boolean property is 'undefined'.")]
		bpvUndefined = -9999999/*tomUndefined*/,
		/// \brief The value of the boolean property is 'False'
		[helpstring("The value of the boolean property is 'False'.")]
		bpvFalse = 0/*tomFalse*/,
		/// \brief The value of the boolean property is 'True'
		[helpstring("The value of the boolean property is 'True'.")]
		bpvTrue = -1/*tomTrue*/
	} BooleanPropertyValueConstants;

	/// \brief <em>Constants used with the \c BorderStyle property</em>
	///
	/// \sa IRichTextBox::BorderStyle
	[helpstring("Constants used with the 'BorderStyle' property.")]
	typedef enum BorderStyleConstants {
		/// \brief The control is drawn without an inner border
		[helpstring("The control is drawn without an additional border.")]
		bsNone,
		/// \brief The control is drawn with an inner border
		[helpstring("The control is drawn with an additional border.")]
		bsFixedSingle
	} BorderStyleConstants;

	/// \brief <em>Constants used with the \c IRichTextRange::BuildUpMath and \c IRichTextRange::BuildDownMath methods</em>
	///
	/// \sa IRichTextRange::BuildUpMath, IRichTextRange::BuildDownMath
	[helpstring("Constants used with the 'TextRange.BuildUpMath' and 'TextRange.BuildDownMath' methods. They can be combined.")]
	typedef enum BuildUpMathConstants {
		/// \brief Enables TeX syntax for build up/down operations
		[helpstring("Enables TeX syntax for build up/down operations.")]
		bumTeX = 1/*tomTeX*/,
		/// \brief A terminating operator is needed
		[helpstring("A terminating operator is needed. Only used with a degenerate range for formula autobuildup.")]
		bumNeedTerminatingOperator = 2/*tomNeedTermOp*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumMathAlphabetics = 4/*tomMathAlphabetics*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumMathSingleChar = 8/*tomMathSingleChar*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumPlain = 16/*tomPlain*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumHaveDelimiter = 32/*tomHaveDelimiter*/,
		/// \brief Use operand precedence
		[helpstring("Use operand precedence.")]
		bumUseOperandPrecedence = 64/*tomUseOperandPrec*/,
		/// \brief Collapse the selection after the operation
		[helpstring("Collapse the selection after the operation.")]
		bumMathCollapseSel = 128/*tomMathCollapseSel*/,
		/// \brief Automatically replace text like "\pi" and other standard keywords with their professional representation (e.g. π)
		[helpstring("Automatically replace text like ""\pi"" and other standard keywords with their professional representation (e.g. the greek letter pi).")]
		bumMathAutoCorrect = 256/*tomMathAutoCorrect*/,
		/// \brief Build-down the math zone that the insertion point is in, without requiring a selection
		[helpstring("Build-down the math zone that the insertion point is in, without requiring a selection.")]
		bumBuildUpArgOrZone = 512/*tomMathBuildUpArgOrZone*/,
		/// \brief Enable recursive build-up
		[helpstring("Enable recursive build-up.")]
		bumMathBuildUpRecurse = 1024/*tomMathBuildUpRecurse*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumBuildDownOutermost = 2048/*tomMathBuildDownOutermost*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumChemicalFormula = 0x1000/*tomChemicalFormula*/,
		/// \brief Build down instead of up
		[helpstring("Build down instead of up.")]
		bumMathBuildDown = 0x2000/*tomMathBuildDown*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumMathApplyTemplate = 0x4000/*tomMathApplyTemplate*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumRemoveOutermost = 0x8000/*tomMathRemoveOutermost*/,
		/// \brief Insert a row before the current row, e.g. in a matrix
		[helpstring("Insert a row before the current row, e.g. in a matrix.")]
		bumMathInsertRowBefore = 0x10000/*tomMathInsRowBefore*/,
		/// \brief Insert a row after the current row, e.g. in a matrix
		[helpstring("Insert a row after the current row, e.g. in a matrix.")]
		bumMathInsertRowAfter = 0x20000/*tomMathInsRowAfter*/,
		/// \brief Insert a column before the current column, e.g. in a matrix
		[helpstring("Insert a column before the current column, e.g. in a matrix.")]
		bumMathInsertColBefore = 0x30000/*tomMathInsColBefore*/,
		/// \brief Insert a column after the current column, e.g. in a matrix
		[helpstring("Insert a column after the current column, e.g. in a matrix.")]
		bumMathInsertColAfter = 0x40000/*tomMathInsColAfter*/,
		/// \brief Delete the current row, e.g. in a matrix
		[helpstring("Delete the current row, e.g. in a matrix.")]
		bumMathDeleteRow = 0x50000/*tomMathDeleteRow*/,
		/// \brief Delete the current column, e.g. in a matrix
		[helpstring("Delete the current column, e.g. in a matrix.")]
		bumMathDeleteCol = 0x60000/*tomMathDeleteCol*/,
		/// \brief Delete the argument at the start of the range
		[helpstring("Delete the argument at the start of the range.")]
		bumMathDeleteArg = 0x70000/*tomMathDeleteArg*/,
		/// \brief Delete the 2nd argument, counted from the start of the range
		[helpstring("Delete the 2nd argument, counted from the start of the range.")]
		bumMathDeleteArg1 = 0x80000/*tomMathDeleteArg1*/,
		/// \brief Delete the 3rd argument, counted from the start of the range
		[helpstring("Delete the 3rd argument, counted from the start of the range.")]
		bumMathDeleteArg2 = 0x90000/*tomMathDeleteArg2*/,
		/// \brief Change fractions to linear format (1/2)
		[helpstring("Change fractions to linear format (1/2).")]
		bumMathMakeFracLinear = 0xA0000/*tomMathMakeFracLinear*/,
		/// \brief Change fractions to stacked format (\f$\frac{1}{2}\f$)
		[helpstring("Change fractions to stacked format (1 over 2).")]
		bumMathMakeFracStacked = 0xB0000/*tomMathMakeFracStacked*/,
		/// \brief Change fractions to slashed format (½)
		[helpstring("Change fractions to slashed format (½).")]
		bumMathMakeFracSlashed = 0xC0000/*tomMathMakeFracSlashed*/,
		/// \brief Move superscripts and subscripts to the left side
		[helpstring("Move superscripts and subscripts to the left side.")]
		bumMathMakeLeftSubSup = 0xD0000/*tomMathMakeLeftSubSup*/,
		/// \brief Move superscripts and subscripts to the right side
		[helpstring("Move superscripts and subscripts to the right side.")]
		bumMathMakeSubSup = 0xE0000/*tomMathMakeSubSup*/,
		/// \brief Handle [BACKSPACE] key
		[helpstring("Handle [BACKSPACE] key.")]
		bumMathBackspace = 0x100000/*tomMathBackspace*/,
		/// \brief Handle [ENTER] key
		[helpstring("Handle [ENTER] key.")]
		bumMathEnter = 0x110000/*tomMathEnter*/,
		/// \brief Handle [SHIFT]+[TAB] key
		[helpstring("Handle [SHIFT]+[TAB] key.")]
		bumMathShiftTab = 0x120000/*tomMathShiftTab*/,
		/// \brief Handle [TAB] key
		[helpstring("Handle [TAB] key.")]
		bumMathTab = 0x130000/*tomMathTab*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumMathAlignBreakLeft = 0x140000/*tomMathAlignBreakLeft*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumMathAlignBreakCenter = 0x150000/*tomMathAlignBreakCenter*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumMathAlignBreakRight = 0x160000/*tomMathAlignBreakRight*/,
		/// \brief Handle the [CTRL]+[=] key combination in a math zone
		[helpstring("Handle the [CTRL]+[=] key combination in a math zone.")]
		bumMathSubscript = 0x170000/*tomMathSubscript*/,
		/// \brief Handle the [CTRL]+[SHIFT]+[=] key combination in a math zone
		[helpstring("Handle the [CTRL]+[SHIFT]+[=] key combination in a math zone.")]
		bumMathSuperscript = 0x180000/*tomMathSuperscript*/,
		/// \brief Use Arabic math alphabetics for variables
		[helpstring("Use Arabic math alphabetics for variables.")]
		bumMathArabicAlphabetics = 0x800000/*tomMathArabicAlphabetics*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumMathAutoCorrectOpPairs = 0x1000000/*tomMathAutoCorrectOpPairs*/,
		/// \brief Invoke external autocorrection in manual build up
		[helpstring("Invoke external autocorrection in manual build up.")]
		bumMathAutoCorrectExt = 0x2000000/*tomMathAutoCorrectExt*/,
		/// \brief Don't hide empty argument placeholders on build-up
		[helpstring("Don't hide empty argument placeholders on build-up.")]
		bumShowEmptyArgPlaceholders = 0x4000000/*tomShowEmptyArgPlaceholders*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumMathAutoComplete = 0x8000000/*tomMathAutoComplete*/,
		/// \brief Handle minor differences between the rich edit control and Word
		[helpstring("Handle minor differences between the rich edit control and Word.")]
		bumMathRichEdit = 0x40000000/*tomMathRichEdit*/,
		/// \brief To be documented
		[helpstring("To be documented.")]
		bumSpecialChar = 0x80000000/*tomSpecialChar*/
	} BuildUpMathConstants;

	/// \brief <em>Constants used with the \c StyleID properties</em>
	///
	/// \sa IRichTextFont::StyleID, IRichTextParagraph::StyleID
	[helpstring("Constants used with the 'StyleID' properties.")]
	typedef enum BuiltInStyleConstants {
		/// \brief Normal text
		[helpstring("Normal text.")]
		bisNormalText = -1/*StyleNormal*/,
		/// \brief Heading, style 1
		[helpstring("Heading, style 1.")]
		bisHeading1 = -2/*StyleHeading1*/,
		/// \brief Heading, style 2
		[helpstring("Heading, style 2.")]
		bisHeading2 = -3/*StyleHeading2*/,
		/// \brief Heading, style 3
		[helpstring("Heading, style 3.")]
		bisHeading3 = -4/*StyleHeading3*/,
		/// \brief Heading, style 4
		[helpstring("Heading, style 4.")]
		bisHeading4 = -5/*StyleHeading4*/,
		/// \brief Heading, style 5
		[helpstring("Heading, style 5.")]
		bisHeading5 = -6/*StyleHeading5*/,
		/// \brief Heading, style 6
		[helpstring("Heading, style 6.")]
		bisHeading6 = -7/*StyleHeading6*/,
		/// \brief Heading, style 7
		[helpstring("Heading, style 7.")]
		bisHeading7 = -8/*StyleHeading7*/,
		/// \brief Heading, style 8
		[helpstring("Heading, style 8.")]
		bisHeading8 = -9/*StyleHeading8*/,
		/// \brief Heading, style 9
		[helpstring("Heading, style 9.")]
		bisHeading9 = -10/*StyleHeading9*/,
		/// \brief Index, style 1
		[helpstring("Index, style 1.")]
		bisIndex1 = -11/*StyleIndex1*/,
		/// \brief Index, style 2
		[helpstring("Index, style 2.")]
		bisIndex2 = -12/*StyleIndex2*/,
		/// \brief Index, style 3
		[helpstring("Index, style 3.")]
		bisIndex3 = -13/*StyleIndex3*/,
		/// \brief Index, style 4
		[helpstring("Index, style 4.")]
		bisIndex4 = -14/*StyleIndex4*/,
		/// \brief Index, style 5
		[helpstring("Index, style 5.")]
		bisIndex5 = -15/*StyleIndex5*/,
		/// \brief Index, style 6
		[helpstring("Index, style 6.")]
		bisIndex6 = -16/*StyleIndex6*/,
		/// \brief Index, style 7
		[helpstring("Index, style 7.")]
		bisIndex7 = -17/*StyleIndex7*/,
		/// \brief Index, style 8
		[helpstring("Index, style 8.")]
		bisIndex8 = -18/*StyleIndex8*/,
		/// \brief Index, style 9
		[helpstring("Index, style 9.")]
		bisIndex9 = -19/*StyleIndex9*/,
		/// \brief %Table of content, style 1
		[helpstring("Table of content, style 1.")]
		bisTOC1 = -20/*StyleTOC1*/,
		/// \brief %Table of content, style 2
		[helpstring("Table of content, style 2.")]
		bisTOC2 = -21/*StyleTOC2*/,
		/// \brief %Table of content, style 3
		[helpstring("Table of content, style 3.")]
		bisTOC3 = -22/*StyleTOC3*/,
		/// \brief %Table of content, style 4
		[helpstring("Table of content, style 4.")]
		bisTOC4 = -23/*StyleTOC4*/,
		/// \brief %Table of content, style 5
		[helpstring("Table of content, style 5.")]
		bisTOC5 = -24/*StyleTOC5*/,
		/// \brief %Table of content, style 6
		[helpstring("Table of content, style 6.")]
		bisTOC6 = -25/*StyleTOC6*/,
		/// \brief %Table of content, style 7
		[helpstring("Table of content, style 7.")]
		bisTOC7 = -26/*StyleTOC7*/,
		/// \brief %Table of content, style 8
		[helpstring("Table of content, style 8.")]
		bisTOC8 = -27/*StyleTOC8*/,
		/// \brief %Table of content, style 9
		[helpstring("Table of content, style 9.")]
		bisTOC9 = -28/*StyleTOC9*/,
		/// \brief Normal indentation
		[helpstring("Normal indentation.")]
		bisNormalIndent = -29/*StyleNormalIndent*/,
		/// \brief Footnote text
		[helpstring("Footnote text.")]
		bisFootnoteText = -30/*StyleFootnoteText*/,
		/// \brief Annotation text
		[helpstring("Annotation text.")]
		bisAnnotationText = -31/*StyleAnnotationText*/,
		/// \brief Header
		[helpstring("Header.")]
		bisHeader = -32/*StyleHeader*/,
		/// \brief Footer
		[helpstring("Footer.")]
		bisFooter = -33/*StyleFooter*/,
		/// \brief Heading of an index
		[helpstring("Heading of an index.")]
		bisIndexHeading = -34/*StyleIndexHeading*/,
		/// \brief Caption
		[helpstring("Caption.")]
		bisCaption = -35/*StyleCaption*/,
		/// \brief %Table of figures
		[helpstring("Table of figures.")]
		bisTableOfFigures = -36/*StyleTableofFigures*/,
		/// \brief Envelope address
		[helpstring("Envelope address.")]
		bisEnvelopeAddress = -37/*StyleEnvelopeAddress*/,
		/// \brief Envelope return
		[helpstring("Envelope return.")]
		bisEnvelopeReturn = -38/*StyleEnvelopeReturn*/,
		/// \brief Footnote reference
		[helpstring("Footnote reference.")]
		bisFootnoteReference = -39/*StyleFootnoteReference*/,
		/// \brief Annotation reference
		[helpstring("Annotation reference.")]
		bisAnnotationReference = -40/*StyleAnnotationReference*/,
		/// \brief Line number
		[helpstring("Line number.")]
		bisLineNumber = -41/*StyleLineNumber*/,
		/// \brief Page number
		[helpstring("Page number.")]
		bisPageNumber = -42/*StylePageNumber*/,
		/// \brief Endnote reference
		[helpstring("Endnote reference.")]
		bisEndnoteReference = -43/*StyleEndnoteReference*/,
		/// \brief Endnote text
		[helpstring("Endnote text.")]
		bisEndnoteText = -44/*StyleEndnoteText*/,
		/// \brief %Table of authorities
		[helpstring("Table of authorities.")]
		bisTableOfAuthorities = -45/*StyleTableofAuthorities*/,
		/// \brief Macro text
		[helpstring("Macro text.")]
		bisMacroText = -46/*StyleMacroText*/,
		/// \brief TOA heading
		[helpstring("TOA heading.")]
		bisTOAHeading = -47/*StyleTOAHeading*/,
		/// \brief List, style 1
		[helpstring("List, style 1.")]
		bisList1 = -48/*StyleList*/,
		/// \brief List bullet, style 1
		[helpstring("List bullet, style 1.")]
		bisListBullet1 = -49/*StyleListBullet*/,
		/// \brief List number, style 1
		[helpstring("List number, style 1.")]
		bisListNumber1 = -50/*StyleListNumber*/,
		/// \brief List, style 2
		[helpstring("List, style 2.")]
		bisList2 = -51/*StyleList2*/,
		/// \brief List, style 3
		[helpstring("List, style 3.")]
		bisList3 = -52/*StyleList3*/,
		/// \brief List, style 4
		[helpstring("List, style 4.")]
		bisList4 = -53/*StyleList4*/,
		/// \brief List, style 5
		[helpstring("List, style 5.")]
		bisList5 = -54/*StyleList5*/,
		/// \brief List bullet, style 2
		[helpstring("List bullet, style 2.")]
		bisListBullet2 = -55/*StyleListBullet2*/,
		/// \brief List bullet, style 3
		[helpstring("List bullet, style 3.")]
		bisListBullet3 = -56/*StyleListBullet3*/,
		/// \brief List bullet, style 4
		[helpstring("List bullet, style 4.")]
		bisListBullet4 = -57/*StyleListBullet4*/,
		/// \brief List bullet, style 5
		[helpstring("List bullet, style 5.")]
		bisListBullet5 = -58/*StyleListBullet5*/,
		/// \brief List number, style 2
		[helpstring("List number, style 2.")]
		bisListNumber2 = -59/*StyleListNumber2*/,
		/// \brief List number, style 3
		[helpstring("List number, style 3.")]
		bisListNumber3 = -60/*StyleListNumber3*/,
		/// \brief List number, style 4
		[helpstring("List number, style 4.")]
		bisListNumber4 = -61/*StyleListNumber4*/,
		/// \brief List number, style 5
		[helpstring("List number, style 5.")]
		bisListNumber5 = -62/*StyleListNumber5*/,
		/// \brief Title
		[helpstring("Title.")]
		bisTitle = -63/*StyleTitle*/,
		/// \brief Closing
		[helpstring("Closing.")]
		bisClosing = -64/*StyleClosing*/,
		/// \brief Signature
		[helpstring("Signature.")]
		bisSignature = -65/*StyleSignature*/,
		/// \brief Default paragraph font
		[helpstring("Default paragraph font.")]
		bisDefaultParagraphFont = -66/*StyleDefaultParagraphFont*/,
		/// \brief Body text, style 1
		[helpstring("Body text, style 1.")]
		bisBodyText1 = -67/*StyleBodyText*/,
		/// \brief Indented body text, style 1
		[helpstring("Indented body text, style 1.")]
		bisBodyTextIndent1 = -68/*StyleBodyTextIndent*/,
		/// \brief List continue, style 1
		[helpstring("List continue, style 1.")]
		bisListContinue1 = -69/*StyleListContinue*/,
		/// \brief List continue, style 2
		[helpstring("List continue, style 2.")]
		bisListContinue2 = -70/*StyleListContinue2*/,
		/// \brief List continue, style 3
		[helpstring("List continue, style 3.")]
		bisListContinue3 = -71/*StyleListContinue3*/,
		/// \brief List continue, style 4
		[helpstring("List continue, style 4.")]
		bisListContinue4 = -72/*StyleListContinue4*/,
		/// \brief List continue, style 5
		[helpstring("List continue, style 5.")]
		bisListContinue5 = -73/*StyleListContinue5*/,
		/// \brief Message header
		[helpstring("Message header.")]
		bisMessageHeader = -74/*StyleMessageHeader*/,
		/// \brief Subtitle
		[helpstring("Subtitle.")]
		bisSubtitle = -75/*StyleSubtitle*/,
		/// \brief Salutation
		[helpstring("Salutation.")]
		bisSalutation = -76/*StyleSalutation*/,
		/// \brief Date
		[helpstring("Date.")]
		bisDate = -77/*StyleDate*/,
		/// \brief Body text, first indent, style 1
		[helpstring("Body text, first indent, style 1.")]
		bisBodyTextFirstIndent1 = -78/*StyleBodyTextFirstIndent*/,
		/// \brief Body text, first indent, style 2
		[helpstring("Body text, first indent, style 2.")]
		bisBodyTextFirstIndent2 = -79/*StyleBodyTextFirstIndent2*/,
		/// \brief Note heading
		[helpstring("Note heading.")]
		bisNoteHeading = -80/*StyleNoteHeading*/,
		/// \brief Body text, style 2
		[helpstring("Body text, style 2.")]
		bisBodyText2 = -81/*StyleBodyText2*/,
		/// \brief Body text, style 3
		[helpstring("Body text, style 3.")]
		bisBodyText3 = -82/*StyleBodyText3*/,
		/// \brief Indented body text, style 2
		[helpstring("Indented body text, style 2.")]
		bisBodyTextIndent2 = -83/*StyleBodyTextIndent2*/,
		/// \brief Indented body text, style 3
		[helpstring("Indented body text, style 3.")]
		bisBodyTextIndent3 = -84/*StyleBodyTextIndent3*/,
		/// \brief Block quotation
		[helpstring("Block quotation.")]
		bisBlockQuotation= -85/*StyleBlockQuotation*/,
		/// \brief Hyperlink
		[helpstring("Hyperlink.")]
		bisHyperlink = -86/*StyleHyperlink*/,
		/// \brief Visited hyperlink
		[helpstring("Visited hyperlink.")]
		bisHyperlinkFollowed = -87/*StyleHyperlinkFollowed*/
	} BuiltInStyleConstants;

	/// \brief <em>Constants used with the \c ChangeCase method</em>
	///
	/// \sa IRichTextRange::ChangeCase
	[helpstring("Constants used with the 'ChangeCase' method.")]
	typedef enum CaseConstants {
		/// \brief Set all letters to lowercase
		[helpstring("Set all letters to lowercase.")]
		cLowerCase = 0/*tomLowerCase*/,
		/// \brief Set all letters to uppercase
		[helpstring("Set all letters to uppercase.")]
		cUpperCase = 1/*tomUpperCase*/,
		/// \brief Capitalize the first letter of each word
		[helpstring("Capitalize the first letter of each word.")]
		cTitleCase = 2/*tomTitleCase*/,
		/// \brief Capitalize the first letter of each sentence
		[helpstring("Capitalize the first letter of each sentence.")]
		cSentenceCase = 4/*tomSentenceCase*/,
		/// \brief Toggle the case of each letter
		[helpstring("Toggle the case of each letter.")]
		cToggleCase = 5/*tomToggleCase*/
	} CaseConstants;

	/// \brief <em>Constants used with cell border specific properties</em>
	///
	/// \sa IRichTableCell::BorderColor, IRichTableCell::BorderSize
	[helpstring("Constants used with cell border specific properties.")]
	typedef enum CellBorderConstants {
		/// \brief Identifies the left border cell
		[helpstring("Identifies the left border cell.")]
		cbLeft,
		/// \brief Identifies the top border cell
		[helpstring("Identifies the top border cell.")]
		cbTop,
		/// \brief Identifies the right border cell
		[helpstring("Identifies the right border cell.")]
		cbRight,
		/// \brief Identifies the bottom border cell
		[helpstring("Identifies the bottom border cell.")]
		cbBottom
	} CellBorderConstants;

	/// \brief <em>Constants used to identify table cells within an \c IRichTableCells collection</em>
	///
	/// \sa IRichTableCells
	[helpstring("Constants used to identify table cells within a 'TableCells' collection.")]
	typedef enum CellIdentifierTypeConstants {
		/// \brief The table cell is identified by a zero-based index
		///
		/// Removing or adding table cells may change a cell's index.
		///
		/// \sa IRichTableCell::Index
		[helpstring("The table cell is identified by a zero-based index.")]
		citIndex,
		/// \brief The table cell is identified by a character index which lies within the table cell's text range
		///
		/// \sa IRichTableCell::TextRange
		[helpstring("The table cell is identified by a character index which lies within the table cell's text range.")]
		citCharacterIndex
	} CellIdentifierTypeConstants;

	/// \brief <em>Constants used with the \c IRichTableCell::MergeFlags property</em>
	///
	/// \sa IRichTableCell::MergeFlags
	[helpstring("Constants used with the 'TableCell.MergeFlags' property. They can be combined.")]
	typedef enum CellMergeConstants {
		/// \brief The cell is not merged with another cell
		[helpstring("The cell is not merged with another cell.")]
		cmNotMerged = 0,
		/// \brief The cell is the top cell in a vertically merged cell set
		[helpstring("The cell is the top cell in a vertically merged cell set.")]
		cmTopCellInVerticallyMergedSet = 1/*tomVTopCell*/,
		/// \brief The cell is part of (but not the top cell of) a vertically merged cell set
		[helpstring("The cell is part of (but not the top cell of) a vertically merged cell set.")]
		cmContinueVerticallyMergedSet = 2/*tomVLowCell*/,
		/// \brief The cell is the start cell in a horizontally merged cell set
		[helpstring("The cell is the start cell in a horizontally merged cell set.")]
		cmStartCellInHorizontallyMergedSet = 4/*tomHStartCell*/,
		/// \brief The cell is part of (but not the start cell of) a horizontally merged cell set
		[helpstring("The cell is part of (but not the start cell of) a horizontally merged cell set.")]
		cmContinueHorizontallyMergedSet = 8/*tomHContCell*/
	} CellMergeConstants;

	/// \brief <em>Constants used with the \c CharacterConversion property</em>
	///
	/// \sa IRichTextBox::CharacterConversion
	[helpstring("Constants used with the 'CharacterConversion' property.")]
	typedef enum CharacterConversionConstants {
		/// \brief The control does not convert anything
		[helpstring("The control does not convert anything.")]
		ccNone,
		/// \brief The control converts all characters to lowercase as they are typed into the control
		[helpstring("The control converts all characters to lowercase as they are typed into the control.")]
		ccLowerCase,
		/// \brief The control converts all characters to uppercase as they are typed into the control
		[helpstring("The control converts all characters to uppercase as they are typed into the control.")]
		ccUpperCase
	} CharacterConversionConstants;

	/// \brief <em>Constants used with the \c GetDataObject and \c QueryAcceptData events</em>
	///
	/// \sa _IRichTextBoxEvents::GetDataObject, _IRichTextBoxEvents::QueryAcceptData
	[helpstring("Constants used with the 'GetDataObject' and 'QueryAcceptData' events.")]
	typedef enum ClipboardOperationTypeConstants {
		/// \brief The event has been raised in context of a clipboard paste operation
		[helpstring("The event has been raised in context of a clipboard paste operation.")]
		cotPaste = 0/*RECO_PASTE*/,
		/// \brief The event has been raised in context of a drop operation
		[helpstring("The event has been raised in context of a drop operation.")]
		cotDrop = 1/*RECO_DROP*/,
		/// \brief The event has been raised in context of a clipboard copy operation
		[helpstring("The event has been raised in context of a clipboard copy operation.")]
		cotCopy = 2/*RECO_COPY*/,
		/// \brief The event has been raised in context of a clipboard cut operation
		[helpstring("The event has been raised in context of a clipboard cut operation.")]
		cotCut = 3/*RECO_CUT*/,
		/// \brief The event has been raised in context of a drag operation
		[helpstring("The event has been raised in context of a drag operation.")]
		cotDrag = 4/*RECO_DRAG*/
	} ClipboardOperationTypeConstants;

	/// \brief <em>Constants used with the \c DenoteEmptyMathArguments property</em>
	///
	/// \sa IRichTextBox::DenoteEmptyMathArguments
	[helpstring("Constants used with the 'DenoteEmptyMathArguments' property.")]
	typedef enum DenoteEmptyMathArgumentsConstants {
		/// \brief Only empty mandatory arguments are denoted by a dotted square
		[helpstring("Only empty mandatory arguments are denoted by a dotted square.")]
		demaMandatoryOnly = 0/*tomMathDocEmptyArgAuto*/,
		/// \brief Any empty arguments are denoted by a dotted square
		[helpstring("Any empty arguments are denoted by a dotted square.")]
		demaAlways = 0x20/*tomMathDocEmptyArgAlways*/,
		/// \brief Empty arguments are never denoted by a dotted square
		[helpstring("Empty arguments are never denoted by a dotted square.")]
		demaNever = 0x40/*tomMathDocEmptyArgNever*/
	} DenoteEmptyMathArgumentsConstants;

	/// \brief <em>Flags used with the \c DisabledEvents property</em>
	///
	/// \sa IRichTextBox::DisabledEvents
	[helpstring("Flags used with the 'DisabledEvents' property. They can be combined.")]
	typedef enum DisabledEventsConstants {
		/// \brief Mouse events won't be fired
		///
		/// The following events won't be fired: \c MouseDown, \c MouseUp, \c MouseEnter, \c MouseHover,
		/// \c MouseLeave, \c MouseMove, \c MouseWheel
		///
		/// \sa _IRichTextBoxEvents::MouseDown, _IRichTextBoxEvents::MouseUp, _IRichTextBoxEvents::MouseEnter,
		///     _IRichTextBoxEvents::MouseHover, _IRichTextBoxEvents::MouseLeave,
		///     _IRichTextBoxEvents::MouseMove, _IRichTextBoxEvents::MouseWheel
		[helpstring("Disables the following events: MouseDown, MouseUp, MouseEnter, MouseHover, MouseLeave, MouseMove, MouseWheel")]
		deMouseEvents = 0x01,
		/// \brief Click events won't be fired
		///
		/// The following events won't be fired: \c Click, \c DblClick, \c MClick, \c MDblClick,
		/// \c RClick, \c RDblClick, \c XClick, \c XDblClick
		///
		/// \sa _IRichTextBoxEvents::Click, _IRichTextBoxEvents::DblClick, _IRichTextBoxEvents::MClick,
		///     _IRichTextBoxEvents::MDblClick, _IRichTextBoxEvents::RClick, _IRichTextBoxEvents::RDblClick,
		///     _IRichTextBoxEvents::XClick, _IRichTextBoxEvents::XDblClick
		[helpstring("Disables the following events: Click, DblClick, MClick, MDblClick, RClick, RDblClick, XClick, XDblClick")]
		deClickEvents = 0x02,
		/// \brief Keyboard events won't be fired
		///
		/// The following events won't be fired: \c KeyDown, \c KeyUp, \c KeyPress
		///
		/// \sa _IRichTextBoxEvents::KeyDown, _IRichTextBoxEvents::KeyUp, _IRichTextBoxEvents::KeyPress
		[helpstring("Disables the following events: KeyDown, KeyUp, KeyPress")]
		deKeyboardEvents = 0x08,
		/// \brief The \c Scrolling event won't be fired
		///
		/// The following event won't be fired: \c Scrolling
		///
		/// \sa _IRichTextBoxEvents::Scrolling
		[helpstring("Disables the following event: Scrolling")]
		deScrolling = 0x800,
		/// \brief The \c TextChanged event won't be fired
		///
		/// The following event won't be fired: \c TextChanged
		///
		/// \sa _IRichTextBoxEvents::TextChanged
		[helpstring("Disables the following event: TextChanged")]
		deTextChangedEvents = 0x1000,
		/// \brief The \c ShouldResizeControlWindow event won't be fired
		///
		/// The following events won't be fired: \c ShouldResizeControlWindow
		///
		/// \sa _IRichTextBoxEvents::ShouldResizeControlWindow
		[helpstring("Disables the following event: ShouldResizeControlWindow")]
		deShouldResizeControlWindow = 0x2000,
		/// \brief Events concerning selection changes won't be fired
		///
		/// The following events won't be fired: \c SelectionChanged
		///
		/// \sa _IRichTextBoxEvents::SelectionChanged
		[helpstring("Disables the following event: SelectionChanged")]
		deSelectionChangingEvents = 0x40000
	} DisabledEventsConstants;

	/// \brief <em>Constants used with the \c IOLEObject::DisplayAspect property</em>
	///
	/// \sa IOLEObject::DisplayAspect
	[helpstring("Constants used with the 'OLEObject.DisplayAspect' property.")]
	typedef enum DisplayAspectConstants {
		/// \brief Provides a representation of the object so it can be displayed as an embedded object inside of the document
		[helpstring("Provides a representation of the object so it can be displayed as an embedded object inside of the document.")]
		daContent = 1/*DVASPECT_CONTENT*/,
		/// \brief Provides an iconic representation of the object
		[helpstring("Provides an iconic representation of the object.")]
		daIcon = 4/*DVASPECT_ICON*/
	} DisplayAspectConstants;

	/// \brief <em>Constants used with the \c IOLEDataObject::GetDropDescription and IOLEDataObject::SetDropDescription methods</em>
	///
	/// \sa IOLEDataObject::GetDropDescription, IOLEDataObject::SetDropDescription
	[helpstring("Constants used with the 'OLEDataObject.GetDropDescription' and 'OLEDataObject.SetDropDescription' methods.")]
	typedef enum DropDescriptionIconConstants {
		/// \brief No drop description is displayed
		[helpstring("No drop description is displayed.")]
		ddiNone = -1/*DROPIMAGE_INVALID*/,     // should be 8 (DROPIMAGE_NOIMAGE)
		/// \brief The drop description icon that visualizes the \c odeNone drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeNone' drop effect is displayed.")]
		ddiNoDrop = 0/*DROPIMAGE_NONE*/,
		/// \brief The drop description icon that visualizes the \c odeCopy drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeCopy' drop effect is displayed.")]
		ddiCopy = 1/*DROPIMAGE_COPY*/,
		/// \brief The drop description icon that visualizes the \c odeMove drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeMove' drop effect is displayed.")]
		ddiMove = 2/*DROPIMAGE_MOVE*/,
		/// \brief The drop description icon that visualizes the \c odeLink drop effect is displayed
		[helpstring("The drop description icon that visualizes the 'odeLink' drop effect is displayed.")]
		ddiLink = 4/*DROPIMAGE_LINK*/,
		/// \brief The drop description icon that visualizes a drop, which causes a metadata change, is displayed
		[helpstring("The drop description icon that visualizes a drop, which causes a metadata change, is displayed.")]
		ddiMetadataChange = 6/*DROPIMAGE_LABEL*/,
		/// \brief The drop description icon that visualizes a warning is displayed
		[helpstring("The drop description icon that visualizes a warning is displayed.")]
		ddiWarning = 7/*DROPIMAGE_WARNING*/,
		/// \brief The default drop description is displayed
		///
		/// \remarks Requires Windows 7 or newer.
		[helpstring("The default drop description is displayed. Requires Windows 7 or newer.")]
		ddiUseDefault = 8/*DROPIMAGE_NOIMAGE*/     // should be -1 (DROPIMAGE_INVALID)
	} DropDescriptionIconConstants;

	/// \brief <em>Constants used with the extended mouse button events</em>
	///
	/// \sa _IRichTextBoxEvents::MouseDown, _IRichTextBoxEvents::MouseEnter, _IRichTextBoxEvents::MouseHover,
	///     _IRichTextBoxEvents::MouseLeave, _IRichTextBoxEvents::MouseMove, _IRichTextBoxEvents::MouseUp,
	///     _IRichTextBoxEvents::XClick, _IRichTextBoxEvents::XDblClick
	[helpstring("Constants used with the extended mouse button events.")]
	typedef enum ExtendedMouseButtonConstants {
		/// \brief Identifies the first extended mouse button
		[helpstring("Identifies the first extended mouse button.")]
		embXButton1 = 0x20,
		/// \brief Identifies the second extended mouse button
		[helpstring("Identifies the second extended mouse button.")]
		embXButton2 = 0x40
	} ExtendedMouseButtonConstants;

	/// \brief <em>Flags used with the \c LoadFromFile and \c SaveToFile methods</em>
	///
	/// \sa IRichTextBox::LoadFromFile, IRichTextBox::SaveToFile
	[helpstring("Flags used with the 'LoadFromFile' and 'SaveToFile' methods. They can be combined.")]
	typedef enum FileAccessOptionConstants {
		/// \brief Apply default options, i.e. open the file for read/write access and read/write sharing
		[helpstring("Apply default options, i.e. open the file for read/write access and read/write sharing.")]
		faoDefault = 0,
		/// \brief Open the file in read-only mode
		[helpstring("Open the file in read-only mode.")]
		faoReadOnly = 0x0100/*tomReadOnly*/,
		/// \brief Don't allow concurrent read access to the file
		[helpstring("Don't allow concurrent read access to the file.")]
		faoShareDenyRead = 0x0200/*tomShareDenyRead*/,
		/// \brief Don't allow concurrent write access to the file
		[helpstring("Don't allow concurrent write access to the file.")]
		faoShareDenyWrite = 0x0400/*tomShareDenyWrite*/,
		/// \brief Replace the current selection with the loaded file content
		[helpstring("Replace the current selection with the loaded file content.")]
		faoReplaceSelection = 0x1000/*tomPasteFile*/
	} FileAccessOptionConstants;

	/// \brief <em>Constants used with the \c LoadFromFile and \c SaveToFile methods, controlling how the file is opened or saved</em>
	///
	/// \sa IRichTextBox::LoadFromFile, IRichTextBox::SaveToFile
	[helpstring("Constants used with the 'LoadFromFile' and 'SaveToFile' methods, controlling how the file is opened or saved.")]
	typedef enum FileCreationDispositionConstants {
		/// \brief Create a new file; fail if the file already exists
		[helpstring("Create a new file. Fail if the file already exists.")]
		fcdCreateNew = 0x10/*tomCreateNew*/,
		/// \brief Create a new file; destroy the existing file if it exists
		[helpstring("Create a new file. Destroy the existing file if it exists.")]
		fcdCreateAlways = 0x20/*tomCreateAlways*/,
		/// \brief Open an existing file; fail if the file does not exist
		[helpstring("Open an existing file. Fail if the file does not exist.")]
		fcdOpenExisting = 0x30/*tomOpenExisting*/,
		/// \brief Open an existing file; create a new file if the file does not exist.
		[helpstring("Open an existing file. Create a new file if the file does not exist.")]
		fcdOpenAlways = 0x40/*tomOpenAlways*/,
		/// \brief Open an existing file, but truncate it to zero length
		[helpstring("Open an existing file, but truncate it to zero length.")]
		fcdTruncateExisting = 0x50/*tomTruncateExisting*/
	} FileCreationDispositionConstants;

	/// \brief <em>Constants used with the \c LoadFromFile and \c SaveToFile methods, specifying the file type</em>
	///
	/// \sa IRichTextBox::LoadFromFile, IRichTextBox::SaveToFile
	[helpstring("Constants used with the 'LoadFromFile' and 'SaveToFile' methods, specifying the file type.")]
	typedef enum FileTypeConstants {
		/// \brief Detect the file type automatically
		[helpstring("Detect the file type automatically. Unrecognized file formats are treated as text.")]
		ftyAutoDetect = 0,
		/// \brief Treat the file as a RTF file
		[helpstring("Treat the file as a RTF file.")]
		ftyRTF = 1/*tomRTF*/,
		/// \brief Treat the file as a plain TXT file
		[helpstring("Treat the file as a plain TXT file.")]
		ftyText = 2/*tomText*/
		// \brief Treat the file as a HTML document
		//[helpstring("Treat the file as a HTML document.")]
		//ftyHTML = 3/*tomHTML*/,															// Not supported by RICHEDIT50W!
		// \brief Treat the file as a Word document
		//[helpstring("Treat the file as a Word document.")]
		//ftyWordDocument = 4/*tomWordDocument*/							// Not supported by RICHEDIT50W! Will destroy the document when opening it!
	} FileTypeConstants;

	/// \brief <em>Constants used with the \c IRichTextFont::Weight property</em>
	///
	/// \sa IRichTextFont::Weight
	[helpstring("Constants used with the 'TextFont.Weight' property.")]
	typedef enum FontWeightConstants {
		/// \brief The text range uses multiple font weights
		[helpstring("The text range uses multiple font weights.")]
		fwUndefined = -9999999/*tomUndefined*/,
		/// \brief The text range is drawn using the font's default font weight
		[helpstring("The text range is drawn using the font's default font weight.")]
		fwDontCare = 0/*FW_DONTCARE*/,
		/// \brief The text range is drawn using a thin font weight (100)
		[helpstring("The text range is drawn using a thin font weight (100).")]
		fwThin = 100/*FW_THIN*/,
		/// \brief The text range is drawn using an extra light font weight (200)
		[helpstring("The text range is drawn using an extra light font weight (200).")]
		fwExtraLight = 200/*FW_EXTRALIGHT*/,
		/// \brief The text range is drawn using a light font weight (300)
		[helpstring("The text range is drawn using a light font weight (300).")]
		fwLight = 300/*FW_LIGHT*/,
		/// \brief The text range is drawn using a normal font weight (400)
		[helpstring("The text range is drawn using a normal font weight (400).")]
		fwNormal = 400/*FW_NORMAL*/,
		/// \brief The text range is drawn using a medium font weight (500)
		[helpstring("The text range is drawn using a medium font weight (500).")]
		fwMedium = 500/*FW_MEDIUM*/,
		/// \brief The text range is drawn using a semi-bold font weight (600)
		[helpstring("The text range is drawn using a semi-bold font weight (600).")]
		fwSemiBold = 600/*FW_SEMIBOLD*/,
		/// \brief The text range is drawn using a bold font weight (700)
		[helpstring("The text range is drawn using a bold font weight (700).")]
		fwBold = 700/*FW_BOLD*/,
		/// \brief The text range is drawn using an extra-bold font weight (800)
		[helpstring("The text range is drawn using an extra-bold font weight (800).")]
		fwExtraBold = 800/*FW_EXTRABOLD*/,
		/// \brief The text range is drawn using a heavy font weight (900)
		[helpstring("The text range is drawn using a heavy font weight (900).")]
		fwHeavy = 900/*FW_HEAVY*/,
		/// \brief The text range is drawn using an extra heavy font weight (950)
		[helpstring("The text range is drawn using an extra heavy font weight (950).")]
		fwExtraHeavy = 950/*tomFontWeightExtraBlack*/
	} FontWeightConstants;

	/// \brief <em>Constants used with the \c HAlignment properties</em>
	///
	/// \sa IRichTextBox::DefaultMathZoneHAlignment, IRichTextParagraph::HAlignment,
	///     IRichTextParagraph::ListNumberingHAlignment, IRichTableRow::HAlignment
	[helpstring("Constants used with the 'HAlignment' properties.")]
	typedef enum HAlignmentConstants {
		/// \brief The paragraph's text alignment is 'undefined'
		///
		/// \remarks This value is valid only for the \c IRichTextParagraph::HAlignment property.
		[helpstring("The paragraph's text alignment is 'undefined'. This value is valid only for the 'TextParagraph.HAlignment' property.")]
		halUndefined = -9999999/*tomUndefined*/,
		/// \brief The control's or paragraph's content is left-aligned
		[helpstring("The control's or paragraph's content is left-aligned.")]
		halLeft = 0/*tomAlignLeft*/,
		/// \brief The control's or paragraph's content is horizontally centered
		[helpstring("The control's or paragraph's content is horizontally centered.")]
		halCenter = 1/*tomAlignCenter*/,
		/// \brief The control's or paragraph's content is right-aligned
		[helpstring("The control's or paragraph's content is right-aligned.")]
		halRight = 2/*tomAlignRight*/,
		/// \brief The spacing between the words is adjusted so that each line has the same width
		///
		/// \remarks This value is valid only for the \c IRichTextParagraph::HAlignment property.
		[helpstring("The spacing between the words is adjusted so that each line has the same width. This value is valid only for the 'TextParagraph.HAlignment' property.")]
		halJustify = 3/*tomAlignJustify*/,
		/// \brief Same as \c halNewspaper, but uses East Asian metrics
		///
		/// \remarks This value is valid only for the \c IRichTextParagraph::HAlignment property.
		[helpstring("Same as 'halNewspaper', but uses East Asian metrics. This value is valid only for the 'TextParagraph.HAlignment' property.")]
		halNewspaper = 4/*tomAlignNewspaper*/,
		/// \brief The first and last characters of each line are aligned to the left and right margins and character spacing is adjusted evenly
		///
		/// \remarks This value is valid only for the \c IRichTextParagraph::HAlignment property.
		[helpstring("The first and last characters of each line are aligned to the left and right margins and character spacing is adjusted evenly. This value is valid only for the 'TextParagraph.HAlignment' property.")]
		halInterLetter = 5/*tomAlignInterLetter*/,
		/// \brief Same as \c halNewspaper, but uses East Asian metrics and spacing is scaled by the width of characters
		///
		/// \remarks This value is valid only for the \c IRichTextParagraph::HAlignment property.
		[helpstring("Same as 'halNewspaper', but uses East Asian metrics and spacing is scaled by the width of characters. This value is valid only for the 'TextParagraph.HAlignment' property.")]
		halScaled = 6/*tomAlignScaled*/
	} HAlignmentConstants;

	/// \brief <em>Flags used with the \c HitTest method</em>
	///
	/// \sa IRichTextBox::HitTest
	[helpstring("Flags used with the 'HitTest' method.")]
	typedef enum HitTestConstants {
		/// \brief On plain text
		///
		/// The specified point lies inside the control's client area, on text, but not a link.
		///
		/// \sa htSelectedText, htLink, htBackground
		[helpstring("The specified point lies inside the control's client area, on text, but not a link.")]
		htText = 0x00000001,
		/// \brief On a link
		///
		/// The specified point lies on a link.
		///
		/// \sa htText
		[helpstring("The specified point lies on a link.")]
		htLink = 0x00000046,
		/// \brief Above the control's client area
		///
		/// The specified point lies above the control's client area.
		[helpstring("The specified point lies above the control's client area.")]
		htAbove = 0x00000100,
		/// \brief Below the control's client area
		///
		/// The specified point lies below the control's client area.
		[helpstring("The specified point lies below the control's client area.")]
		htBelow = 0x00000200,
		/// \brief To the right of the control's client area
		///
		/// The specified point lies to the right of the control's client area.
		[helpstring("The specified point lies to the right of the control's client area.")]
		htToRight = 0x00000400,
		/// \brief To the left of the control's client area
		///
		/// The specified point lies to the left of the control's client area.
		[helpstring("The specified point lies to the left of the control's client area.")]
		htToLeft = 0x00000800,
		/// \brief On the control's background
		///
		/// The specified point lies within the control's client area, but not on text.
		///
		/// \sa htText
		[helpstring("The specified point lies within the control's client area, but not on text.")]
		htBackground = 0x00020000,
		/// \brief On selected text
		///
		/// \sa htText
		[helpstring("The specified point lies on selected text.")]
		htSelectedText = 0x01000000
	} HitTestConstants;

	/// \brief <em>Constants used with the \c IRichTextRange::GetStartPosition and \c IRichTextRange::GetEndPosition methods</em>
	///
	/// \sa IRichTextRange::GetStartPosition, IRichTextRange::GetEndPosition, VerticalPositionConstants
	[helpstring("Constants used with the 'TextRange.GetStartPosition' and 'TextRange.GetEndPosition' methods.")]
	typedef enum HorizontalPositionConstants {
		/// \brief Retrieve the left edge of the bounding rectangle
		[helpstring("Retrieve the left edge of the bounding rectangle.")]
		hpLeft = 0/*TA_LEFT*/,
		/// \brief Retrieve the right edge of the bounding rectangle
		[helpstring("Retrieve the right edge of the bounding rectangle.")]
		hpRight = 2/*TA_RIGHT*/,
		/// \brief Retrieve the center of the bounding rectangle
		[helpstring("Retrieve the center of the bounding rectangle.")]
		hpCenter = 6/*TA_CENTER*/
	} HorizontalPositionConstants;

	/// \brief <em>Constants used with the \c CurrentIMECompositionMode property</em>
	///
	/// \sa IRichTextBox::CurrentIMECompositionMode
	[helpstring("Constants used with the 'CurrentIMECompositionMode' property.")]
	typedef enum IMECompositionModeConstants {
		/// \brief Input Method Editor is not open
		[helpstring("Input Method Editor is not open.")]
		imecomNotOpen = 0x0000/*ICM_NOTOPEN*/,
		/// \brief Input Method Editor is in true inline mode
		[helpstring("Input Method Editor is in true inline mode.")]
		imecomLevel3 = 0x0001/*ICM_LEVEL3*/,
		/// \brief Input Method Editor is in level 2 mode
		[helpstring("Input Method Editor is in level 2 mode.")]
		imecomLevel2 = 0x0002/*ICM_LEVEL2*/,
		/// \brief Input Method Editor is in level 2.5 mode
		[helpstring("Input Method Editor is in level 2.5 mode.")]
		imecomLevel2Point5 = 0x0003/*ICM_LEVEL2_5*/,
		/// \brief Input Method Editor is in level 2 mode with special UI
		[helpstring("Input Method Editor is in level 2 mode with special UI.")]
		imecomLevel2WithSpecialUI = 0x0004/*ICM_LEVEL2_SUI*/,
		/// \brief Input Method Editor is in complex text framework mode
		[helpstring("Input Method Editor is in complex text framework mode.")]
		imecomCTF = 0x0005/*ICM_CTF*/
	} IMECompositionModeConstants;

	/// \brief <em>Constants used with the \c GetCurrentIMECompositionText method</em>
	///
	/// \sa IRichTextBox::GetCurrentIMECompositionText
	[helpstring("Constants used with the 'CurrentIMECompositionMode' method.")]
	typedef enum IMECompositionTextType {
		/// \brief The final composed string
		[helpstring("The final composed string.")]
		imecttFinalComposedString = 1/*ICT_RESULTREADSTR*/
	} IMECompositionTextType;

	/// \brief <em>Constants used with the \c IMEConversionMode property</em>
	///
	/// \sa IRichTextBox::IMEConversionMode
	[helpstring("Constants used with the 'IMEConversionMode' property.")]
	typedef enum IMEConversionModeConstants {
		/// \brief The IME conversion mode is not explicitly specified
		[helpstring("The IME conversion mode is not explicitly specified.")]
		imecmDefault = 0x0000/*not documented*/,
		/// \brief The IME conversion mode is set to "Bias for Names"
		[helpstring("The IME conversion mode is set to 'Bias for Names'.")]
		imecmBiasForNames = 0x0001/*IMF_SMODE_PLAURALCLAUSE*/,
		/// \brief The IME conversion mode is set to "No Conversion"
		[helpstring("The IME conversion mode is set to 'No Conversion'.")]
		imecmNoConversion = 0x0002/*IMF_SMODE_NONE*/
	} IMEConversionModeConstants;

	/// \brief <em>Constants used with the \c IMEMode property</em>
	///
	/// \sa IRichTextBox::IMEMode
	[helpstring("Constants used with the 'IMEMode' property.")]
	typedef enum IMEModeConstants {
		/// \brief Use the same IME settings as the control's parent
		[helpstring("Inherit the IME status from the control's parent.")]
		imeInherit = -1,
		/// \brief Don't change anything on the control's default IME settings
		[helpstring("Leaves the control's IME status untouched.")]
		imeNoControl = 0,
		/// \brief Set the control's IME status to "on"
		[helpstring("Sets the control's IME status to \"on\".")]
		imeOn = 1,
		/// \brief Set the control's IME status to "off"
		[helpstring("Sets the control's IME status to \"off\".")]
		imeOff = 2,
		/// \brief Don't use IME
		[helpstring("Disables IME for the control.")]
		imeDisable = 3,
		/// \brief Set the control's IME status to "Hiragana Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Japanese.
		[helpstring("Sets the control's IME status to \"Hiragana Double-Byte Characters\" (Japanese IME only).")]
		imeHiragana = 4,
		/// \brief Set the control's IME status to "Hiragana Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Japanese.
		[helpstring("Sets the control's IME status to \"Katakana Double-Byte Characters\" (Japanese IME only).")]
		imeKatakana = 5,
		/// \brief Set the control's IME status to "Katakana Single-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Japanese.
		[helpstring("Sets the control's IME status to \"Katakana Single-Byte Characters\" (Japanese IME only).")]
		imeKatakanaHalf = 6,
		/// \brief Set the control's IME status to "Alphanumeric Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean or Japanese.
		[helpstring("Sets the control's IME status to \"Alphanumeric Double-Byte Characters\" (Korean and Japanese IME only).")]
		imeAlphaFull = 7,
		/// \brief Set the control's IME status to "Alphanumeric Single-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean or Japanese.
		[helpstring("Sets the control's IME status to \"Alphanumeric Single-Byte Characters\" (Korean and Japanese IME only).")]
		imeAlpha = 8,
		/// \brief Set the control's IME status to "Hangul Single-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean.
		[helpstring("Sets the control's IME status to \"Hangul Single-Byte Characters\" (Korean IME only).")]
		imeHangulFull = 9,
		/// \brief Set the control's IME status to "Hangul Double-Byte Characters"
		///
		/// \remarks This flag is valid only if the input language is Korean.
		[helpstring("Sets the control's IME status to \"Hangul Double-Byte Characters\" (Korean IME only).")]
		imeHangul = 10
	} IMEModeConstants;

	/// \brief <em>Constants used with the \c IntegralLimitsLocation and \c NAryLimitsLocation properties</em>
	///
	/// \sa IRichTextBox::IntegralLimitsLocation, IRichTextBox::NAryLimitsLocation
	[helpstring("Constants used with the 'IntegralLimitsLocation' and 'NAryLimitsLocation' properties.")]
	typedef enum LimitsLocationConstants {
		/// \brief Display the operation limits on the side of the operator sign
		[helpstring("Display the operation limits on the side of the operator sign.")]
		llOnSide = 0,
		/// \brief Display the operation limits under and over the operator sign
		[helpstring("Display the operation limits under and over the operator sign.")]
		llUnderAndOver = 1
	} LimitsLocationConstants;

	/// \brief <em>Constants used with the \c LineSpacingRule property</em>
	///
	/// \sa IRichTextParagraph::LineSpacingRule
	[helpstring("Constants used with the 'LineSpacingRule' property.")]
	typedef enum LineSpacingRuleConstants {
		/// \brief The paragraph's line-spacing rule is 'undefined'
		[helpstring("The paragraph's line-spacing rule is 'undefined'.")]
		lsrUndefined = -9999999/*tomUndefined*/,
		/// \brief Use a single space
		///
		/// \remarks The value of the \c IRichTextParagraph::LineSpacing property is ignored.
		///
		/// \sa IRichTextParagraph::LineSpacing
		[helpstring("Use a single space. The value of the 'LineSpacing' property is ignored.")]
		lsrSingle = 0/*tomLineSpaceSingle*/,
		/// \brief Use one and a half space
		///
		/// \remarks The value of the \c IRichTextParagraph::LineSpacing property is ignored.
		///
		/// \sa IRichTextParagraph::LineSpacing
		[helpstring("Use one and a half space. The value of the 'LineSpacing' property is ignored.")]
		lsr1pt5 = 1/*tomLineSpace1pt5*/,
		/// \brief Use a double space
		///
		/// \remarks The value of the \c IRichTextParagraph::LineSpacing property is ignored.
		///
		/// \sa IRichTextParagraph::LineSpacing
		[helpstring("Use a double space. The value of the 'LineSpacing' property is ignored.")]
		lsrDouble = 2/*tomLineSpaceDouble*/,
		/// \brief Use the maximum of single-space and the value specified by the \c LineSpacing property
		///
		/// \sa IRichTextParagraph::LineSpacing
		[helpstring("Use the maximum of single-space and the value specified by the 'LineSpacing' property.")]
		lsrAtLeastSingle = 3/*tomLineSpaceAtLeast*/,
		/// \brief Use exactly the value specified by the \c LineSpacing property
		///
		/// \sa IRichTextParagraph::LineSpacing
		[helpstring("Use exactly the value specified by the 'LineSpacing' property.")]
		lsrExactly = 4/*tomLineSpaceExactly*/,
		/// \brief The \c LineSpacing property specifies the line spacing in lines
		///
		/// \sa IRichTextParagraph::LineSpacing
		[helpstring("The 'LineSpacing' property specifies the line spacing in lines.")]
		lsrMultiple = 5/*tomLineSpaceMultiple*/,
		/// \brief The \c LineSpacing property specifies the line spacing by percent of line height
		///
		/// \sa IRichTextParagraph::LineSpacing
		[helpstring("The 'LineSpacing' property specifies the line spacing by percent of line height.")]
		lsrPercent = 6/*tomLineSpacePercent*/
	} LineSpacingRuleConstants;

	/// \brief <em>Constants used with the \c ListNumberingStyle property</em>
	///
	/// \sa IRichTextParagraph::ListNumberingStyle
	[helpstring("Constants used with the 'ListNumberingStyle' property.")]
	typedef enum ListNumberingStyleConstants {
		/// \brief The paragraph's list-numbering style is 'undefined'
		[helpstring("The paragraph's line-numbering style is 'undefined'.")]
		lnsUndefined = -9999999/*tomUndefined*/,
		/// \brief Mask to extract numbering styles
		///
		/// This constant can be used to extract the numbering style, e.g. (ListNumberingStyle & lnsTypeMask)==lnsBullet
		[helpstring("This constant can be used to extract the numbering style, e.g. (ListNumberingStyle And lnsTypeMask)=lnsBullet.")]
		lnsTypeMask = 0x0000FFFF,
		/// \brief The paragraph is not a list
		[helpstring("The paragraph is not a list.")]
		lnsNoList = 0/*tomListNone*/,
		/// \brief Use bullets (unicode code point 0x2022) to number list items
		[helpstring("Use bullets (unicode code point 0x2022) to number list items.")]
		lnsBullet = 1/*tomListBullet*/,
		/// \brief Use arabic numerals (0, 1, 2, ...) to number list items
		[helpstring("Use arabic numerals (0, 1, 2, ...) to number list items.")]
		lnsArabicNumbers = 2/*tomListNumberAsArabic*/,
		/// \brief Use lowercase letters (a, b, c, ...) to number list items
		[helpstring("Use lowercase letters (a, b, c, ...) to number list items.")]
		lnsLowerCaseLetters = 3/*tomListNumberAsLCLetter*/,
		/// \brief Use uppercase letters (A, B, C, ...) to number list items
		[helpstring("Use uppercase letters (A, B, C, ...) to number list items.")]
		lnsUpperCaseLetters = 4/*tomListNumberAsUCLetter*/,
		/// \brief Use lowercase roman letters (i, ii, iii, ...) to number list items
		[helpstring("Use lowercase roman letters (i, ii, iii, ...) to number list items.")]
		lnsLowerCaseRomanLetters = 5/*tomListNumberAsLCRoman*/,
		/// \brief Use uppercase roman letters (I, II, III, ...) to number list items
		[helpstring("Use uppercase roman letters (I, II, III, ...) to number list items.")]
		lnsUpperCaseRomanLetters = 6/*tomListNumberAsUCRoman*/,
		/// \brief The value specified by the \c ListNumberingStart property is treated as the first code in a Unicode sequence
		///
		/// \remarks This can be used to use different kinds of bullets.
		///
		/// \sa IRichTextParagraph::ListNumberingStart
		[helpstring("The value specified by the 'ListNumberingStart' property is treated as the first code in a Unicode sequence. For instance this can be used to use different kinds of bullets.")]
		lnsCustomSequence = 7/*tomListNumberAsSequence*/,
		/// \brief Use circled numbers to number list items
		[helpstring("Use circled numbers to number list items.")]
		lnsCircledNumbers = 8/*tomListNumberedCircle*/,
		/// \brief Use black circled digits, from the Wingdings font, to number list items
		[helpstring("Use black circled digits, from the Wingdings font, to number list items.")]
		lnsWingdingsBlackCircledNumbers = 9/*tomListNumberedBlackCircleWingding*/,
		/// \brief Use white circled digits, from the Wingdings font, to number list items
		[helpstring("Use white circled digits, from the Wingdings font, to number list items.")]
		lnsWingdingsWhiteCircledNumbers = 10/*tomListNumberedWhiteCircleWingding*/,
		/// \brief Use full-width arabic numerals (0, 1, 2, ...) to number list items
		[helpstring("Use full-width arabic numerals (0, 1, 2, ...) to number list items.")]
		lnsFullWidthArabicNumbers = 11/*tomListNumberedArabicWide*/,
		/// \brief Use chinese numbers, with 十 only in items 10 through 99 (一, 二, 三, 四, ...), to number list items
		[helpstring("Use chinese numbers, with 十 only in items 10 through 99 (一, 二, 三, 四, ...), to number list items.")]
		lnsChineseNumbers1 = 12/*tomListNumberedChS*/,
		/// \brief Use chinese numbers, with 十 only in items 10 through 19, to number list items
		[helpstring("Use chinese numbers, with 十 only in items 10 through 19, to number list items.")]
		lnsChineseNumbers2 = 13/*tomListNumberedChT*/,
		/// \brief Use chinese numbers, with a full-width period and without 十, to number list items
		[helpstring("Use chinese numbers, with a full-width period and without 十, to number list items.")]
		lnsChineseJapaneseNumbers = 14/*tomListNumberedJpnChS*/,
		/// \brief Use chinese numbers, without 十, to number list items
		[helpstring("Use chinese numbers, without 十, to number list items.")]
		lnsChineseKoreanNumbers = 15/*tomListNumberedJpnKor*/,
		/// \brief Use arabic alphabet (أ ,ب ,ت ,ث, ...) to number list items
		[helpstring("Use arabic alphabet (أ ,ب ,ت ,ث, ...) to number list items.")]
		lnsArabicAlphabet = 16/*tomListNumberedArabic1*/,
		/// \brief Use arabic abjadi (أ ,ب ,ج ,د, ...) to number list items
		[helpstring("Use arabic abjadi (أ ,ب ,ج ,د, ...) to number list items.")]
		lnsArabicAbjadi = 17/*tomListNumberedArabic2*/,
		/// \brief Use hebrew alphabet (א, ב, ג, ד, ...) to number list items
		[helpstring("Use hebrew alphabet (א, ב, ג, ד, ...) to number list items.")]
		lnsHebrewAlphabet = 18/*tomListNumberedHebrew*/,
		/// \brief Use thai alphabet (ก, ข,ค, ง, ...) to number list items
		[helpstring("Use thai alphabet (ก, ข,ค, ง, ...) to number list items.")]
		lnsThaiAlphabet = 19/*tomListNumberedThaiAlpha*/,
		/// \brief Use thai numbers (๑, ๒,๓, ๔, ...) to number list items
		[helpstring("Use thai numbers (๑, ๒,๓, ๔, ...) to number list items.")]
		lnsThaiNumbers = 20/*tomListNumberedThaiNum*/,
		/// \brief Use hindi vowels (अ, आ, इ, ई, ...) to number list items
		[helpstring("Use hindi vowels (अ, आ, इ, ई, ...) to number list items.")]
		lnsHindiVowels = 21/*tomListNumberedHindiAlpha*/,
		/// \brief Use hindi consonants (क, ख, ग, घ, ...) to number list items
		[helpstring("Use hindi consonants (क, ख, ग, घ, ...) to number list items.")]
		lnsHindiConsonants = 22/*tomListNumberedHindiAlpha1*/,
		/// \brief Use hindi numbers (१, २, ३, ४, ...) to number list items
		[helpstring("Use hindi numbers (१, २, ३, ४, ...) to number list items.")]
		lnsHindiNumbers = 23/*tomListNumberedHindiNum*/,

		/// \brief Mask to extract additional styles
		///
		/// This constant can be used to extract the additional style, e.g. (ListNumberingStyle & lnsAddMask)==lnsAddEncloseInParentheses
		[helpstring("This constant can be used to extract the additional style, e.g. (ListNumberingStyle And lnsAddMask)=lnsAddEncloseInParentheses.")]
		lnsAddMask = 0xFFFF0000,
		/// \brief Additional style: Enclose the number in parentheses, e.g. \c (1)
		///
		/// This is an additional style which can be added to the normal style, e.g.
		/// lnsArabicNumbers+lnsAddEncloseInParentheses.
		[helpstring("Enclose the number in parentheses, e.g. '(1)'. This is an additional style.")]
		lnsAddEncloseInParentheses = 0x10000/*tomListParentheses*/,
		/// \brief Additional style: Follow the number with a period, e.g. \c 1.
		///
		/// This is an additional style which can be added to the normal style, e.g.
		/// lnsArabicNumbers+lnsAddFollowedByPeriod.
		[helpstring("Follow the number with a period, e.g. '1.' This is an additional style.")]
		lnsAddFollowedByPeriod = 0x20000/*tomListPeriod*/,
		/// \brief Additional style: Use the number alone, e.g. \c 1
		///
		/// This is an additional style which can be added to the normal style, e.g.
		/// lnsArabicNumbers+lnsAddNumberOnly.
		[helpstring("Use the number alone, e.g. '1'. This is an additional style.")]
		lnsAddNumberOnly = 0x30000/*tomListPlain*/,
		/// \brief Additional style: Use no numbers, so that the list items appear as list items, but without any numbering
		///
		/// This is an additional style which can be added to the normal style, e.g.
		/// lnsArabicNumbers+lnsAddNoNumbers.
		[helpstring("Use no numbers, so that the list items appear as list items, but without any numbering. This is an additional style.")]
		lnsAddNoNumbers = 0x40000/*tomListNoNumber*/,
		/// \brief Additional style: Follow the number with a hyphen, e.g. \c 1-.
		///
		/// This is an additional style which can be added to the normal style, e.g.
		/// lnsArabicNumbers+lnsAddFollowedByHyphen.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.
		[helpstring("Follow the number with a hyphen, e.g. '1-' This is an additional style. Requires Rich Edit 7.5 or newer.")]
		lnsAddFollowedByHyphen = 0x80000/*tomListMinus*/
		/// \brief Additional style: ?? (Has to do something with Windows CE)
		//
		// This is an additional style which can be added to the normal style, e.g.
		// lnsArabicNumbers+lnsAddIgnoreNumberStyle.
		//[helpstring("Follow the number with a hyphen, e.g. '1-' This is an additional style.")]
		//lnsAddIgnoreNumberStyle = 0x1000000/*tomIgnoreNumberStyle*/
	} ListNumberingStyleConstants;

	/// \brief <em>Constants used with the \c MathLineBreakBehavior property</em>
	///
	/// \sa IRichTextBox::MathLineBreakBehavior
	[helpstring("Constants used with the 'MathLineBreakBehavior' property.")]
	typedef enum MathLineBreakBehaviorConstants {
		/// \brief Insert line breaks before binary or relational operators
		[helpstring("Insert line breaks before binary or relational operators.")]
		mlbbBreakBeforeOperator = 0/*tomMathBrkBinBefore*/,
		/// \brief Insert line breaks after binary or relational operators
		[helpstring("Insert line breaks after binary or relational operators.")]
		mlbbBreakAfterOperator = 0x10000/*tomMathBrkBinAfter*/,
		/// \brief Duplicate binary or relational operators and insert line breaks in between
		///
		/// \remarks If the operation is a substraction, a minus sign will be inserted on both lines.
		[helpstring("Duplicate binary or relational operators and insert line breaks in between. If the operation is a substraction, a minus sign will be inserted on both lines.")]
		mlbbDuplicateOperatorMinusMinus = 0x20000 | 0/*tomMathBrkBinDup | tomMathBrkBinSubMM*/,
		/// \brief Duplicate binary or relational operators and insert line breaks in between
		///
		/// \remarks If the operation is a substraction, the first line will end with a plus and the second
		///          line will start with a minus sign.
		[helpstring("Duplicate binary or relational operators and insert line breaks in between. If the operation is a substraction, the first line will end with a plus and the second line will start with a minus sign.")]
		mlbbDuplicateOperatorPlusMinus = 0x20000 | 0x40000/*tomMathBrkBinDup | tomMathBrkBinSubPM*/,
		/// \brief Duplicate binary or relational operators and insert line breaks in between
		///
		/// \remarks If the operation is a substraction, the first line will end with a minus and the second
		///          line will start with a plus sign.
		[helpstring("Duplicate binary or relational operators and insert line breaks in between. If the operation is a substraction, the first line will end with a minus and the second line will start with a plus sign.")]
		mlbbDuplicateOperatorMinusPlus = 0x20000 | 0x80000/*tomMathBrkBinDup | tomMathBrkBinSubMP*/
	} MathLineBreakBehaviorConstants;

	/// \brief <em>Flags used with the \c ContextMenu event</em>
	///
	/// \sa _IRichTextBoxEvents::ContextMenu
	[helpstring("Flags used with the 'ContextMenu' event. They can be combined.")]
	typedef enum MenuTypeConstants {
		/// \brief The menu has been invoked by tapping a touch gripper handle
		[helpstring("The menu has been invoked by tapping a touch gripper handle.")]
		mtTouchGripper = 0x00000001/*GCMF_GRIPPER*/,
		/// \brief The menu for a spelling error is being requested
		[helpstring("The menu for a spelling error is being requested.")]
		mtSpellingError = 0x00000002/*GCMF_SPELLING*/,
		/// \brief The menu has been invoked by mouse
		[helpstring("The menu has been invoked by mouse.")]
		mtMouseMenu = 0x00002000/*GCMF_MOUSEMENU*/,
		/// \brief The menu has been invoked by touch
		[helpstring("The menu has been invoked by touch.")]
		mtTouchMenu = 0x00004000/*GCMF_TOUCHMENU*/
	} MenuTypeConstants;

	/// \brief <em>Constants used with the \c MousePointer property</em>
	///
	/// \sa IRichTextBox::MousePointer, IRichTextBox::LinkMousePointer
	[helpstring("Constants used with the 'MousePointer' property.")]
	typedef enum MousePointerConstants {
		/// \brief The default mouse cursor is used
		[helpstring("The default mouse cursor is used.")]
		mpDefault,
		/// \brief The default arrow is used as mouse cursor
		[helpstring("The default arrow is used as mouse cursor.")]
		mpArrow,
		/// \brief A cross is used as mouse cursor
		[helpstring("A cross is used as mouse cursor.")]
		mpCross,
		/// \brief A vertical beam (like in textboxes) is used as mouse cursor
		[helpstring("A vertical beam (like in textboxes) is used as mouse cursor.")]
		mpIBeam,
		/// \brief An icon is used as mouse cursor
		[helpstring("An icon is used as mouse cursor.")]
		mpIcon,
		/// \brief A mouse cursor indicating window sizing is used
		[helpstring("A mouse cursor indicating window sizing is used.")]
		mpSize,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-right or lower-left corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-right or lower-left corner is used.")]
		mpSizeNESW,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its upper or
		/// lower border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper or lower border is used.")]
		mpSizeNS,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its
		/// upper-left or lower-right corner.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's upper-left or lower-right corner is used.")]
		mpSizeNWSE,
		/// \brief A mouse cursor indicating window sizing is used
		///
		/// This is the cursor that is used while resizing a window into the direction of its left or
		/// right border.
		[helpstring("A mouse cursor indicating window sizing to the direction of a window's left or right border is used.")]
		mpSizeEW,
		/// \brief An arrow pointing upwardly is used as mouse cursor
		[helpstring("An arrow pointing upwardly is used as mouse cursor.")]
		mpUpArrow,
		/// \brief An hourglass is used as mouse cursor
		[helpstring("An hourglass is used as mouse cursor.")]
		mpHourglass,
		/// \brief An mouse cursor indicating that the control can't be a drop target is used
		[helpstring("An mouse cursor indicating that the control can't be a drop target is used.")]
		mpNoDrop,
		/// \brief The default arrow with a small hourglass is used as mouse cursor
		[helpstring("The default arrow with a small hourglass is used as mouse cursor.")]
		mpArrowHourglass,
		/// \brief The default arrow with a small question mark is used as mouse cursor
		[helpstring("The default arrow with a small question mark is used as mouse cursor.")]
		mpArrowQuestion,
		/// \brief A mouse cursor indicating window sizing to all directions is used
		[helpstring("A mouse cursor indicating window sizing to all directions is used.")]
		mpSizeAll,
		/// \brief A hand typically used for hyperlinks is used as mouse cursor
		[helpstring("A hand typically used for hyperlinks is used as mouse cursor.")]
		mpHand,
		/// \brief A mouse cursor indicating that the program waits for some media is used
		[helpstring("A mouse cursor indicating that the program waits for some media is used.")]
		mpInsertMedia,
		/// \brief A mouse cursor indicating scrolling to all directions is used
		[helpstring("A mouse cursor indicating scrolling to all directions is used.")]
		mpScrollAll,
		/// \brief A mouse cursor indicating scrolling upwardly is used
		[helpstring("A mouse cursor indicating scrolling upwardly is used.")]
		mpScrollN,
		/// \brief A mouse cursor indicating scrolling to the window's upper-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-right corner is used.")]
		mpScrollNE,
		/// \brief A mouse cursor indicating scrolling to the window's right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's right border is used.")]
		mpScrollE,
		/// \brief A mouse cursor indicating scrolling to the window's lower-right corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-right corner is used.")]
		mpScrollSE,
		/// \brief A mouse cursor indicating scrolling downwards is used
		[helpstring("A mouse cursor indicating scrolling downwards is used.")]
		mpScrollS,
		/// \brief A mouse cursor indicating scrolling to the window's lower-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's lower-left corner is used.")]
		mpScrollSW,
		/// \brief A mouse cursor indicating scrolling to the window's left border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left border is used.")]
		mpScrollW,
		/// \brief A mouse cursor indicating scrolling to the window's upper-left corner is used
		[helpstring("A mouse cursor indicating scrolling to the window's upper-left corner is used.")]
		mpScrollNW,
		/// \brief A mouse cursor indicating scrolling upwardly or downwards is used
		[helpstring("A mouse cursor indicating scrolling upwardly or downwards is used.")]
		mpScrollNS,
		/// \brief A mouse cursor indicating scrolling to the window's left or right border is used
		[helpstring("A mouse cursor indicating scrolling to the window's left or right border is used.")]
		mpScrollEW,
		/// \brief The custom mouse cursor defined by the \c MouseIcon property is used
		[helpstring("The custom mouse cursor defined by the MouseIcon property is used.")]
		mpCustom = 0x63
	} MousePointerConstants;

	/// \brief <em>Constants used with the \c IRichTextRange::FindText method</em>
	///
	/// \sa IRichTextRange::FindText
	[helpstring("Constants used with the 'TextRange.FindText' method.")]
	typedef enum MoveRangeBoundariesConstants {
		/// \brief Move the text range to the matched string
		[helpstring("Move the text range to the matched string.")]
		mrbMoveBoth = 0,
		/// \brief Move the text range's start position to the matched string's start, but don't move the range's end position
		[helpstring("Move the text range's start position to the matched string's start, but don't move the range's end position.")]
		mrbMoveStartOnly = 1,
		/// \brief Move the text range's end position to the matched string's end, but don't move the range's start position
		[helpstring("Move the text range's end position to the matched string's end, but don't move the range's start position.")]
		mrbMoveEndOnly = 2
	} MoveRangeBoundariesConstants;

	/// \brief <em>Constants used to identify OLE objects within an \c IRichOLEObjects collection</em>
	///
	/// \sa IRichOLEObjects
	[helpstring("Constants used to identify OLE objects within an 'OLEObjects' collection.")]
	typedef enum ObjectIdentifierTypeConstants {
		/// \brief The embedded OLE object is identified by a zero-based index
		///
		/// Removing or adding embedded OLE objects may change an object's index.
		///
		/// \sa IRichOLEObject::Index
		[helpstring("The embedded OLE object is identified by a zero-based index.")]
		oitIndex
	} ObjectIdentifierTypeConstants;

	/// \brief <em>Constants used with the \c OLEQueryContinueDrag event</em>
	///
	/// \sa _IRichTextBoxEvents::OLEQueryContinueDrag, _IRichTextBoxEvents::OLEGiveFeedback,
	///     IRichTextBox::OLEDrag
	[helpstring("Constants used with the OLEQueryContinueDrag event.")]
	typedef enum OLEActionToContinueWithConstants {
		/// \brief Continue the drag'n'drop operation
		[helpstring("Continue the drag'n'drop operation.")]
		oatcwContinue = 0x0 /*S_OK*/,
		/// \brief Cancel the drag'n'drop operation
		[helpstring("Cancel the drag'n'drop operation.")]
		oatcwCancel = 0x40101 /*DRAGDROP_S_CANCEL*/,
		/// \brief Complete the drag'n'drop operation
		[helpstring("Complete the drag'n'drop operation.")]
		oatcwDrop = 0x40100 /*DRAGDROP_S_DROP*/
	} OLEActionToContinueWithConstants;

	/// \brief <em>Constants used with the \c OLEDragImageStyle property</em>
	///
	/// \sa IRichTextBox::OLEDragImageStyle
	[helpstring("Constants used with the 'OLEDragImageStyle' property.")]
	typedef enum OLEDragImageStyleConstants {
		/// \brief OLE drag images will be generated in classic style
		[helpstring("OLE drag images will be generated in classic style.")]
		odistClassic,
		/// \brief OLE drag images will be generated in Aero (Vista) style on systems supporting it and in classic style on other systems
		///
		/// \remarks Aero style is supported by Windows Vista and newer systems.
		[helpstring("OLE drag images will be generated in Aero (Vista) style on systems supporting it and in classic style on other systems. Aero style is supported by Windows Vista and newer systems.")]
		odistAeroIfAvailable
	} OLEDragImageStyleConstants;

	/// \brief <em>Constants used with OLE drag'n'drop</em>
	///
	/// \sa _IRichTextBoxEvents::OLEDragEnter, _IRichTextBoxEvents::OLEDragMouseMove,
	///     _IRichTextBoxEvents::OLEDragDrop
	[helpstring("Constants used with the OLEDrag* events.")]
	typedef enum OLEDropEffectConstants {
		/// \brief No OLE drag and drop operation has occurred or will occur
		[helpstring("No OLE drag and drop operation has occurred or will occur.")]
		odeNone = 0 /*DROPEFFECT_NONE*/,
		/// \brief A copy has occured or will occur
		[helpstring("A copy has occured or will occur.")]
		odeCopy = 1 /*DROPEFFECT_COPY*/,
		/// \brief A move has occured or will occur
		[helpstring("A move has occured or will occur.")]
		odeMove = 2 /*DROPEFFECT_MOVE*/,
		/// \brief A link has occured or will occur
		[helpstring("A link has occured or will occur.")]
		odeLink = 4 /*DROPEFFECT_LINK*/,
		/// \brief Combination of \c odeCopy and \c odeMove
		[helpstring("Combination of 'odeCopy' and 'odeMove'.")]
		odeCopyOrMove = odeCopy | odeMove,
		/// \brief The drop target window has scrolled or will scroll
		[helpstring("The drop target window has scrolled or will scroll.")]
		odeScroll = 0x80000000 /*DROPEFFECT_SCROLL*/
	} OLEDropEffectConstants;

	/// \brief <em>Flags used with the \c IRichOLEObject::Flags property</em>
	///
	/// \sa IRichOLEObject::Flags
	[helpstring("Flags used with the 'OLEObject.Flags' property. They can be combined.")]
	typedef enum OLEObjectFlagsConstants {
		/// \brief No specific flags
		[helpstring("No specific flags.")]
		oofNone = 0x00000000L/*REO_NULL*/,
		/// \brief The object may be resized
		[helpstring("The object may be resized.")]
		oofResizable = 0x00000001L/*REO_RESIZABLE*/,
		/// \brief The object sits below the baseline of the surrounding text; the default is to sit on the baseline
		[helpstring("The object sits below the baseline of the surrounding text; the default is to sit on the baseline.")]
		oofBelowBaseline = 0x00000002L/*REO_BELOWBASELINE*/,
		/// \brief The object is to be drawn entirely inverted when selected; the default is to be drawn with a border
		[helpstring("The object is to be drawn entirely inverted when selected; the default is to be drawn with a border.")]
		oofInvertedSelect = 0x00000004L/*REO_INVERTEDSELECT*/,
		/// \brief The object always determines its extents and may change despite the modify flag being turned off
		[helpstring("The object always determines its extents and may change despite the modify flag being turned off.")]
		oofDynamicSize = 0x00000008L/*REO_DYNAMICSIZE*/,
		/// \brief The object is new
		[helpstring("The object is new.")]
		oofBlank = 0x00000010L/*REO_BLANK*/,
		/// \brief The object is rendered before the creation and realization of a half-tone palette
		[helpstring("The object is rendered before the creation and realization of a half-tone palette.")]
		oofDoesNotNeedPalette = 0x00000020L/*REO_DONTNEEDPALETTE*/,
		/// \brief The owner draws the object if it is selected
		[helpstring("The owner draws the object if it is selected.")]
		oofOwnerDrawnIfSelected = 0x00000040L/*REO_OWNERDRAWSELECT*/,
		/// \brief The object can display itself in a rotated position
		[helpstring("The object can display itself in a rotated position.")]
		oofCanRotate = 0x00000080L/*REO_CANROTATE*/,
		/// \brief Align the object with the right side of the view
		///
		/// \remarks This value is ignored if \c ofWrapTextAroundObject is not specified.
		[helpstring("Align the object with the right side of the view. This value is ignored if 'ofWrapTextAroundObject' is not specified.")]
		oofAlignToRight = 0x00000100L/*REO_ALIGNTORIGHT*/,
		/// \brief Wrap text around the object
		[helpstring("Wrap text around the object.")]
		oofWrapTextAroundObject = 0x00000200L/*REO_WRAPTEXTAROUND*/,
		/// \brief Use the object as the background picture
		[helpstring("Use the object as the background picture.")]
		oofUseAsBackground = 0x00000400L/*REO_USEASBACKGROUND*/,
		/// \brief The rich edit control retrieved the metafile from the object to correctly determine the object's extents
		///
		/// \remarks This flag can be read but not set.
		[helpstring("The rich edit control retrieved the metafile from the object to correctly determine the object's extents. This flag can be read but not set.")]
		oofGotMetafileToDetermineExtents = 0x00400000L/*REO_GETMETAFILE*/,
		/// \brief The object is a link and is believed to be available
		///
		/// \remarks This flag can be read but not set.
		[helpstring("The object is a link and is believed to be available. This flag can be read but not set.")]
		oofIsAnAvailableLink = 0x00800000L/*REO_LINKAVAILABLE*/,
		/// \brief The object is currently highlighted to indicate selection
		///
		/// \remarks This flag can be read but not set.
		[helpstring("The object is currently highlighted to indicate selection. This flag can be read but not set.")]
		oofIsHilighted = 0x01000000L/*REO_HILITED*/,
		/// \brief The object is currently inplace active
		///
		/// \remarks This flag can be read but not set.
		[helpstring("The object is currently inplace active. This flag can be read but not set.")]
		oofIsInPlaceActive = 0x02000000L/*REO_INPLACEACTIVE*/,
		/// \brief The object is currently open in its server
		///
		/// \remarks This flag can be read but not set.
		[helpstring("The object is currently open in its server. This flag can be read but not set.")]
		oofIsOpened = 0x04000000L/*REO_OPEN*/,
		/// \brief The object is selected
		///
		/// \remarks This flag can be read but not set.
		[helpstring("The object is selected. This flag can be read but not set.")]
		oofIsSelected = 0x08000000L/*REO_SELECTED*/,
		/// \brief The object is a static object
		///
		/// \remarks This flag can be read but not set.
		[helpstring("The object is a static object. This flag can be read but not set.")]
		oofIsStatic = 0x40000000L/*REO_STATIC*/,
		/// \brief The object is a link
		///
		/// \remarks This flag can be read but not set.
		[helpstring("The object is a link. This flag can be read but not set.")]
		oofIsLink = 0x80000000L/*REO_LINK*/,
	} OLEObjectFlagsConstants;

	/// \brief <em>Constants used with the \c OLEObject::TypeName property</em>
	///
	/// \sa IRichOLEObject::TypeName
	[helpstring("Constants used with the 'OLEObject.TypeName' property.")]
	typedef enum OLEObjectTypeNameFormatConstants {
		/// \brief The full type name of the class
		[helpstring("The full type name of the class.")]
		ootnfFullName = 1/*USERCLASSTYPE_FULL*/,
		/// \brief A short name (maximum of 15 characters) that is used for popup menus and the Links dialog box
		[helpstring("A short name (maximum of 15 characters) that is used for popup menus and the Links dialog box.")]
		ootnfShortName = 2/*USERCLASSTYPE_SHORT*/,
		/// \brief The name of the application servicing the class and is used in the result text in dialog boxes.
		[helpstring("The name of the application servicing the class and is used in the result text in dialog boxes.")]
		ootnfAppName = 3/*USERCLASSTYPE_APPNAME*/
	} OLEObjectTypeNameFormatConstants;

	/// \brief <em>Constants used with the \c QueryAcceptData event</em>
	///
	/// \sa _IRichTextBoxEvents::QueryAcceptData
	[helpstring("Constants used with the 'QueryAcceptData' event.")]
	typedef enum QueryAcceptDataConstants {
		/// \brief Let the native control check the provided data
		///
		/// The provided data will be checked by the native control. It will decide whether to accept or refuse
		/// the data.
		[helpstring("The provided data will be checked by the native control. It will decide whether to accept or refuse the data.")]
		qadLetNativeControlDecide,
		/// \brief Accept the provided data
		///
		/// The provided data will be accepted and the operation will complete. If the event has been raised
		/// for actually performing the specified operation, the client application needs to perform the
		/// operation before returning from the event.
		[helpstring("The provided data will be accepted and the operation will complete. If the event has been raised for actually performing the specified operation, the client application needs to perform the operation before returning from the event.")]
		qadAcceptData,
		/// \brief Refuse the provided data
		///
		/// The provided data will be refused and the operation will be aborted.
		[helpstring("The provided data will be refused and the operation will be aborted.")]
		qadRefuseData
	} QueryAcceptDataConstants;

	/// \brief <em>Flags used with the \c IRichTextRange::GetStartPosition and \c IRichTextRange::GetEndPosition methods</em>
	///
	/// \sa IRichTextRange::GetStartPosition, IRichTextRange::GetEndPosition
	[helpstring("Flags used with the 'TextRange.GetStartPosition' and 'TextRange.GetEndPosition' methods. They can be combined.")]
	typedef enum RangePositionConstants {
		/// \brief Retrieve the position in screen coordinates, relative to the screen's upper-left corner
		[helpstring("Retrieve the position in screen coordinates, relative to the screen's upper-left corner.")]
		rpDefault = 0,
		/// \brief Retrieve the position in client coordinates, relative to the control's upper-left corner
		[helpstring("Retrieve the position in client coordinates, relative to the control's upper-left corner.")]
		rpClientCoordinates = 256/*tomClientCoord*/,
		/// \brief Don't fail if the retrieved position is outside the control's bounding rectangle
		[helpstring("Don't fail if the retrieved position is outside the control's bounding rectangle.")]
		rpAllowOffClientCoordinates = 512/*tomAllowOffClient*/,
		/// \brief Transform the coordinates using a world transform (XFORM) supplied by the client application (To be documented)
		[helpstring("Transform the coordinates using a world transform (XFORM) supplied by the client application (To be documented).")]
		rpTransformCoordinates = 1024/*tomTransform*/,
		/// \brief Retrieve a point inside an inline object argument; for example, inside the numerator of a fraction
		[helpstring("Retrieve a point inside an inline object argument; for example, inside the numerator of a fraction.")]
		rpInlineObjectArgument = 2048/*tomObjectArg*/
		// According to the value, this might be a valid flag as well. Maybe the unit must be encoded in the lower byte?
		// \brief The end of the specified unit
		//[helpstring("The end of the specified unit.")]
		//rpUnknown = 4096/*tomAtEnd*/
	} RangePositionConstants;

	/// \brief <em>Constants used with the \c RegisterForOLEDragDrop properties</em>
	///
	/// \sa IRichTextBox::RegisterForOLEDragDrop
	[helpstring("Constants used with the 'RegisterForOLEDragDrop' properties.")]
	typedef enum RegisterForOLEDragDropConstants {
		/// \brief OLE drag'n'drop support is deactivated
		[helpstring("OLE drag'n'drop support is deactivated.")]
		rfoddNoDragDrop,
		/// \brief The built-in OLE drag'n'drop support of \c RichEdit50W is used
		///
		/// The built-in OLE drag'n'drop support of \c RichEdit50W is used.
		[helpstring("The built-in OLE drag'n'drop support of 'RichEdit50W' is used.")]
		rfoddNativeDragDrop,
		/// \brief OLE drag'n'drop is done by the \c RichTextBox class
		///
		/// OLE drag'n'drop is done by the \c RichTextBox class, giving the client application full control
		/// over OLE drag'n'drop.
		[helpstring("OLE drag'n'drop is done by the 'RichTextBox' class, giving the client application full control over OLE drag'n'drop.")]
		rfoddAdvancedDragDrop
	} RegisterForOLEDragDropConstants;

	/// \brief <em>Constants used with the \c Reset methods</em>
	///
	/// \sa IRichTextFont::Reset, IRichTextParagraph::Reset
	[helpstring("Constants used with the 'Reset' methods.")]
	typedef enum ResetRulesConstants {
		/// \brief Set to undefined values
		///
		/// Sets all properties to undefined values. This value is valid only for a duplicate (clone) objects.
		[helpstring("Sets all properties to undefined values. This value is valid only for a duplicate (clone) objects.")]
		rrUndefined = -9999999/*tomUndefined*/,
		/// \brief Reset to defaults
		///
		/// Set to the document default format if the object is attached to a range; otherwise, set the
		/// defaults to the basic TOM engine defaults.
		[helpstring("Set to the document default format if the object is attached to a range; otherwise, set the defaults to the basic TOM engine defaults.")]
		rrDefault = -9999996/*tomDefault*/,
		/// \brief Apply the current properties to the attached range
		[helpstring("Apply the current properties to attached range.")]
		rrApplyNow = 0/*tomApplyNow*/,
		/// \brief Allow property values to be set, but don’t apply them to the attached range yet
		[helpstring("Allow property values to be set, but don’t apply them to the attached range yet.")]
		rrApplyLater = 1/*tomApplyLater*/,
		/// \brief Update the current object with the attached range properties
		[helpstring("Update the current object with the attached range properties.")]
		rrTrackParms = 2/*tomTrackParms*/,
		/// \brief Do not update the current object with the attached range properties
		[helpstring("Do not update the current object with the attached range properties.")]
		rrCacheParms = 3/*tomCacheParms*/,
		/// \brief Apply temporary formatting
		[helpstring("Apply temporary formatting.")]
		rrApplyTmp = 4/*tomApplyTmp*/,
		/// \brief Do not apply smart fonts
		[helpstring("Do not apply smart fonts.")]
		rrDisableSmartFont = 8/*tomDisableSmartFont*/,
		/// \brief Do apply smart fonts
		[helpstring("Do apply smart fonts.")]
		rrEnableSmartFont = 9/*tomEnableSmartFont*/,
		/// \brief Use points for floating-point measurements
		[helpstring("Use points for floating-point measurements.")]
		rrUsePoints = 10/*tomUsePoints*/,
		/// \brief Use twips for floating-point measurements
		[helpstring("Use twips for floating-point measurements.")]
		rrUseTwips = 11/*tomUseTwips*/
	} ResetRulesConstants;

	/// \brief <em>Constants used with the \c RichEditAPIVersion property</em>
	///
	/// \sa IRichTextBox::RichEditAPIVersion
	[helpstring("Constants used with the 'RichEditAPIVersion' property.")]
	typedef enum RichEditAPIVersionConstants {
		/// \brief The loaded rich edit control supports an unknown version of the rich edit API set
		[helpstring("The loaded rich edit control supports an unknown version of the rich edit API set.")]
		reavUnknown = 0,
		/// \brief The loaded rich edit control supports version 4.1 of the rich edit API set
		///
		/// \remarks Version 4.1 is provided by the native rich edit control of Windows XP, 2003, 2003 R2,
		///          Vista, 2008, 7, 2008 R2.
		[helpstring("The loaded rich edit control supports version 4.1 of the rich edit API set. Version 4.1 is provided by the native rich edit control of Windows XP, 2003, 2003 R2, Vista, 2008, 7, 2008 R2.")]
		reav41 = 41,
		/// \brief The loaded rich edit control supports version 5.0 of the rich edit API set
		///
		/// \remarks Version 5.0 is provided by the rich edit control of Office 2003.
		[helpstring("The loaded rich edit control supports version 5.0 of the rich edit API set. Version 5.0 is provided by the rich edit control of Office 2003.")]
		reav50 = 50,
		/// \brief The loaded rich edit control supports version 6.0 of the rich edit API set
		///
		/// \remarks Version 6.0 is provided by the rich edit control of Office 2007.
		[helpstring("The loaded rich edit control supports version 6.0 of the rich edit API set. Version 6.0 is provided by the rich edit control of Office 2007.")]
		reav60 = 60,
		/// \brief The loaded rich edit control supports version 7.0 of the rich edit API set
		///
		/// \remarks Version 7.0 is provided by the rich edit control of Office 2010.
		[helpstring("The loaded rich edit control supports version 7.0 of the rich edit API set. Version 7.0 is provided by the rich edit control of Office 2010.")]
		reav70 = 70,
		/// \brief The loaded rich edit control supports version 7.5 of the rich edit API set
		///
		/// \remarks Version 7.5 is provided by the native rich edit control of Windows 8, 2012, 8.1, 2012 R2,
		///          10.
		[helpstring("The loaded rich edit control supports version 7.5 of the rich edit API set. Version 7.5 is provided by the native rich edit control of Windows 8, 2012, 8.1, 2012 R2, 10.")]
		reav75 = 75,
		/// \brief The loaded rich edit control supports version 8.0 of the rich edit API set
		///
		/// \remarks Version 8.0 is provided by the rich edit control of Office 2013, 2016.
		[helpstring("The loaded rich edit control supports version 8.0 of the rich edit API set. Version 8.0 is provided by the rich edit control of Office 2013, 2016.")]
		reav80 = 80
	} RichEditAPIVersionConstants;

	/// \brief <em>Constants used with the \c RichEditVersion property</em>
	///
	/// \sa IRichTextBox::RichEditVersion
	[helpstring("Constants used with the 'RichEditVersion' property.")]
	typedef enum RichEditVersionConstants {
		/// \brief Always use the rich edit control of Windows
		///
		/// Use the native rich edit control of Microsoft Windows even if there is an installation of
		/// Microsoft Office which would provide a higher API version of the rich edit control.
		[helpstring("Use the native rich edit control of Microsoft Windows even if there is an installation of Microsoft Office which would provide a higher API version of the rich edit control.")]
		revAlwaysUseWindowsRichEdit,
		/// \brief Use the rich edit control of Office if available
		///
		/// Use the rich edit control of Microsoft Office if there is an installation of Microsoft
		/// Office, even if the native control of Windows provides a higher API version. If no Office
		/// is installed, the native control of Windows is used.
		[helpstring("Use the rich edit control of Microsoft Office if there is an installation of Microsoft Office, even if the native control of Windows provides a higher API version. If no Office is installed, the native control of Windows is used.")]
		revPreferOfficeRichEdit,
		/// \brief Use the rich edit control of Office if it provides a higher API version than the native control
		///
		/// Use the rich edit control of Microsoft Office if there is an installation of Microsoft
		/// Office, but only if it provides a higher API version than the native control of Windows. If no
		/// Office is installed, the native control of Windows is used.
		[helpstring("Use the rich edit control of Microsoft Office if there is an installation of Microsoft Office, but only if it provides a higher API version than the native control of Windows. If no Office is installed, the native control of Windows is used.")]
		revUseHighestVersion
	} RichEditVersionConstants;

	/// \brief <em>Flags used with the \c RightToLeft property</em>
	///
	/// \sa IRichTextBox::RightToLeft
	[helpstring("Flags used with the 'RightToLeft' property. They can be combined.")]
	typedef enum RightToLeftConstants {
		/// \brief Read text from right to left
		///
		/// The control's text is read from right to left, but the general layout is left to right.
		[helpstring("The control's text is read from right to left, but the general layout is left to right.")]
		rtlText = 1,
		/// \brief Use a right to left layout
		///
		/// The general layout is right to left.
		[helpstring("The general layout is right to left.")]
		rtlLayout = 2
	} RightToLeftConstants;

	/// \brief <em>Constants used to identify table rows within an \c IRichTableRows collection</em>
	///
	/// \sa IRichTableRows
	[helpstring("Constants used to identify table rows within a 'TableRows' collection.")]
	typedef enum RowIdentifierTypeConstants {
		/// \brief The table row is identified by a zero-based index
		///
		/// Removing or adding table rows may change a row's index.
		///
		/// \sa IRichTableRow::Index
		[helpstring("The table row is identified by a zero-based index.")]
		ritIndex,
		/// \brief The table row is identified by a character index which lies within the table row's text range
		///
		/// \sa IRichTableRow::TextRange
		[helpstring("The table row is identified by a character index which lies within the table row's text range.")]
		ritCharacterIndex
	} RowIdentifierTypeConstants;

	/// \brief <em>Flags used with the \c Scroll method and the \c Scrolling and \c MouseWheel events</em>
	///
	/// \sa IRichTextBox::Scroll, _IRichTextBoxEvents::Scrolling, _IRichTextBoxEvents::MouseWheel
	[helpstring("Flags used with the 'Scroll' method and the 'Scrolling' and 'MouseWheel' events. For 'Scroll', they can be combined.")]
	typedef enum ScrollAxisConstants {
		/// \brief Scroll vertically
		[helpstring("The control will scroll vertically.")]
		saVertical = 1,
		/// \brief Scroll horizontally
		[helpstring("The control will scroll horizontally.")]
		saHorizontal = 2
	} ScrollAxisConstants;

	/// \brief <em>Flags used with the \c ScrollBars property</em>
	///
	/// \sa IRichTextBox::ScrollBars
	[helpstring("Flags used with the 'ScrollBars' property. They can be combined.")]
	typedef enum ScrollBarsConstants {
		/// \brief Don't display any scrollbars
		[helpstring("The control doesn't display any scrollbars.")]
		sbNone = 0,
		/// \brief Display a vertical scrollbar
		[helpstring("The control displays a vertical scrollbar.")]
		sbVertical = 1,
		/// \brief Display a horizontal scrollbar
		[helpstring("The control displays a horizontal scrollbar.")]
		sbHorizontal = 2
	} ScrollBarsConstants;

	/// \brief <em>Constants used with the \c Scroll method</em>
	///
	/// \sa IRichTextBox::Scroll
	[helpstring("Constants used with the 'Scroll' method.")]
	typedef enum ScrollDirectionConstants {
		/// \brief Scrolls up by one line or left by one unit
		[helpstring("The control will scroll up by one line or left by one unit.")]
		sdLineUpOrLeft = 0/*SB_LINEUP, SB_LINELEFT*/,
		/// \brief Scrolls down by one line or right by one unit
		[helpstring("The control will scroll down by one line or right by one unit.")]
		sdLineDownOrRight = 1/*SB_LINEDOWN, SB_LINERIGHT*/,
		/// \brief Scrolls up by one page or left by one window width
		[helpstring("The control will scroll up by one page or left by one window width.")]
		sdPageUpOrLeft = 2/*SB_PAGEUP, SB_PAGELEFT*/,
		/// \brief Scrolls down by one page or right by one window width
		[helpstring("The control will scroll down by one page or right by one window width.")]
		sdPageDownOrRight = 3/*SB_PAGEDOWN, SB_PAGERIGHT*/,
		/// \brief Scrolls to the control's upper left
		[helpstring("The control will scroll to the control's upper left.")]
		sdTopOrLeft = 6/*SB_TOP, SB_LEFT*/,
		/// \brief Scrolls to the control's lower right
		[helpstring("The control will scroll to the control's lower right.")]
		sdBottomOrRight = 7/*SB_BOTTOM, SB_RIGHT*/,
		/// \brief Scrolls by the values specified by the \c linesToScrollVertically and \c charactersToScrollHorizontally parameters
		[helpstring("Scrolls by the values specified by the 'linesToScrollVertically' and 'charactersToScrollHorizontally' parameters.")]
		sdCustom = 99
	} ScrollDirectionConstants;

	/// \brief <em>Flags used with the \c IRichTextRange::ScrollIntoView method</em>
	///
	/// \sa IRichTextRange::ScrollIntoView
	[helpstring("Flags used with the 'TextRange.ScrollIntoView' method. They can be combined.")]
	typedef enum ScrollIntoViewConstants {
		/// \brief Scrolls the text range's end position to appear on the bottom line
		[helpstring("Scrolls the text range's end position to appear on the bottom line.")]
		sivScrollRangeEndToBottom = 0/*tomEnd*/,
		/// \brief Scrolls the text range's start position to appear on the top line
		[helpstring("Scrolls the text range's start position to appear on the top line.")]
		sivScrollRangeStartToTop = 32/*tomStart*/,
		/// \brief The control won't scroll horizontally
		[helpstring("The control won't scroll horizontally.")]
		sivNoHorizontalScrolling = 0x10000/*tomNoUpScroll*/,
		/// \brief The control won't scroll vertically
		[helpstring("The control won't scroll vertically.")]
		sivNoVerticalScrolling = 0x40000/*tomNoVpScroll*/
	} ScrollIntoViewConstants;

	/// \brief <em>Constants used with the \c IRichTextRange::FindText method</em>
	///
	/// \sa IRichTextRange::FindText
	[helpstring("Constants used with the 'TextRange.FindText' method.")]
	typedef enum SearchDirectionConstants {
		/// \brief Search forward, toward the end of the story
		[helpstring("Search forward, toward the end of the story.")]
		sdForward = 0x3fffffff/*tomForward*/,
		/// \brief Search backward, toward the start of the story
		[helpstring("Search backward, toward the start of the story.")]
		sdBackward = 0xc0000001/*tomBackward*/,
		/// \brief Search within the range only
		[helpstring("Search within the range only.")]
		sdWithinRange = 0
	} SearchDirectionConstants;

	/// \brief <em>Flags used with the \c IRichTextRange::FindText method</em>
	///
	/// \sa IRichTextRange::FindText
	[helpstring("Flags used with the 'TextRange.FindText' method. They can be combined.")]
	typedef enum SearchModeConstants {
		/// \brief The search is case-insensitive and also parts of words match
		[helpstring("The search is case-insensitive and also parts of words match.")]
		smDefault = 0,
		/// \brief Match whole words only
		[helpstring("Match whole words only.")]
		smMatchWord = 2/*tomMatchWord*/,
		/// \brief Perform a case-sensitive search
		[helpstring("Perform a case-sensitive search.")]
		smMatchCase = 4/*tomMatchCase*/,
		/// \brief Treat the search string as regular expression
		[helpstring("Treat the search string as regular expression.")]
		smMatchPattern = 8/*tomMatchPattern*/
	} SearchModeConstants;

	/// \brief <em>Flags used with the \c SelectionType property and the \c ContextMenu event</em>
	///
	/// \sa IRichTextBox::SelectionType, _IRichTextBoxEvents::ContextMenu
	[helpstring("Flags used with the 'SelectionType' property and the 'ContextMenu' event. They can be combined.")]
	typedef enum SelectionTypeConstants {
		/// \brief The selection is empty
		[helpstring("The selection is empty.")]
		setEmpty = 0x0000/*SEL_EMPTY*/,
		/// \brief The selection contains text
		[helpstring("The selection contains text.")]
		setText = 0x0001/*SEL_TEXT*/,
		/// \brief The selection contains at least one object
		[helpstring("The selection contains at least one object.")]
		setObject = 0x0002/*SEL_OBJECT*/,
		/// \brief The selection contains more than one character
		[helpstring("The selection contains more than one character.")]
		setMultiChar = 0x0004/*SEL_MULTICHAR*/,
		/// \brief The selection contains more than one object
		[helpstring("The selection contains more than one object.")]
		setMultiObject = 0x0008/*SEL_MULTIOBJECT*/
	} SelectionTypeConstants;

	/// \brief <em>Constants used with the \c IRichTextRange::StoryType property</em>
	///
	/// \sa IRichTextRange::StoryType
	[helpstring("Constants used with the 'TextRange.StoryType' property.")]
	typedef enum StoryTypeConstants {
		/// \brief The story has no specific type
		[helpstring("The story has no specific type.")]
		sttUnknownStory = 0/*tomUnknownStory*/,
		/// \brief The story is the main text story of the document
		[helpstring("The story is the main text story of the document.")]
		sttMainTextStory = 1/*tomMainTextStory*/,
		/// \brief The story is used for footnotes
		[helpstring("The story is used for footnotes.")]
		sttFootnotesStory = 2/*tomFootnotesStory*/,
		/// \brief The story is used for endnotes
		[helpstring("The story is used for endnotes.")]
		sttEndnotesStory = 3/*tomEndnotesStory*/,
		/// \brief The story is used for comments
		[helpstring("The story is used for comments.")]
		sttCommentsStory = 4/*tomCommentsStory*/,
		/// \brief The story is used for an embedded text box
		[helpstring("The story is used for an embedded text box.")]
		sttTextFrameStory = 5/*tomTextFrameStory*/,
		/// \brief The story is used for the header of even pages
		[helpstring("The story is used for the header of even pages.")]
		sttEvenPagesHeaderStory = 6/*tomEvenPagesHeaderStory*/,
		/// \brief The story is used for the header of odd pages
		[helpstring("The story is used for the header of odd pages.")]
		sttPrimaryHeaderStory = 7/*tomPrimaryHeaderStory*/,
		/// \brief The story is used for the footer of even pages
		[helpstring("The story is used for the footer of even pages.")]
		sttEvenPagesFooterStory = 8/*tomEvenPagesFooterStory*/,
		/// \brief The story is used for the footer of odd pages
		[helpstring("The story is used for the footer of odd pages.")]
		sttPrimaryFooterStory = 9/*tomPrimaryFooterStory*/,
		/// \brief The story is used for the header of the first page
		[helpstring("The story is used for the header of the first page.")]
		sttFirstPageHeaderStory = 10/*tomFirstPageHeaderStory*/,
		/// \brief The story is used for the footer of the first page
		[helpstring("The story is used for the footer of the first page.")]
		sttFirstPageFooterStory = 11/*tomFirstPageFooterStory*/,
		/// \brief The story is the document's scratch story
		[helpstring("The story is the document's scratch story.")]
		sttScratchStory = 127/*tomScratchStory*/,
		/// \brief The story is used for a Find dialog
		[helpstring("The story is used for a Find dialog.")]
		sttFindDialogStory = 128/*tomFindStory*/,
		/// \brief The story is used for a Replace dialog
		[helpstring("The story is used for a Replace dialog.")]
		sttReplaceDialogStory = 129/*tomReplaceStory*/
	} StoryTypeConstants;

	/// \brief <em>Constants used to identify sub-ranges within an \c IRichTextSubRanges collection</em>
	///
	/// \sa IRichTextSubRanges
	[helpstring("Constants used to identify sub-ranges within a 'TextSubRanges' collection.")]
	typedef enum SubRangeIdentifierTypeConstants {
		/// \brief The sub-range is identified by an index
		///
		/// The index is interpreted in different ways, depending on its sign:
		/// - 0 always identifies the currently active sub-range.
		/// - A negative index identifies the sub-range by its character position order. For instance if there
		///   are 3 sub-ranges from character positions 2 to 4, 7 to 10, and 20 to 40, then an index of -1
		///   identifies the sub-range 2-4, even if this one has been added after e.g. the sub-range 7-10.
		/// - A positive index identifies the sub-range by the order it has been added. For instance if there
		///   are 3 sub-ranges from character positions 7 to 10, 2 to 4, and 20 to 40 (all added in this
		///   order), then an index of +1 identifies the sub-range 7-10, because it has been added first.
		///
		/// Removing or adding sub-ranges may change a sub-range's index.
		[helpstring("The sub-range is identified by an index.")]
		sritIndex
	} SubRangeIdentifierTypeConstants;

	/// \brief <em>Constants used with the \c Alignment properties</em>
	///
	/// \sa IRichTextParagraphTab::Alignment
	[helpstring("Constants used with the 'TextParagraphTab.Alignment' property.")]
	typedef enum TabAlignmentConstants {
		/// \brief The tab's alignment is 'undefined'
		[helpstring("The tab's alignment is 'undefined'.")]
		taUndefined = -9999999/*tomUndefined*/,
		/// \brief Text is left justified from the tab position
		[helpstring("Text is left justified from the tab position.")]
		taLeft = 0/*tomAlignLeft*/,
		/// \brief Text is centered on the tab position
		[helpstring("Text is centered on the tab position.")]
		taCenter = 1/*tomAlignCenter*/,
		/// \brief Text is right justified from the tab position
		[helpstring("Text is right justified from the tab position.")]
		taRight = 2/*tomAlignRight*/,
		/// \brief The decimal point is set at the tab position
		[helpstring("The decimal point is set at the tab position. This is useful for aligning a column of decimal numbers.")]
		taDecimal = 3/*tomAlignDecimal*/,
		/// \brief A vertical bar is positioned at the tab position
		///
		/// \remarks Alignment bars on nearby lines at the same position form a continuous vertical line.
		[helpstring("A vertical bar is positioned at the tab position. Text is not affected. Alignment bars on nearby lines at the same position form a continuous vertical line.")]
		taDisplayVerticalBar = 4/*tomAlignBar*/
	} TabAlignmentConstants;

	/// \brief <em>Constants used to identify tabs within an \c IRichTextParagraphTabs collection</em>
	///
	/// \sa IRichTextParagraphTabs
	[helpstring("Constants used to identify tabs within a 'TextParagraphTabs' collection.")]
	typedef enum TabIdentifierTypeConstants {
		/// \brief The tab is identified by a zero-based index
		///
		/// Changing a tab's position, or removing or adding new tabs may change a tab's index.
		///
		/// \sa IRichTextParagraphTab::Index
		[helpstring("The tab is identified by a zero-based index.")]
		titIndex = 1,
		/// \brief The tab is identified by its position
		///
		/// \sa IRichTextParagraphTab::Position
		[helpstring("The tab is identified by its position.")]
		titPosition
	} TabIdentifierTypeConstants;

	/// \brief <em>Constants used with the \c LeaderCharacter property</em>
	///
	/// \sa IRichTextParagraphTab::LeaderCharacter
	[helpstring("Constants used with the 'TextParagraphTab.LeaderCharacter' property.")]
	typedef enum TabLeaderCharacterConstants {
		/// \brief The tab's leader character is 'undefined'
		[helpstring("The tab's leader character is 'undefined'.")]
		tlcUndefined = -9999999/*tomUndefined*/,
		/// \brief The tab's space is filled with spaces
		[helpstring("The tab's space is filled with spaces.")]
		tlcSpaces = 0/*tomSpaces*/,
		/// \brief The tab's space is filled with dots
		[helpstring("The tab's space is filled with dots.")]
		tlcDots = 1/*tomDots*/,
		/// \brief The tab's space is filled with a dashed line
		[helpstring("The tab's space is filled with a dashed line.")]
		tlcDashes = 2/*tomDashes*/,
		/// \brief The tab's space is filled with a solid line
		[helpstring("The tab's space is filled with a solid line.")]
		tlcLines = 3/*tomLines*/,
		/// \brief The tab's space is filled with a thick solid line
		[helpstring("The tab's space is filled with a thick solid line.")]
		tlcThickLines = 4/*tomThickLines*/,
		/// \brief The tab's space is filled with equality signs (=)
		[helpstring("The tab's space is filled with equality signs (=).")]
		tlcEquals = 5/*tomEquals*/
	} TabLeaderCharacterConstants;

	/// \brief <em>Constants used with the \c IRichTextFont::TeXStyle property</em>
	///
	/// \sa IRichTextFont::TeXStyle
	[helpstring("Constants used with the 'TextFont.TeXStyle' property.")]
	typedef enum TeXFontStyleConstants {
		/// \brief The math handler determines the style
		[helpstring("The math handler determines the style.")]
		texfsDefault = 0/*tomStyleDefault*/,
		/// \brief The 2nd and higher level subscript superscript size, cramped
		[helpstring("The 2nd and higher level subscript superscript size, cramped.")]
		texfsScriptScriptCramped = 1/*tomStyleScriptScriptCramped*/,
		/// \brief The 2nd and higher level subscript superscript size
		[helpstring("The 2nd and higher level subscript superscript size.")]
		texfsScriptScript = 2/*tomStyleScriptScript*/,
		/// \brief The 1st level subscript superscript size, cramped
		[helpstring("The 1st level subscript superscript size, cramped.")]
		texfsScriptCramped = 3/*tomStyleScriptCramped*/,
		/// \brief The 1st level subscript superscript size
		[helpstring("The 1st level subscript superscript size.")]
		texfsScript = 4/*tomStyleScript*/,
		/// \brief Text size cramped, for example, inside a square root
		[helpstring("Text size cramped, for example, inside a square root.")]
		texfsTextCramped = 5/*tomStyleTextCramped*/,
		/// \brief The standard inline text size
		[helpstring("The standard inline text size.")]
		texfsText = 6/*tomStyleText*/,
		/// \brief Display style cramped
		[helpstring("Display style cramped.")]
		texfsDisplayCramped = 7/*tomStyleDisplayCramped*/,
		/// \brief Display style
		[helpstring("Display style.")]
		texfsDisplay = 8/*tomStyleDisplay*/,
		/// \brief The size that other values relate to
		///
		/// Indicates one of these is active: \c texfsDecDecSize, \c texfsDecSize, \c texfsIncSize,
		/// \c texfsIncIncSize. Note that the maximum size is \c texfsText size, and the minimum size is
		/// \c texfsScriptScript size.
		[helpstring("Indicates one of these is active: texfsDecDecSize, texfsDecSize, texfsIncSize, texfsIncIncSize. Note that the maximum size is texfsText size, and the minimum size is texfsScriptScript size.")]
		texfsMathRelSize = 0x40/*tomMathRelSize*/,
		/// \brief Two sizes smaller than the default
		[helpstring("Two sizes smaller than the default.")]
		texfsDecDecSize = 0xFE/*tomDecDecSize*/,
		/// \brief One size smaller than the default
		[helpstring("One size smaller than the default.")]
		texfsDecSize = 0xFF/*tomDecSize*/,
		/// \brief One size bigger than the default
		[helpstring("One size bigger than the default.")]
		texfsIncSize = (texfsMathRelSize | 1)/*tomIncSize*/,
		/// \brief Two sizes bigger than the default
		[helpstring("Two sizes bigger than the default.")]
		texfsIncIncSize = (texfsMathRelSize | 2)/*tomIncIncSize*/
	} TeXFontStyleConstants;

	/// \brief <em>Constants used with the \c TextFlow property</em>
	///
	/// \sa IRichTextBox::TextFlow, IRichTableCell::TextFlow
	[helpstring("Constants used with the 'TextFlow' property.")]
	typedef enum TextFlowConstants {
		/// \brief Text flows from from left to right and top to bottom
		[helpstring("Text flows from from left to right and top to bottom.")]
		tfLeftToRightTopToBottom = 0/*EPR_0*/,
		/// \brief Text flows from top to bottom and from right to left
		[helpstring("Text flows from top to bottom and from right to left.")]
		tfTopToBottomRightToLeft = 1/*EPR_270*/,
		/// \brief Text flows from right to left and from bottom to top
		[helpstring("Text flows from right to left and from bottom to top.")]
		tfRightToLeftBottomToTop = 2/*EPR_180*/,
		/// \brief Text flows from bottom to top and from left to right
		[helpstring("Text flows from bottom to top and from left to right.")]
		tfBottomToTopLeftToRight = 3/*EPR_90*/,
		/// \brief Text flows from top to bottom and from left to right (Mongolian text layout)
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IRichTextBox::RichEditVersion
		[helpstring("Text flows from top to bottom and from left to right (Mongolian text layout). Requires Rich Edit 8.0 or newer.")]
		tfTopToBottomLeftToRight = 5/*EPR_SE*/
	} TextFlowConstants;

	/// \brief <em>Constants used with the \c TextOrientation property</em>
	///
	/// \sa IRichTextBox::TextOrientation
	[helpstring("Constants used with the 'TextOrientation' property.")]
	typedef enum TextOrientationConstants {
		/// \brief The control's content is orientated horizontally
		[helpstring("The control's content is orientated horizontally.")]
		toHorizontal,
		/// \brief The control's content is orientated vertically and vertical fonts (starting with "@") are used
		///
		/// The control's content is orientated vertically. The control uses fonts starting with an "@", so
		/// that the symbols (characters) keep their natural orientation and are not rotated.\n
		/// This orientation can be used for languages that are written in vertical columns rather than
		/// horizontal lines, e.g. traditional Chinese and traditional Japanese.
		[helpstring("The control's content is orientated vertically and vertical fonts (starting with ""@"") are used.")]
		toVertical,
		/// \brief The control's content is orientated vertically and horizontal fonts are used
		///
		/// This orientation is like \c oVertical, but the symbols (characters) lose their natural orientation
		/// because they are rotated.
		[helpstring("The control's content is orientated vertically and horizontal fonts are used.")]
		toVerticalWithHorizontalFont
	} TextOrientationConstants;

	/// \brief <em>Constants used with the \c TSFModeBias property</em>
	///
	/// \sa IRichTextBox::TSFModeBias
	[helpstring("Constants used with the 'CTFConversionMode' property.")]
	typedef enum TSFModeBiasConstants {
		/// \brief The Text Services Framework mode bias is not specified
		[helpstring("The Text Services Framework mode bias is not specified.")]
		tsfmbDefault = 0x0000/*CTFMODEBIAS_DEFAULT*/,
		/// \brief The Text Services Framework mode bias is to a filename
		[helpstring("The Text Services Framework mode bias is to a filename.")]
		tsfmbBiasToFilename = 0x0001/*CTFMODEBIAS_FILENAME*/,
		/// \brief The Text Services Framework mode bias is to a name
		[helpstring("The Text Services Framework mode bias is to a name.")]
		tsfmbBiasToName = 0x0002/*CTFMODEBIAS_NAME*/,
		/// \brief The Text Services Framework mode bias is to the reading
		[helpstring("The Text Services Framework mode bias is to the reading.")]
		tsfmbBiasToReading = 0x0003/*CTFMODEBIAS_READING*/,
		/// \brief The Text Services Framework mode bias is to a date or time
		[helpstring("The Text Services Framework mode bias is to a date or time.")]
		tsfmbBiasToDateOrTime = 0x0004/*CTFMODEBIAS_DATETIME*/,
		/// \brief The Text Services Framework mode bias is to a conversation
		[helpstring("The Text Services Framework mode bias is to a conversation.")]
		tsfmbBiasToConversation = 0x0005/*CTFMODEBIAS_CONVERSATION*/,
		/// \brief The Text Services Framework mode bias is to a number
		[helpstring("The Text Services Framework mode bias is to a number.")]
		tsfmbBiasToNumber = 0x0006/*CTFMODEBIAS_NUMERIC*/,
		/// \brief The Text Services Framework mode bias is to hiragana strings
		[helpstring("The Text Services Framework mode bias is to hiragana strings.")]
		tsfmbBiasToHiraganaStrings = 0x0007/*CTFMODEBIAS_HIRAGANA*/,
		/// \brief The Text Services Framework mode bias is to katakana strings
		[helpstring("The Text Services Framework mode bias is to katakana strings.")]
		tsfmbBiasToKatakanaStrings = 0x0008/*CTFMODEBIAS_KATAKANA*/,
		/// \brief The Text Services Framework mode bias is to hangul characters
		[helpstring("The Text Services Framework mode bias is to hangul characters.")]
		tsfmbBiasToHangulCharacters = 0x0009/*CTFMODEBIAS_HANGUL*/,
		/// \brief The Text Services Framework mode bias is to half-width katakana strings
		[helpstring("The Text Services Framework mode bias is to half-width katakana strings.")]
		tsfmbBiasToHalfWidthKatakanaStrings = 0x000A/*CTFMODEBIAS_HALFWIDTHKATAKANA*/,
		/// \brief The Text Services Framework mode bias is to full-width alphanumeric characters
		[helpstring("The Text Services Framework mode bias is to full-width alphanumeric characters.")]
		tsfmbBiasToFullWidthAlphanumericCharacters = 0x000B/*CTFMODEBIAS_FULLWIDTHALPHANUMERIC*/,
		/// \brief The Text Services Framework mode bias is to half-width alphanumeric characters
		[helpstring("The Text Services Framework mode bias is to half-width alphanumeric characters.")]
		tsfmbBiasToHalfWidthAlphanumericCharacters = 0x000C/*CTFMODEBIAS_HALFWIDTHALPHANUMERIC*/,
	} TSFModeBiasConstants;

	/// \brief <em>Constants used with the \c IRichTextFont::UnderlinePosition property</em>
	///
	/// \sa IRichTextFont::UnderlinePosition
	[helpstring("Constants used with the 'TextFont.UnderlinePosition' property.")]
	typedef enum UnderlinePositionConstants {
		/// \brief The text range uses multiple underline positions
		[helpstring("The text range uses multiple underline positions.")]
		upUndefined = -9999999/*tomUndefined*/,
		/// \brief The position of the underlining is set automatically
		[helpstring("The position of the underlining is set automatically.")]
		upAuto = 0/*tomUnderlinePositionAuto*/,
		/// \brief Underlining is drawn below text
		[helpstring("Underlining is drawn below text.")]
		upBelowText = 1/*tomUnderlinePositionBelow*/,
		/// \brief Underlining is drawn above text
		[helpstring("Underlining is drawn above text.")]
		upAboveText = 2/*tomUnderlinePositionAbove*/
	} UnderlinePositionConstants;

	/// \brief <em>Constants used with the \c IRichTextFont::UnderlineType property</em>
	///
	/// \sa IRichTextFont::UnderlineType
	[helpstring("Constants used with the 'TextFont.UnderlineType' property.")]
	typedef enum UnderlineTypeConstants {
		/// \brief The text range uses multiple underline types
		[helpstring("The text range uses multiple underline types.")]
		utUndefined = -9999999/*tomUndefined*/,
		/// \brief The text range is not underlined
		[helpstring("The text range is not underlined.")]
		utNone = 0/*tomNone*/,
		/// \brief The text range is underlined with a single line
		[helpstring("The text range is underlined with a single line.")]
		utSingle = 1/*tomSingle*/,
		/// \brief The text range is underlined with a single line, but only words are underlined
		[helpstring("The text range is underlined with a single line, but only words are underlined.")]
		utWords = 2/*tomWords*/,
		/// \brief The text range is underlined with a double line
		[helpstring("The text range is underlined with a double line.")]
		utDouble = 3/*tomDouble*/,
		/// \brief The text range is underlined with a dotted line
		[helpstring("The text range is underlined with a dotted line.")]
		utDotted = 4/*tomDotted*/,
		/// \brief The text range is underlined with a dash line
		[helpstring("The text range is underlined with a dash line.")]
		utDash = 5/*tomDash*/,
		/// \brief The text range is underlined with a dash dot line
		[helpstring("The text range is underlined with a dash dot line.")]
		utDashDot = 6/*tomDashDot*/,
		/// \brief The text range is underlined with a dash dot dot line
		[helpstring("The text range is underlined with a dash dot dot line.")]
		utDashDotDot = 7/*tomDashDotDot*/,
		/// \brief The text range is underlined with a wave line
		[helpstring("The text range is underlined with a wave line.")]
		utWave = 8/*tomWave*/,
		/// \brief The text range is underlined with a thick line
		[helpstring("The text range is underlined with a thick line.")]
		utThick = 9/*tomThick*/,
		/// \brief The text range is underlined with a hair line
		[helpstring("The text range is underlined with a hair line.")]
		utHair = 10/*tomHair*/,
		/// \brief The text range is underlined with a double wave line
		[helpstring("The text range is underlined with a double wave line.")]
		utDoubleWave = 11/*tomDoubleWave*/,
		/// \brief The text range is underlined with a heavy wave line
		[helpstring("The text range is underlined with a heavy wave line.")]
		utHeavyWave = 12/*tomHeavyWave*/,
		/// \brief The text range is underlined with a long dash line
		[helpstring("The text range is underlined with a long dash line.")]
		utLongDash = 13/*tomLongDash*/,
		/// \brief The text range is underlined with a thick dash line
		[helpstring("The text range is underlined with a thick dash line.")]
		utThickDash = 14/*tomThickDash*/,
		/// \brief The text range is underlined with a thick dash dot line
		[helpstring("The text range is underlined with a thick dash dot line.")]
		utThickDashDot = 15/*tomThickDashDot*/,
		/// \brief The text range is underlined with a thick dash dot dot line
		[helpstring("The text range is underlined with a thick dash dot dot line.")]
		utThickDashDotDot = 16/*tomThickDashDotDot*/,
		/// \brief The text range is underlined with a thick dotted line
		[helpstring("The text range is underlined with a thick dotted line.")]
		utThickDotted = 17/*tomThickDotted*/,
		/// \brief The text range is underlined with a thick long dash line
		[helpstring("The text range is underlined with a thick long dash line.")]
		utThickLongDash = 18/*tomThickLongDash*/
	} UnderlineTypeConstants;

	/// \brief <em>Constants used with the \c NextRedoActionType and \c NextUndoActionType properties</em>
	///
	/// \sa IRichTextBox::NextRedoActionType, IRichTextBox::NextUndoActionType
	[helpstring("Constants used with the 'NextRedoActionType' and 'NextUndoActionType' properties.")]
	typedef enum UndoActionTypeConstants {
		/// \brief The type of the action is unknown
		[helpstring("The type of the action is unknown.")]
		uatUnknown = 0/*UID_UNKNOWN*/,
		/// \brief The next action is a typing operation
		[helpstring("The next action is a typing operation.")]
		uatTyping = 1/*UID_TYPING*/,
		/// \brief The next action is a delete operation
		[helpstring("The next action is a delete operation.")]
		uatDelete = 2/*UID_DELETE*/,
		/// \brief The next action is a drag'n'drop operation
		[helpstring("The next action is a drag'n'drop operation.")]
		uatDragDrop = 3/*UID_DRAGDROP*/,
		/// \brief The next action is a cut operation
		[helpstring("The next action is a cut operation.")]
		uatCut = 4/*UID_CUT*/,
		/// \brief The next action is a paste operation
		[helpstring("The next action is a paste operation.")]
		uatPaste = 5/*UID_PASTE*/,
		/// \brief The next action is an automatic table insertion
		///
		/// The next action is an automatic table insertion, for example typing
		/// +---+---+[ENTER] to insert a table row.
		[helpstring("The next action is an automatic table insertion, for example typing +---+---+[ENTER] to insert a table row.")]
		uatAutoTable = 6/*UID_AUTOTABLE*/
	} UndoActionTypeConstants;

	/// \brief <em>Constants used with the \c IRichTextRange::UnitIndex property</em>
	///
	/// \sa IRichTextRange::UnitIndex
	[helpstring("Constants used with the 'TextRange.UnitIndex' property.")]
	typedef enum UnitConstants {
		/// \brief Each character is a separate unit
		[helpstring("Each character is a separate unit.")]
		uCharacter = 1/*tomCharacter*/,
		/// \brief Each word is a separate unit
		[helpstring("Each word is a separate unit.")]
		uWord = 2/*tomWord*/,
		/// \brief Each sentence is a separate unit
		[helpstring("Each sentence is a separate unit.")]
		uSentence = 3/*tomSentence*/,
		/// \brief Each paragraph is a separate unit
		[helpstring("Each paragraph is a separate unit.")]
		uParagraph = 4/*tomParagraph*/,
		/// \brief Each line is a separate unit
		[helpstring("Each line is a separate unit.")]
		uLine = 5/*tomLine*/,
		/// \brief Each story is a separate unit
		[helpstring("Each story is a separate unit.")]
		uStory = 6/*tomStory*/,
		/// \brief Each screen (as for [PAGE UP]/[PAGE DOWN]) is a separate unit
		[helpstring("Each screen (as for [PAGE UP]/[PAGE DOWN]) is a separate unit.")]
		uScreen = 7/*tomScreen*/,
		/// \brief Each section is a separate unit
		[helpstring("Each section is a separate unit.")]
		uSection = 8/*tomSection*/,
		/// \brief Each table column is a separate unit
		[helpstring("Each table column is a separate unit.")]
		uTableColumn = 9/*tomTableColumn, tomColumn*/,
		/// \brief Each table row is a separate unit
		[helpstring("Each table row is a separate unit.")]
		uTableRow = 10/*tomRow*/,
		/// \brief The upper-left and the lower-right of the control's window are separate units
		[helpstring("The upper-left and the lower-right of the control's window are separate units.")]
		uWindow = 11/*tomWindow*/,
		/// \brief Each table cell is a separate unit
		[helpstring("Each table cell is a separate unit.")]
		uTableCell = 12/*tomCell*/,
		/// \brief A run of constant character formatting forms a unit
		[helpstring("A run of constant character formatting forms a unit.")]
		uCharacterFormat = 13/*tomCharFormat*/,
		/// \brief A run of constant paragraph formatting forms a unit
		[helpstring("A run of constant paragraph formatting forms a unit.")]
		uParagraphFormat = 14/*tomParaFormat*/,
		/// \brief Each table is a separate unit
		[helpstring("Each table is a separate unit.")]
		uTable = 15/*tomTable*/,
		/// \brief Each embedded OLE object is a separate unit
		[helpstring("Each embedded OLE object is a separate unit.")]
		uEmbeddedOLEObject = 16/*tomObject*/,
		/// \brief Each page is a separate unit
		[helpstring("Each page is a separate unit.")]
		uPage = 17/*tomPage*/,
		/// \brief Each hard paragraph is a separate unit
		[helpstring("Each hard paragraph is a separate unit.")]
		uHardParagraph = 18/*tomHardParagraph*/,
		/// \brief Each cluster of characters is a separate unit
		[helpstring("Each cluster of characters is a separate unit.")]
		uCluster = 19/*tomCluster*/,
		/// \brief Each inline object (e.g. a part of a math zone) is a separate unit
		[helpstring("Each inline object (e.g. a part of a math zone) is a separate unit.")]
		uInlineObject = 20/*tomInlineObject*/,
		/// \brief Each inline object argument (e.g. the numerator and denominator of a fraction in a math zone) is a separate unit
		[helpstring("Each inline object argument (e.g. the numerator and denominator of a fraction in a math zone) is a separate unit.")]
		uInlineObjectArgument = 21/*tomInlineObjectArg*/,
		/// \brief Each leaf-level line is a separate unit
		[helpstring("Each leaf-level line is a separate unit.")]
		uLeafLine = 22/*tomLeafLine*/,
		/// \brief Each layout column is a separate unit
		[helpstring("Each layout column is a separate unit.")]
		uLayoutColumn = 23/*tomLayoutColumn*/
	} UnitConstants;

	/// \brief <em>Constants used with the \c IRichTableCell::VAlignment property</em>
	///
	/// \sa IRichTableCell::VAlignment, HAlignmentConstants
	[helpstring("Constants used with the 'TableCell.VAlignment' property.")]
	typedef enum VAlignmentConstants {
		/// \brief The table cell's content is top-aligned
		[helpstring("The table cell's content is top-aligned.")]
		valTop,
		/// \brief The table cell's content is vertically centered
		[helpstring("The table cell's content is vertically centered.")]
		valCenter,
		/// \brief The table cell's content is bottom-aligned
		[helpstring("The table cell's content is bottom-aligned.")]
		valBottom
	} VAlignmentConstants;

	/// \brief <em>Constants used with the \c IRichTextRange::GetStartPosition and \c IRichTextRange::GetEndPosition methods</em>
	///
	/// \sa IRichTextRange::GetStartPosition, IRichTextRange::GetEndPosition, HorizontalPositionConstants
	[helpstring("Constants used with the 'TextRange.GetStartPosition' and 'TextRange.GetEndPosition' methods.")]
	typedef enum VerticalPositionConstants {
		/// \brief Retrieve the top edge of the bounding rectangle
		[helpstring("Retrieve the top edge of the bounding rectangle.")]
		vpTop = 0/*TA_TOP*/,
		/// \brief Retrieve the bottom edge of the bounding rectangle
		[helpstring("Retrieve the bottom edge of the bounding rectangle.")]
		vpBottom = 8/*TA_BOTTOM*/,
		/// \brief Retrieve the base line of the text
		[helpstring("Retrieve the base line of the text.")]
		vpBaseline = 24/*TA_BASELINE*/
	} VerticalPositionConstants;


	/// \brief <em>Holds the details of an OLE object verb</em>
	///
	/// \sa IRichOLEObject::GetVerbs
	[helpstring("Holds the details of an OLE object verb."), uuid(ACF9C8A9-76EB-4484-84B6-704C4723BC25)]
	typedef struct OLEVERBDETAILS
	{
		/// \brief <em>The verb's identifier</em>
		[helpstring("The verb's identifier.")]
		LONG ID;
		/// \brief <em>The verb's name</em>
		[helpstring("The verb's name.")]
		BSTR Name;
		/// \brief <em>The verb's menu flags that should be used when displaying the item within a menu</em>
		///
		/// \sa <a href="https://msdn.microsoft.com/en-us/library/ms647616.aspx">Menu Flags</a>
		[helpstring("The verb's menu flags that should be used when displaying the item within a menu.")]
		LONG MenuFlags;
		/// \brief <em>The verb's attributes</em>
		///
		/// \sa <a href="https://msdn.microsoft.com/en-us/library/ms686659.aspx">Verb Attributes</a>
		[helpstring("The verb's attributes.")]
		LONG Attributes;
	} OLEVERBDETAILS;

	/// \brief <em>Holds the coordinates of a rectangle's opposing corners</em>
	///
	/// \sa _IRichTextBoxEvents::ShouldResizeControlWindow
	// NOTE: If we change the UUID, we also need to update _IRichTextBoxEvents_CP.h!
	[helpstring("Holds a rectangle's position and size."), uuid(42239B47-C660-4CC3-847C-A5EE735A8796)]
	typedef struct RECTANGLE
	{
		/// \brief <em>Holds the position of the rectangle's left border in pixels</em>
		[helpstring("Holds the position of the rectangle's left border in pixels.")]
		OLE_XPOS_PIXELS Left;
		/// \brief <em>Holds the position of the rectangle's upper border in pixels</em>
		[helpstring("Holds the position of the rectangle's upper border in pixels.")]
		OLE_YPOS_PIXELS Top;
		/// \brief <em>Holds the position of the rectangle's right border in pixels</em>
		[helpstring("Holds the position of the rectangle's right border in pixels.")]
		OLE_XPOS_PIXELS Right;
		/// \brief <em>Holds the position of the rectangle's lower border in pixels</em>
		[helpstring("Holds the position of the rectangle's lower border in pixels.")]
		OLE_YPOS_PIXELS Bottom;
	} RECTANGLE;


	/// \interface IOLEDataObject
	/// \brief <em>Wraps the \c IDataObject interface</em>
	///
	/// This interface provides easy access to data being transferred using the \c IDataObject interface.
	///
	/// \sa _IOLEDataObjectEvents,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
	[
		object,
		uuid(443C19CF-D862-4145-A900-6B2515213C9F),
		dual,
		nonextensible,
		helpstring("IOLEDataObject interface"),
		pointer_default(unique)
	]
	interface IOLEDataObject : IDispatch
	{
		/// \brief <em>Deletes the contents of the \c OLEDataObject object</em>
		///
		/// \remarks This method will succeed only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
		[id(DISPID_ODO_CLEAR), helpstring("Deletes the contents of the 'OLEDataObject' object.")]
		HRESULT Clear(void);
		/// \brief <em>Retrieves the best format settings from the \c OLEDataObject object</em>
		///
		/// Call this method to retrieve data format settings that match best with the data format, that you
		/// actually want to work with. Set the parameters to the data format settings you want to work with.
		/// The method will set them to the settings you should use.
		///
		/// \param[in,out] formatID An integer value specifying the data format. Valid values are those defined
		///                by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///                registered using the \c RegisterClipboardFormat API function.
		/// \param[in,out] index An integer value that is assigned to the internal \c FORMATETC struct's
		///                \c lindex member. Usually you pass -1 here, but some formats like
		///                \c CFSTR_FILECONTENTS require multiple \c FORMATETC structs for the same format. In
		///                such cases you'll give each struct of this format a separate index.
		/// \param[in,out] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
		///                struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
		///                Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \sa GetData, GetFormat,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETCANONICALFORMAT), helpstring("Call this method to retrieve data format settings that match best with the data format, that you actually want to work with.")]
		HRESULT GetCanonicalFormat([in, out] LONG* formatID, [in, out] LONG* Index, [in, out] LONG* dataOrViewAspect);
		/// \brief <em>Retrieves data from the \c OLEDataObject object</em>
		///
		/// Retrieves data from the \c OLEDataObject object, that has the specified format.
		///
		/// \param[in] formatID An integer value specifying the format of the data to retrieve. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return The data that has the specified format.
		///
		/// \remarks This method will fail, if the \c OLEDataObject object does not contain data of the
		///          specified format.
		///
		/// \sa GetCanonicalFormat, GetFormat, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETDATA), helpstring("Retrieves data from the 'OLEDataObject' object.")]
		HRESULT GetData([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT* pData);
		/// \brief <em>Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object</em>
		///
		/// Retrieves the \c DROPDESCRIPTION data stored by the \c OLEDataObject object. The drop description
		/// describes what will happen if the user drops the dragged data at the current position. It is
		/// displayed at the bottom of the drag image.
		///
		/// \param[in,out] targetDescription Receives the description of the current drop target.
		/// \param[in,out] actionDescription Receives the description of the whole drop action, i. e. a string
		///                like <em>"Copy to %1"</em> where <em>"Copy to"</em> is the description of the current
		///                drop effect and <em>"%1"</em> is the placeholder for the drop target description
		///                specified by \c targetDescription.
		/// \param[in,out] icon Receives the icon used to visualize the current drop effect. Any of the values
		///                defined by the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa SetDropDescription, IRichTextBox::SupportOLEDragImages, DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_GETDROPDESCRIPTION), helpstring("Retrieves the 'DROPDESCRIPTION' data stored by the 'OLEDataObject' object. Requires Windows Vista or newer.")]
		HRESULT GetDropDescription([in, out, optional] VARIANT* targetDescription, [in, out, optional] VARIANT* actionDescription, [in, out, defaultvalue(0)] DropDescriptionIconConstants* Icon);
		/// \brief <em>Retrieves whether the \c OLEDataObject object contains data in a specific format</em>
		///
		/// \param[in] formatID An integer value specifying the format to check for. Valid values are those
		///            defined by VB's \c ClipBoardConstants enumeration, but also any other format that was
		///            registered using the \c RegisterClipboardFormat API function.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \return \c True, if the \c OLEDataObject object contains data in the specified format;
		///         otherwise \c False.
		///
		/// \sa GetCanonicalFormat, GetData, SetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_GETFORMAT), helpstring("Retrieves whether the 'OLEDataObject' object contains data in a specific format.")]
		HRESULT GetFormat([in] LONG formatID, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect, [out, retval] VARIANT_BOOL* pFormatAvailable);
		/// \brief <em>Inserts data into the \c OLEDataObject object using the specified format</em>
		///
		/// \param[in] formatID An integer value specifying the format of the data being passed. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.
		/// \param[in] data The data to insert. If not specified, the \c OLESetData event will be raised if
		///            data of the specified format is requested from the \c OLEDataObject object.
		/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
		///            member. Usually you pass -1 here, but some formats like \c CFSTR_FILECONTENTS require
		///            multiple \c FORMATETC structs for the same format. In such cases you'll give each struct
		///            of this format a separate index.
		/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
		///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
		///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
		///
		/// \remarks The \c data parameter is optional only if the \c OLEDataObject wraps the control's own
		///          implementation of the \c IDataObject interface.
		///
		/// \sa GetData, Clear, _IRichTextBoxEvents::OLESetData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
		[id(DISPID_ODO_SETDATA), helpstring("Inserts data into the 'OLEDataObject' object using the specified format.")]
		HRESULT SetData([in] LONG formatID, [in, optional] VARIANT data, [in, defaultvalue(-1)] LONG Index, [in, defaultvalue(1)] LONG dataOrViewAspect);
		/// \brief <em>Sets the drop description displayed below the drag image</em>
		///
		/// Sets the \c DROPDESCRIPTION data. The drop description describes what will happen if the user drops
		/// the dragged data at the current position. It is displayed at the bottom of the drag image.
		///
		/// \param[in] targetDescription The description of the current drop target.
		/// \param[in] actionDescription The description of the whole drop action, i. e. a string like <em>"Copy
		///            to %1"</em> where <em>"Copy to"</em> is the description of the current drop effect and
		///            <em>"%1"</em> is the placeholder for the drop target description specified by
		///            \c targetDescription.
		/// \param[in] icon The icon used to visualize the current drop effect. Any of the values defined by
		///            the \c DropDescriptionIconConstants enumeration is valid.
		///
		/// \remarks In the \c actionDescription string, the sign "%" is escaped as "%%".\n
		///          Requires Windows Vista or newer.
		///
		/// \sa GetDropDescription, IRichTextBox::SupportOLEDragImages, DropDescriptionIconConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb773268.aspx">DROPDESCRIPTION</a>
		[id(DISPID_ODO_SETDROPDESCRIPTION), helpstring("Sets the drop description displayed below the drag image. Requires Windows Vista or newer.")]
		HRESULT SetDropDescription([in, optional] VARIANT targetDescription, [in, optional] VARIANT actionDescription, [in, defaultvalue(ddiNone)] DropDescriptionIconConstants Icon);
	}


	/// \interface _IOLEDataObjectEvents
	/// \brief <em>The \c OLEDataObject class' events interface</em>
	///
	/// This interface defines all events the \c OLEDataObject class may raise.
	///
	/// \sa IOLEDataObject
	[
		uuid(7AA6DA56-9377-453F-915D-20142981F16A),
		helpstring("IOLEDataObject-event-interface")
	]
	dispinterface _IOLEDataObjectEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c OLEDataObject class</em>
	///
	/// This COM class implements the \c IOLEDataObject and \c _IOLEDataObjectEvents interfaces.
	///
	/// \sa IOLEDataObject, _IOLEDataObjectEvents
	[
		uuid(10838426-1AB0-46C4-82B0-F3B6F4D0A0FF),
		version(1.0),
		noncreatable,
		helpstring("OLEDataObject Class 1.0 (ANSI)")
	]
	coclass OLEDataObject
	{
		[default] interface IOLEDataObject;
		[default, source] dispinterface _IOLEDataObjectEvents;
	};


	/// \interface IRichTextFont
	/// \brief <em>Wraps a text range's styling, e.g. font and colors</em>
	///
	/// This interface is a wrapper around the styling of a text range.
	///
	/// \sa _IRichTextFontEvents, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(198178B4-C120-488A-BFB8-56B67BBEB66D),
		dual,
		nonextensible,
		helpstring("IRichTextFont interface"),
		pointer_default(unique)
	]
	interface IRichTextFont : IDispatch
	{
		// \brief <em>To be documented</em>
		//
		// To be documented
		//
		// \sa IsMathZone, RichTextBox::DefaultMathZoneHAlignment
		//[propget, id(DISPID_TF_ALIGNEQUATIONSATOPERATOR), helpstring("To be documented.")]
		//HRESULT AlignEquationsAtOperator([out, retval] SHORT* pValue);
		//[propput, id(DISPID_TF_ALIGNEQUATIONSATOPERATOR), helpstring("To be documented.")]
		//HRESULT AlignEquationsAtOperator([in] SHORT newValue);
		/// \brief <em>Specifies whether the characters are all uppercase</em>
		///
		/// Retrieves or sets whether the characters are all uppercase. Any of the values defined by the
		/// \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the characters are all
		/// uppercase; if set to \c bpvFalse, they are not all uppercase; and if set to \c bpvUndefined, some
		/// of the characters are uppercase and others are not.
		///
		/// \sa SmallCaps, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_ALLCAPS), helpstring("Retrieves or sets whether the characters are all uppercase.")]
		HRESULT AllCaps([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_ALLCAPS), helpstring("Retrieves or sets whether the characters are all uppercase.")]
		HRESULT AllCaps([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies how the text is animated</em>
		///
		/// Retrieves or sets whether and how the text is animated. Any of the values defined by the
		/// \c AnimationTypeConstants enumeration is valid. If the text range uses multiple animation
		/// types, the type will be reported as \c atUndefined.
		///
		/// \sa AnimationTypeConstants
		[propget, id(DISPID_TF_ANIMATIONTYPE), helpstring("Retrieves or sets whether and how the text is animated. If the text range uses multiple animation types, the type will be reported as 'atUndefined'.")]
		HRESULT AnimationType([out, retval] AnimationTypeConstants* pValue);
		[propput, id(DISPID_TF_ANIMATIONTYPE), helpstring("Retrieves or sets whether and how the text is animated. If the text range uses multiple animation types, the type will be reported as 'atUndefined'.")]
		HRESULT AnimationType([in] AnimationTypeConstants newValue);
		/// \brief <em>Specifies whether ligatures in entered text are detected and converted automatically</em>
		///
		/// Retrieves or sets whether character combinations like \c f+i are detected and replaced by ligatures
		/// like \c ﬁ automatically. Any of the values defined by the \c BooleanPropertyValueConstants
		/// enumeration is valid. If set to \c bpvTrue, ligatures are detected and used automatically; if set
		/// to \c bpvFalse, they are not detected and used automatically; and if set to \c bpvUndefined, some
		/// parts of the text range use automatic ligature detection and others don't.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa BooleanPropertyValueConstants
		[propget, id(DISPID_TF_AUTOLIGATURES), helpstring("Retrieves or sets whether character combinations like 'f+i' are detected and replaced by ligatures like 'ﬁ' automatically. Requires Rich Edit 8.0 or newer.")]
		HRESULT AutoLigatures([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_AUTOLIGATURES), helpstring("Retrieves or sets whether character combinations like 'f+i' are detected and replaced by ligatures like 'ﬁ' automatically. Requires Rich Edit 8.0 or newer.")]
		HRESULT AutoLigatures([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies the text range's background color</em>
		///
		/// Retrieves or sets the text range's background color. If set to -1, the default background color is
		/// used.
		///
		/// \sa ForeColor, IRichTextBox::ExtendFontBackColorToWholeLine, IRichTextBox::BackColor
		[propget, id(DISPID_TF_BACKCOLOR), helpstring("Retrieves or sets the text range's background color. If set to -1, the default background color is used.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TF_BACKCOLOR), helpstring("Retrieves or sets the text range's background color. If set to -1, the default background color is used.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies whether the text is drawn bold</em>
		///
		/// Retrieves or sets whether the characters are bold. Any of the values defined by the
		/// \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the characters are
		/// bold; if set to \c bpvFalse, they are not bold; and if set to \c bpvUndefined, some of the
		/// characters are bold and others are not.
		///
		/// \sa Weight, Italic, Name, Size, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_BOLD), helpstring("Retrieves or sets whether the characters are bold.")]
		HRESULT Bold([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_BOLD), helpstring("Retrieves or sets whether the characters are bold.")]
		HRESULT Bold([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Retrieves whether the styling of the text range can be changed</em>
		///
		/// Retrieves whether the styling of the text range can be changed. Any of the values defined by the
		/// \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the styling can be
		/// changed; if set to \c bpvFalse, it cannot be changed; and if set to \c bpvUndefined, parts of the
		/// text range's styling can be changed and others can't.
		///
		/// \remarks This property is read-only.
		///
		/// \sa BooleanPropertyValueConstants
		[propget, id(DISPID_TF_CANCHANGE), helpstring("Retrieves whether the styling of the text range can be changed. This property is read-only."), nonbrowsable]
		HRESULT CanChange([out, retval] BooleanPropertyValueConstants* pValue);
		/// \brief <em>Controls how the text is displayed within a math zone</em>
		///
		/// Retrieves or sets whether the text, which is located inside a math zone, is displayed as normal
		/// text. Any of the values defined by the \c BooleanPropertyValueConstants enumeration is valid. If
		/// set to \c bpvTrue, the text is displayed as ordinary text; if set to \c bpvFalse, they it is
		/// displayed as part of the mathematics; and if set to \c bpvUndefined, parts of the text range are
		/// displayed as ordinary text and others as part of the mathematics.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IsMathZone, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_DISPLAYASORIDNARYTEXTWITHINMATHZONE), helpstring("Retrieves or sets whether the text, which is located inside a math zone, is displayed as normal text. Requires Rich Edit 8.0 or newer.")]
		HRESULT DisplayAsOrdinaryTextWithMathZone([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_DISPLAYASORIDNARYTEXTWITHINMATHZONE), helpstring("Retrieves or sets whether the text, which is located inside a math zone, is displayed as normal text. Requires Rich Edit 8.0 or newer.")]
		HRESULT DisplayAsOrdinaryTextWithMathZone([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies whether the text is drawn embossed</em>
		///
		/// Retrieves or sets whether the characters are embossed. Any of the values defined by the
		/// \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the characters are
		/// embossed; if set to \c bpvFalse, they are not embossed; and if set to \c bpvUndefined, some of the
		/// characters are embossed and others are not.
		///
		/// \sa Engrave, Outline, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_EMBOSS), helpstring("Retrieves or sets whether the characters are embossed.")]
		HRESULT Emboss([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_EMBOSS), helpstring("Retrieves or sets whether the characters are embossed.")]
		HRESULT Emboss([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies whether the text is drawn engraved</em>
		///
		/// Retrieves or sets whether the characters are displayed as imprinted characters. Any of the values
		/// defined by the \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the
		/// characters are displayed as imprinted characters; if set to \c bpvFalse, they are not displayed as
		/// imprinted characters; and if set to \c bpvUndefined, some of the characters are displayed as
		/// imprinted characters and others are not.
		///
		/// \sa Emboss, Outline, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_ENGRAVE), helpstring("Retrieves or sets whether the characters are displayed as imprinted characters.")]
		HRESULT Engrave([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_ENGRAVE), helpstring("Retrieves or sets whether the characters are displayed as imprinted characters.")]
		HRESULT Engrave([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies the text range's text color</em>
		///
		/// Retrieves or sets the text range's text color. If set to -1, the default text color is used.
		///
		/// \sa BackColor, Hidden
		[propget, id(DISPID_TF_FORECOLOR), helpstring("Retrieves or sets the text range's text color. If set to -1, the default text color is used.")]
		HRESULT ForeColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TF_FORECOLOR), helpstring("Retrieves or sets the text range's text color. If set to -1, the default text color is used.")]
		HRESULT ForeColor([in] OLE_COLOR newValue);
		/// \brief <em>Specifies whether the text is hidden</em>
		///
		/// Retrieves or sets whether the characters are hidden. Any of the values defined by the
		/// \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the characters are
		/// hidden; if set to \c bpvFalse, they are not hidden; and if set to \c bpvUndefined, some of the
		/// characters are hidden and others are not.
		///
		/// \sa ForeColor, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_HIDDEN), helpstring("Retrieves or sets whether the characters are hidden.")]
		HRESULT Hidden([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_HIDDEN), helpstring("Retrieves or sets whether the characters are hidden.")]
		HRESULT Hidden([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Controls the font's character width</em>
		///
		/// Retrieves or sets the percentage by which the width of each character in the range is scaled.
		///
		/// \remarks Requires Rich Edit 6.0 or newer.
		///
		/// \sa Size, Spacing
		[propget, id(DISPID_TF_HORIZONTALSCALING), helpstring("Retrieves or sets the percentage by which the width of each character in the range is scaled. Requires Rich Edit 6.0 or newer.")]
		HRESULT HorizontalScaling([out, retval] LONG* pValue);
		[propput, id(DISPID_TF_HORIZONTALSCALING), helpstring("Retrieves or sets the percentage by which the width of each character in the range is scaled. Requires Rich Edit 6.0 or newer.")]
		HRESULT HorizontalScaling([in] LONG newValue);
		/// \brief <em>Specifies whether the text range is a hyperlink</em>
		///
		/// Retrieves whether the text range is a hyperlink, that has been detected automatically. Any of the
		/// values defined by the \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue,
		/// the text range is an automatically detected hyperlink; if set to \c bpvFalse, it is not a hyperlink
		/// or has not been detected automatically; and if set to \c bpvUndefined, some parts of the text range
		/// are an automatically detected hyperlink and others are not.
		///
		/// \remarks Requires Rich Edit 6.0 or newer.\n
		///          This property is read-only.
		///
		/// \sa IsLink, IRichTextRange::URL, IRichTextBox::AutoDetectURLs, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_ISAUTOMATICLINK), helpstring("Retrieves whether the text range is a hyperlink, that has been detected automatically. Requires Rich Edit 6.0 or newer. This property is read-only."), nonbrowsable]
		HRESULT IsAutomaticLink([out, retval] BooleanPropertyValueConstants* pValue);
		/// \brief <em>Specifies whether the text range is a math zone that is embedded in a normal line of text</em>
		///
		/// Retrieves whether the text range is a zone for entering formulas, and is embedded in a normal line
		/// of text. Any of the values defined by the \c BooleanPropertyValueConstants enumeration is valid. If
		/// set to \c bpvTrue, the text range is an inline math zone; if set to \c bpvFalse, it is not an
		/// inline math zone (might be a math zone that has its own paragraph); and if set to \c bpvUndefined,
		/// some parts of the text range are an inline math zone and others are not.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.\n
		///          This property is read-only.
		///
		/// \sa IsMathZone, IRichTextRange::BuildUpMath, IRichTextBox::AllowMathZoneInsertion,
		///     DisplayAsOrdinaryTextWithMathZone, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_ISINLINEMATHZONE), helpstring("Retrieves or sets whether the text range is a zone for entering formulas, and is embedded in a normal line of text. Requires Rich Edit 8.0 or newer. This property is read-only."), nonbrowsable]
		HRESULT IsInlineMathZone([out, retval] BooleanPropertyValueConstants* pValue);
		/// \brief <em>Specifies whether the text range is a hyperlink</em>
		///
		/// Retrieves whether the text range is a hyperlink, either detected automatically or created manually.
		/// Any of the values defined by the \c BooleanPropertyValueConstants enumeration is valid. If set to
		/// \c bpvTrue, the text range is a hyperlink; if set to \c bpvFalse, it is not a hyperlink; and if set
		/// to \c bpvUndefined, some parts of the text range are a hyperlink and others are not.
		///
		/// \remarks Requires Rich Edit 6.0 or newer.\n
		///          This property is read-only.
		///
		/// \sa IsAutomaticLink, IRichTextRange::URL, IRichTextBox::AutoDetectURLs,
		///     BooleanPropertyValueConstants
		[propget, id(DISPID_TF_ISLINK), helpstring("Retrieves whether the text range is a hyperlink, either detected automatically or created manually. Requires Rich Edit 6.0 or newer. This property is read-only."), nonbrowsable]
		HRESULT IsLink([out, retval] BooleanPropertyValueConstants* pValue);
		/// \brief <em>Specifies whether the text range is a math zone</em>
		///
		/// Retrieves or sets whether the text range is a zone for entering formulas. Any of the values defined
		/// by the \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the text range
		/// is a math zone; if set to \c bpvFalse, it is not a math zone; and if set to \c bpvUndefined, some
		/// parts of the text range are a math zone and others are not.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IsInlineMathZone, IRichTextRange::BuildUpMath, IRichTextBox::AllowMathZoneInsertion,
		///     DisplayAsOrdinaryTextWithMathZone, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_ISMATHZONE), helpstring("Retrieves or sets whether the text range is a zone for entering formulas. Requires Rich Edit 8.0 or newer.")]
		HRESULT IsMathZone([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_ISMATHZONE), helpstring("Retrieves or sets whether the text range is a zone for entering formulas. Requires Rich Edit 8.0 or newer.")]
		HRESULT IsMathZone([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies whether the text is drawn in italics</em>
		///
		/// Retrieves or sets whether the characters are in italics. Any of the values defined by the
		/// \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the characters are in
		/// italics; if set to \c bpvFalse, they are not in italics; and if set to \c bpvUndefined, some of the
		/// characters are in italics and others are not.
		///
		/// \sa Bold, Name, Size, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_ITALIC), helpstring("Retrieves or sets whether the characters are in italics.")]
		HRESULT Italic([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_ITALIC), helpstring("Retrieves or sets whether the characters are in italics.")]
		HRESULT Italic([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies the minimum font size at which kerning is applied</em>
		///
		/// Retrieves or sets the minimum font size at which kerning is applied. If the text range uses
		/// multiple kerning sizes, the size will be reported as -9999999.
		///
		/// \sa Size, Spacing
		[propget, id(DISPID_TF_KERNINGSIZE), helpstring("Retrieves or sets the minimum font size at which kerning is applied. If the text range uses multiple kerning sizes, the size will be reported as -9999999.")]
		HRESULT KerningSize([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TF_KERNINGSIZE), helpstring("Retrieves or sets the minimum font size at which kerning is applied. If the text range uses multiple kerning sizes, the size will be reported as -9999999.")]
		HRESULT KerningSize([in] FLOAT newValue);
		/// \brief <em>Specifies the text's locale identifier</em>
		///
		/// Retrieves or sets the identifier of the locale that the text is in.
		///
		/// \sa IRichTextBox::UseBuiltInSpellChecking
		[propget, id(DISPID_TF_LOCALE), helpstring("Retrieves or sets the identifier of the locale that the text is in.")]
		HRESULT Locale([out, retval] LONG* pValue);
		[propput, id(DISPID_TF_LOCALE), helpstring("Retrieves or sets the identifier of the locale that the text is in.")]
		HRESULT Locale([in] LONG newValue);
		/// \brief <em>Specifies the name of the font the text is drawn in</em>
		///
		/// Retrieves or sets the name of the font the text is drawn in. If the text range uses multiple fonts,
		/// the name will be reported as an empty string.
		///
		/// \sa Size, IRichTextBox::Font
		[propget, id(DISPID_TF_NAME), helpstring("Retrieves or sets the name of the font the text is drawn in. If the text range uses multiple fonts, the name will be reported as an empty string.")]
		HRESULT Name([out, retval] BSTR* pValue);
		[propput, id(DISPID_TF_NAME), helpstring("Retrieves or sets the name of the font the text is drawn in. If the text range uses multiple fonts, the name will be reported as an empty string.")]
		HRESULT Name([in] BSTR newValue);
		/// \brief <em>Specifies whether the characters are displayed as outlined characters</em>
		///
		/// Retrieves or sets whether the characters are displayed as outlined characters. Any of the values
		/// defined by the \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the
		/// characters are displayed as outlined characters; if set to \c bpvFalse, they are not displayed as
		/// outlined characters; and if set to \c bpvUndefined, some of the characters are displayed as
		/// outlined characters and others are not.
		///
		/// \sa Emboss, Engrave, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_OUTLINE), helpstring("Retrieves or sets whether the characters are displayed as outlined characters.")]
		HRESULT Outline([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_OUTLINE), helpstring("Retrieves or sets whether the characters are displayed as outlined characters.")]
		HRESULT Outline([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies whether the text range can be modified</em>
		///
		/// Retrieves or sets whether the text range is protected against modifications. Any of the values
		/// defined by the \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the
		/// text range is protected against modifications; if set to \c bpvFalse, it is not protected; and if
		/// set to \c bpvUndefined, parts of the text range are protected and others are not.
		///
		/// \sa CanChange, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_PROTECTED), helpstring("Retrieves or sets whether the text range is protected against modifications.")]
		HRESULT Protected([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_PROTECTED), helpstring("Retrieves or sets whether the text range is protected against modifications.")]
		HRESULT Protected([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies whether the text range has been revised</em>
		///
		/// Retrieves or sets whether the text range has been revised. Any of the values defined by the
		/// \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the text range has
		/// been revised; if set to \c bpvFalse, it has not been revised; and if set to \c bpvUndefined, parts
		/// of the text range have been revised and others not.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.
		///
		/// \sa BooleanPropertyValueConstants
		[propget, id(DISPID_TF_REVISED), helpstring("Retrieves or sets whether the text range has been revised. Requires Rich Edit 7.5 or newer.")]
		HRESULT Revised([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_REVISED), helpstring("Retrieves or sets whether the text range has been revised. Requires Rich Edit 7.5 or newer.")]
		HRESULT Revised([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies whether the characters are displayed as shadowed characters</em>
		///
		/// Retrieves or sets whether the characters are displayed as shadowed characters. Any of the values
		/// defined by the \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the
		/// characters are displayed as shadowed characters; if set to \c bpvFalse, they are displayed
		/// normally; and if set to \c bpvUndefined, some of the characters are displayed as shadowed
		/// characters and others are displayed normally.
		///
		/// \sa Bold, Italic, Name, Size, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_SHADOW), helpstring("Retrieves or sets whether the characters are displayed as shadowed characters.")]
		HRESULT Shadow([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_SHADOW), helpstring("Retrieves or sets whether the characters are displayed as shadowed characters.")]
		HRESULT Shadow([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies the size of the font the text is drawn in</em>
		///
		/// Retrieves or sets the size of the font the text is drawn in. If the text range uses multiple font
		/// sizes, the size will be reported as -9999999.
		///
		/// \sa Name, Spacing, KerningSize, HorizontalScaling, IRichTextBox::Font
		[propget, id(DISPID_TF_SIZE), helpstring("Retrieves or sets the size of the font the text is drawn in. If the text range uses multiple font sizes, the size will be reported as -9999999.")]
		HRESULT Size([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TF_SIZE), helpstring("Retrieves or sets the size of the font the text is drawn in. If the text range uses multiple font sizes, the size will be reported as -9999999.")]
		HRESULT Size([in] FLOAT newValue);
		/// \brief <em>Specifies whether the characters are in small capital letters</em>
		///
		/// Retrieves or sets whether the characters are in small capital letters. Any of the values defined by
		/// the \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the characters are
		/// in small capital letters; if set to \c bpvFalse, they are not in small capital letters; and if set
		/// to \c bpvUndefined, some of the characters are in small capital letters and others are not.
		///
		/// \sa AllCaps, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_SMALLCAPS), helpstring("Retrieves or sets whether the characters are in small capital letters.")]
		HRESULT SmallCaps([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_SMALLCAPS), helpstring("Retrieves or sets whether the characters are in small capital letters.")]
		HRESULT SmallCaps([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies the amount of horizontal spacing between characters</em>
		///
		/// Retrieves or sets the amount of horizontal spacing between characters, in floating-point points.
		/// If the text range uses multiple spacings, the spacing will be reported as -9999999.
		///
		/// \sa HorizontalScaling, Size, Name
		[propget, id(DISPID_TF_SPACING), helpstring("Retrieves or sets the amount of horizontal spacing between characters. If the text range uses multiple spacings, the spacing will be reported as -9999999.")]
		HRESULT Spacing([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TF_SPACING), helpstring("Retrieves or sets the amount of horizontal spacing between characters. If the text range uses multiple spacings, the spacing will be reported as -9999999.")]
		HRESULT Spacing([in] FLOAT newValue);
		/// \brief <em>Specifies whether the characters are displayed with a horizontal line through the center</em>
		///
		/// Retrieves or sets whether the characters are displayed with a horizontal line through the center.
		/// Any of the values defined by the \c BooleanPropertyValueConstants enumeration is valid. If set to
		/// \c bpvTrue, the characters are stroke out; if set to \c bpvFalse, they are not stroke out; and if
		/// set to \c bpvUndefined, some of the characters are stroke out and others are not.
		///
		/// \sa UnderlineType, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_STRIKETHROUGH), helpstring("Retrieves or sets whether the characters are displayed with a horizontal line through the center.")]
		HRESULT StrikeThrough([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_STRIKETHROUGH), helpstring("Retrieves or sets whether the characters are displayed with a horizontal line through the center.")]
		HRESULT StrikeThrough([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies the style assigned to the text range</em>
		///
		/// Retrieves or sets the unique ID of the style assigned to the text. If the text range uses multiple
		/// styles, the style will be reported as -9999999.\n
		/// This property can also be set to one of the built-in styles defined by the \c BuiltInStyleConstants
		/// enumeration.
		///
		/// \sa BuiltInStyleConstants
		[propget, id(DISPID_TF_STYLEID), helpstring("Retrieves or sets the unique ID of the style assigned to the text. If the text range uses multiple styles, the style will be reported as -9999999.")]
		HRESULT StyleID([out, retval] LONG* pValue);
		[propput, id(DISPID_TF_STYLEID), helpstring("Retrieves or sets the unique ID of the style assigned to the text. If the text range uses multiple styles, the style will be reported as -9999999.")]
		HRESULT StyleID([in] LONG newValue);
		/// \brief <em>Specifies whether the characters are displayed as subscript</em>
		///
		/// Retrieves or sets whether the characters are displayed as subscript. Any of the values defined by
		/// the \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the characters are
		/// displayed as subscript; if set to \c bpvFalse, they are not displayed as subscript; and if set to
		/// \c bpvUndefined, some of the characters are displayed as subscript and others are not.
		///
		/// \sa Superscript, VerticalOffset, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_SUBSCRIPT), helpstring("Retrieves or sets whether the characters are displayed as subscript.")]
		HRESULT Subscript([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_SUBSCRIPT), helpstring("Retrieves or sets whether the characters are displayed as subscript.")]
		HRESULT Subscript([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies whether the characters are displayed as superscript</em>
		///
		/// Retrieves or sets whether the characters are displayed as superscript. Any of the values defined by
		/// the \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the characters are
		/// displayed as superscript; if set to \c bpvFalse, they are not displayed as superscript; and if set
		/// to \c bpvUndefined, some of the characters are displayed as superscript and others are not.
		///
		/// \sa Subscript, VerticalOffset, BooleanPropertyValueConstants
		[propget, id(DISPID_TF_SUPERSCRIPT), helpstring("Retrieves or sets whether the characters are displayed as superscript.")]
		HRESULT Superscript([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TF_SUPERSCRIPT), helpstring("Retrieves or sets whether the characters are displayed as superscript.")]
		HRESULT Superscript([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies the font's corresponding TeX style</em>
		///
		/// Retrieves or sets the TeX style of the font, if the font refers to a math zone. Any of the values
		/// defined by the \c TeXFontStyleConstants enumeration is valid.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IsMathZone, TeXFontStyleConstants
		[propget, id(DISPID_TF_TEXSTYLE), helpstring("Retrieves or sets the TeX style of the font, if the font refers to a math zone. Requires Rich Edit 8.0 or newer.")]
		HRESULT TeXStyle([out, retval] TeXFontStyleConstants* pValue);
		[propput, id(DISPID_TF_TEXSTYLE), helpstring("Retrieves or sets the TeX style of the font, if the font refers to a math zone. Requires Rich Edit 8.0 or newer.")]
		HRESULT TeXStyle([in] TeXFontStyleConstants newValue);
		/// \brief <em>Specifies the color in which the text's underline is drawn</em>
		///
		/// Retrieves or sets the zero-based index of the color in which the text's underline is drawn.
		/// If set to zero, the underline is drawn in the same color as the text; otherwise the value is the
		/// index of the effect color to use. Effect colors are specified by the \c IRichTextBox::EffectColor
		/// property.
		///
		/// \sa IRichTextBox::EffectColor, ForeColor, UnderlineType, UnderlinePosition
		[propget, id(DISPID_TF_UNDERLINECOLORINDEX), helpstring("Retrieves or sets the zero-based index of the color in which the text's underline is drawn. If set to zero, the underline is drawn in the same color as the text.")]
		HRESULT UnderlineColorIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_TF_UNDERLINECOLORINDEX), helpstring("Retrieves or sets the zero-based index of the color in which the text's underline is drawn. If set to zero, the underline is drawn in the same color as the text.")]
		HRESULT UnderlineColorIndex([in] LONG newValue);
		/// \brief <em>Specifies where the text's underlining is drawn</em>
		///
		/// Retrieves or sets the position that the text's underlining is drawn at. Any of the values defined
		/// by the \c UnderlinePositionConstants enumeration is valid. If the text range uses multiple
		/// underline positions, the position will be reported as \c upUndefined.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa UnderlineType, UnderlineColorIndex, UnderlinePositionConstants
		[propget, id(DISPID_TF_UNDERLINEPOSITION), helpstring("Retrieves or sets the position that the text's underlining is drawn at. If the text range uses multiple underline positions, the position will be reported as 'upUndefined'. Requires Rich Edit 8.0 or newer.")]
		HRESULT UnderlinePosition([out, retval] UnderlinePositionConstants* pValue);
		[propput, id(DISPID_TF_UNDERLINEPOSITION), helpstring("Retrieves or sets the position that the text's underlining is drawn at. If the text range uses multiple underline positions, the position will be reported as 'upUndefined'. Requires Rich Edit 8.0 or newer.")]
		HRESULT UnderlinePosition([in] UnderlinePositionConstants newValue);
		/// \brief <em>Specifies whether the text is drawn underlined</em>
		///
		/// Retrieves or sets whether the characters are underlined. Any of the values defined by the
		/// \c UnderlineTypeConstants enumeration is valid. If the text range uses multiple underline
		/// types, the type will be reported as \c utUndefined.
		///
		/// \sa UnderlineColorIndex, Weight, Italic, Name, Size, UnderlinePosition, UnderlineTypeConstants
		[propget, id(DISPID_TF_UNDERLINETYPE), helpstring("Retrieves or sets whether the characters are underlined. If the text range uses multiple underline types, the type will be reported as 'utUndefined'.")]
		HRESULT UnderlineType([out, retval] UnderlineTypeConstants* pValue);
		[propput, id(DISPID_TF_UNDERLINETYPE), helpstring("Retrieves or sets whether the characters are underlined. If the text range uses multiple underline types, the type will be reported as 'utUndefined'.")]
		HRESULT UnderlineType([in] UnderlineTypeConstants newValue);
		/// \brief <em>Specifies the amount of vertical offset</em>
		///
		/// Retrieves or sets the amount that characters are offset vertically relative to the baseline, in
		/// floating-point points. If the text range uses multiple offsets, the offset will be reported as
		/// -9999999.
		///
		/// \sa Subscript, Superscript
		[propget, id(DISPID_TF_VERTICALOFFSET), helpstring("Retrieves or sets the amount that characters are offset vertically relative to the baseline. If the text range uses multiple offsets, the offset will be reported as -9999999.")]
		HRESULT VerticalOffset([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TF_VERTICALOFFSET), helpstring("Retrieves or sets the amount that characters are offset vertically relative to the baseline. If the text range uses multiple offsets, the offset will be reported as -9999999.")]
		HRESULT VerticalOffset([in] FLOAT newValue);
		/// \brief <em>Specifies the font weight the text is drawn with</em>
		///
		/// Retrieves or sets the font weight the characters are drawn with. Any of the values defined by the
		/// \c FontWeightConstants enumeration is valid. If the text range uses multiple font weights,
		/// the weight will be reported as \c fwUndefined.
		///
		/// \sa Bold, Italic, Name, Size, FontWeightConstants
		[propget, id(DISPID_TF_WEIGHT), helpstring("Retrieves or sets the font weight the characters are drawn with. If the text range uses multiple font weights, the weight will be reported as 'fwUndefined'.")]
		HRESULT Weight([out, retval] FontWeightConstants* pValue);
		[propput, id(DISPID_TF_WEIGHT), helpstring("Retrieves or sets the font weight the characters are drawn with. If the text range uses multiple font weights, the weight will be reported as 'fwUndefined'.")]
		HRESULT Weight([in] FontWeightConstants newValue);

		/// \brief <em>Creates a new \c IRichTextFont instance with identical properties</em>
		///
		/// \return The new \c IRichTextFont instance.
		///
		/// \sa CopySettings, Equals
		[id(DISPID_TF_CLONE), helpstring("Creates a new 'TextFont' instance with identical properties.")]
		HRESULT Clone([out, retval] IRichTextFont** ppClone);
		/// \brief <em>Copies all settings from an other \c IRichTextFont instance</em>
		///
		/// \param[in] sourceObject The \c IRichTextFont instance to copy from.
		///
		/// \sa Clone, Equals
		[id(DISPID_TF_COPYSETTINGS), helpstring("Copies all settings from an other 'TextFont' instance.")]
		HRESULT CopySettings([in] IRichTextFont* sourceObject);
		/// \brief <em>Retrieves whether two \c IRichTextFont instances have the same properties</em>
		///
		/// \param[in] compareAgainst The \c IRichTextFont instance to compare with.
		///
		/// \return \c True, if the objects have the same properties; otherwise \c False.
		///
		/// \remarks Properties that are set to 'undefined' are ignored.
		///
		/// \sa Clone, CopySettings
		[id(DISPID_TF_EQUALS), helpstring("Retrieves whether two 'TextFont' instances have the same properties.")]
		HRESULT Equals([in] IRichTextFont* compareAgainst, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Resets the text range's character formatting</em>
		///
		/// Resets the text range's character formatting, applying the specified rules.
		///
		/// \param[in] rules The rules to apply. Any of the values defined by the \c ResetRulesConstants
		///            enumeration is valid.
		///
		/// \sa ResetRulesConstants
		[id(DISPID_TF_RESET), helpstring("Resets the text range's character formatting, applying the specified rules.")]
		HRESULT Reset([in] ResetRulesConstants rules);
	}


	/// \interface _IRichTextFontEvents
	/// \brief <em>The \c TextFont class' events interface</em>
	///
	/// This interface defines all events the \c TextFont class may raise.
	///
	/// \sa IRichTextFont
	[
		uuid(FBE8037F-FCB6-4546-9A3C-53C11293FE3A),
		helpstring("IRichTextFont-event-interface")
	]
	dispinterface _IRichTextFontEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TextFont class</em>
	///
	/// This COM class implements the \c IRichTextFont and \c _IRichTextFontEvents interfaces.
	///
	/// \sa IRichTextFont, _IRichTextFontEvents, RichTextBox
	[
		uuid(35B513B8-688D-4F87-82FC-4EFA62F0B634),
		version(1.0),
		noncreatable,
		helpstring("TextFont Class 1.0 (ANSI)")
	]
	coclass TextFont
	{
		[default] interface IRichTextFont;
		[default, source] dispinterface _IRichTextFontEvents;
	};


	/// \interface IRichTextParagraphTab
	/// \brief <em>Wraps a specific tab of a text range's paragraph</em>
	///
	/// This interface is a wrapper around a specific tab of a text range's paragraph.
	///
	/// \sa _IRichTextParagraphTabEvents, IRichTextParagraphTabs, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(9FBA623E-1E52-4371-BEC2-8BB233FF4CEF),
		dual,
		nonextensible,
		helpstring("IRichTextParagraphTab interface"),
		pointer_default(unique)
	]
	interface IRichTextParagraphTab : IDispatch
	{
		/// \brief <em>Controls the horizontal alignment of text at the tab</em>
		///
		/// Retrieves or sets the horizontal alignment of text at the tab. Any of the values defined by the
		/// \c TabAlignmentConstants enumeration is valid.
		///
		/// \sa Position, LeaderCharacter, IRichTextParagraph::HAlignment, TabAlignmentConstants
		[propget, id(DISPID_TPT_ALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of text at the tab.")]
		HRESULT Alignment([out, retval] TabAlignmentConstants* pValue);
		[propput, id(DISPID_TPT_ALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of text at the tab.")]
		HRESULT Alignment([in] TabAlignmentConstants newValue);
		/// \brief <em>Retrieves the tab's zero-based index</em>
		///
		/// Retrieves the zero-based index identifying this tab.
		///
		/// \remarks Changing a tab's position, or removing or adding new tabs may change a tab's index.\n
		///          This property is read-only.
		///
		/// \sa Position, TabIdentifierTypeConstants
		[propget, id(DISPID_TPT_INDEX), helpstring("Retrieves the zero-based index identifying this tab. This property is read-only.")]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Specifies how the space taken by the tab is filled</em>
		///
		/// Retrieves or sets the character that is used to fill the space taken by the tab. Any of the values
		/// defined by the \c TabLeaderCharacterConstants enumeration is valid.
		///
		/// \sa Position, Alignment, TabLeaderCharacterConstants
		[propget, id(DISPID_TPT_LEADERCHARACTER), helpstring("Retrieves or sets the character that is used to fill the space taken by the tab.")]
		HRESULT LeaderCharacter([out, retval] TabLeaderCharacterConstants* pValue);
		[propput, id(DISPID_TPT_LEADERCHARACTER), helpstring("Retrieves or sets the character that is used to fill the space taken by the tab.")]
		HRESULT LeaderCharacter([in] TabLeaderCharacterConstants newValue);
		/// \brief <em>Retrieves the tab's proceeding tab</em>
		///
		/// Retrieves the tab that proceeds this tab.
		///
		/// \remarks This property is read-only.
		///
		/// \sa PreviousTab, Index
		[propget, id(DISPID_TPT_NEXTTAB), helpstring("Retrieves the tab that proceeds this tab. This property is read-only.")]
		HRESULT NextTab([out, retval] IRichTextParagraphTab** ppTab);
		/// \brief <em>Specifies the tab's position</em>
		///
		/// Retrieves or sets the tab's position (in points).
		///
		/// \sa Index, LeaderCharacter, Alignment, TabIdentifierTypeConstants
		[propget, id(DISPID_TPT_POSITION), helpstring("Retrieves or sets the tab's position (in points).")]
		HRESULT Position([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TPT_POSITION), helpstring("Retrieves or sets the tab's position (in points).")]
		HRESULT Position([in] FLOAT newValue);
		/// \brief <em>Retrieves the tab's preceding tab</em>
		///
		/// Retrieves the tab that precedes this tab.
		///
		/// \remarks This property is read-only.
		///
		/// \sa NextTab, Index
		[propget, id(DISPID_TPT_PREVIOUSTAB), helpstring("Retrieves the tab that precedes this tab. This property is read-only.")]
		HRESULT PreviousTab([out, retval] IRichTextParagraphTab** ppTab);
	}


	/// \interface _IRichTextParagraphTabEvents
	/// \brief <em>The \c TextParagraphTab class' events interface</em>
	///
	/// This interface defines all events the \c TextParagraphTab class may raise.
	///
	/// \sa IRichTextParagraphTab
	[
		uuid(4888F5F6-D5B0-42E0-9375-4713DE0917B5),
		helpstring("IRichTextParagraphTab-event-interface")
	]
	dispinterface _IRichTextParagraphTabEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TextParagraphTab class</em>
	///
	/// This COM class implements the \c IRichTextParagraphTab and \c _IRichTextParagraphTabEvents
	/// interfaces.
	///
	/// \sa IRichTextParagraphTab, _IRichTextParagraphTabEvents, RichTextBox, TextParagraphTabs
	[
		uuid(3A29AAD8-C759-4002-8372-7235C9481392),
		version(1.0),
		noncreatable,
		helpstring("TextParagraphTab Class 1.0 (ANSI)")
	]
	coclass TextParagraphTab
	{
		[default] interface IRichTextParagraphTab;
		[default, source] dispinterface _IRichTextParagraphTabEvents;
	};


	/// \interface IRichTextParagraphTabs
	/// \brief <em>Manages a collection of \c TextParagraphTab objects</em>
	///
	/// This interface provides easy access to collections of \c TextParagraphTab objects.
	/// A \c TextParagraphTabs object is used to group tabs that have certain properties in common.
	///
	/// \sa _IRichTextParagraphTabsEvents, IRichTextParagraphTabs, IRichTextBox
	[
		object,
		uuid(4EF75ECD-4C9D-40CF-B938-C728F28BB23C),
		dual,
		nonextensible,
		helpstring("IRichTextParagraphTabs interface"),
		pointer_default(unique)
	]
	interface IRichTextParagraphTabs : IDispatch
	{
		/// \brief <em>Retrieves a \c TextParagraphTab object from the collection</em>
		///
		/// Retrieves a \c TextParagraphTab object from the collection that wraps the tab identified by
		/// \c tabIdentifier.
		///
		/// \param[in] tabIdentifier A value that identifies the tab to be retrieved.
		/// \param[in] tabIdentifierType A value specifying the meaning of \c tabIdentifier. Any of the
		///            values defined by the \c TabIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks This is the default property of the \c IRichTextParagraphTabs interface.\n
		///          This property is read-only.
		///
		/// \sa IRichTextParagraphTab, TabIdentifierTypeConstants, Add, Remove, Contains
		[propget, id(DISPID_TPTS_ITEM), helpstring("Retrieves a 'TextParagraphTab' object from the collection that wraps the tab identified by 'tabIdentifier'."), nonbrowsable]
		HRESULT Item([in] VARIANT tabIdentifier, [in, defaultvalue(titPosition)] TabIdentifierTypeConstants tabIdentifierType, [out, retval] IRichTextParagraphTab** ppTab);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c TextParagraphTab objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_TPTS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds a tab to the paragraph</em>
		///
		/// Adds a tab with the specified properties at the specified position in the paragraph and returns
		/// a \c TextParagraphTab object wrapping the inserted tab.
		///
		/// \param[in] tabPosition The new tab's position in pixels.
		/// \param[in] tabAlignment The text alignment at the new tab. Any of the values defined by the
		///            \c TabAlignmentConstants enumeration is valid.
		/// \param[in] leaderCharacter The character that is used to fill the space taken by the tab. Any of
		///            the values defined by the \c TabLeaderCharacterConstants enumeration is valid.
		///
		/// \return The inserted tab.
		///
		/// \sa Count, Remove, RemoveAll, IRichTextParagraphTab::Position, IRichTextParagraphTab::Alignment,
		///     IRichTextParagraphTab::LeaderCharacter, TabAlignmentConstants, TabLeaderCharacterConstants
		[id(DISPID_TPTS_ADD), helpstring("Adds a new tab with the specified properties.")]
		HRESULT Add([in] FLOAT tabPosition, [in, defaultvalue(taLeft)] TabAlignmentConstants tabAlignment, [in, defaultvalue(tlcSpaces)] TabLeaderCharacterConstants LeaderCharacter, [out, retval] IRichTextParagraphTab** ppAddedTab);
		/// \brief <em>Retrieves whether the specified tab is part of the tab collection</em>
		///
		/// \param[in] tabIdentifier A value that identifies the tab to be checked.
		/// \param[in] tabIdentifierType A value specifying the meaning of \c tabIdentifier. Any of the
		///            values defined by the \c TabIdentifierTypeConstants enumeration is valid.
		///
		/// \return \c True, if the specified tab is part of the collection; otherwise \c False.
		///
		/// \sa Add, Remove, TabIdentifierTypeConstants
		[id(DISPID_TPTS_CONTAINS), helpstring("Retrieves whether the specified tab is part of the tab collection.")]
		HRESULT Contains([in] VARIANT tabIdentifier, [in, defaultvalue(titPosition)] TabIdentifierTypeConstants tabIdentifierType, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the tabs in the collection</em>
		///
		/// Retrieves the number of \c TextParagraphTab objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_TPTS_COUNT), helpstring("Retrieves the number of 'TextParagraphTab' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the specified tab in the collection from the paragraph</em>
		///
		/// \param[in] tabIdentifier A value that identifies the tab to be removed.
		/// \param[in] tabIdentifierType A value specifying the meaning of \c tabIdentifier. Any of the
		///            values defined by the \c TabIdentifierTypeConstants enumeration is valid.
		///
		/// \sa Add, Count, RemoveAll, Contains, TabIdentifierTypeConstants
		[id(DISPID_TPTS_REMOVE), helpstring("Removes the specified tab in the collection from the paragraph.")]
		HRESULT Remove([in] VARIANT tabIdentifier, [in, defaultvalue(titPosition)] TabIdentifierTypeConstants tabIdentifierType);
		/// \brief <em>Removes all tabs in the collection from the paragraph</em>
		///
		/// \sa Add, Count, Remove
		[id(DISPID_TPTS_REMOVEALL), helpstring("Removes all tabs in the collection from the paragraph.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IRichTextParagraphTabsEvents
	/// \brief <em>The \c TextParagraphTabs class' events interface</em>
	///
	/// This interface defines all events the \c TextParagraphTabs class may raise.
	///
	/// \sa IRichTextParagraphTabs
	[
		uuid(AB95794E-D692-41FC-97F5-1414E4E27AC5),
		helpstring("IRichTextParagraphTabs-event-interface")
	]
	dispinterface _IRichTextParagraphTabsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TextParagraphTabs class</em>
	///
	/// This COM class implements the \c IRichTextParagraphTabs and \c _IRichTextParagraphTabsEvents
	/// interfaces.
	///
	/// \sa IRichTextParagraphTabs, _IRichTextParagraphTabsEvents, RichTextBox, TextParagraphTab
	[
		uuid(98C3AB49-F184-41B6-A841-160DA46EDA71),
		version(1.0),
		noncreatable,
		helpstring("TextParagraphTabs Class 1.0 (ANSI)")
	]
	coclass TextParagraphTabs
	{
		[default] interface IRichTextParagraphTabs;
		[default, source] dispinterface _IRichTextParagraphTabsEvents;
	};


	/// \interface IRichTextParagraph
	/// \brief <em>Wraps a text range paragraph's styling, e.g. alignment and line spacing</em>
	///
	/// This interface is a wrapper around the styling of a text range paragraph.
	///
	/// \sa _IRichTextParagraphEvents, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(F9D7FF7E-D9B9-4FBF-8D09-818A15A2B94B),
		dual,
		nonextensible,
		helpstring("IRichTextParagraph interface"),
		pointer_default(unique)
	]
	interface IRichTextParagraph : IDispatch
	{
		/// \brief <em>Retrieves whether the paragraph's formatting can be changed</em>
		///
		/// Retrieves whether the paragraph's formatting can be changed. Any of the values defined by the
		/// \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the formatting can be
		/// changed; if set to \c bpvFalse, it cannot be changed; and if set to \c bpvUndefined, parts of the
		/// paragraph can be changed and others can't.
		/// The formatting cannot be changed, if the document is read-only or any part of the paragraph is
		/// protected.
		///
		/// \remarks This property is read-only.
		///
		/// \sa BooleanPropertyValueConstants
		[propget, id(DISPID_TP_CANCHANGE), helpstring("Retrieves whether the paragraph's formatting can be changed. This property is read-only."), nonbrowsable]
		HRESULT CanChange([out, retval] BooleanPropertyValueConstants* pValue);
		/// \brief <em>Controls indentation of the paragraph's text</em>
		///
		/// Retrieves or sets the indent (in points) of the first line in the paragraph, relative to the
		/// control's left margin.
		///
		/// \sa LeftIndent, RightIndent
		[propget, id(DISPID_TP_FIRSTLINEINDENT), helpstring("Retrieves or sets the indent (in points) of the first line in the paragraph, relative to the control's left margin.")]
		HRESULT FirstLineIndent([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TP_FIRSTLINEINDENT), helpstring("Retrieves or sets the indent (in points) of the first line in the paragraph, relative to the control's left margin.")]
		HRESULT FirstLineIndent([in] FLOAT newValue);
		/// \brief <em>Controls the horizontal alignment of the paragraph's content</em>
		///
		/// Retrieves or sets the horizontal alignment of the paragraph's content. Any of the values defined by
		/// the \c HAlignmentConstants enumeration is valid. If the text range uses multiple alignments, the
		/// alignment will be reported as \c halUndefined.
		///
		/// \sa IRichTextRange::Text, ListNumberingHAlignment, IRichTextParagraphTab::Alignment,
		///     HAlignmentConstants
		[propget, id(DISPID_TP_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the paragraph's content. If the text range uses multiple alignments, the alignment will be reported as 'halUndefined'.")]
		HRESULT HAlignment([out, retval] HAlignmentConstants* pValue);
		[propput, id(DISPID_TP_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the paragraph's content. If the text range uses multiple alignments, the alignment will be reported as 'halUndefined'.")]
		HRESULT HAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Specifies whether automatic hyphenation is applied to the paragraphs in the text range</em>
		///
		/// Retrieves or sets whether automatic hyphenation is applied to the paragraphs in the text range. Any
		/// of the values defined by the \c BooleanPropertyValueConstants enumeration is valid. If set to
		/// \c bpvTrue, automatic hyphenation is enabled; if set to \c bpvFalse, it is disabled; and if set
		/// to \c bpvUndefined, some paragraphs in the text range use automatic hyphenation and others don't.
		///
		/// \sa IRichTextBox::HyphenationFunction, IRichTextBox::HyphenationWordWrapZoneWidth,
		///     BooleanPropertyValueConstants
		[propget, id(DISPID_TP_HYPHENATION), helpstring("Retrieves or sets whether automatic hyphenation is applied to the paragraphs in the text range.")]
		HRESULT Hyphenation([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TP_HYPHENATION), helpstring("Retrieves or sets whether automatic hyphenation is applied to the paragraphs in the text range.")]
		HRESULT Hyphenation([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies whether a page break is inserted before the paragraph</em>
		///
		/// Retrieves or sets whether the paragraph is forced to start on a new page by inserting a page break
		/// before the paragraph. Any of the values defined by the \c BooleanPropertyValueConstants enumeration
		/// is valid. If set to \c bpvTrue, the paragraph is forced to start on a new page; if set to
		/// \c bpvFalse, the paragraph does not need to start on a new page; and if set to \c bpvUndefined,
		/// some paragraphs in the text range are forced to start on a new page and others are not.
		///
		/// \sa KeepTogether, KeepWithNext, BooleanPropertyValueConstants
		[propget, id(DISPID_TP_INSERTPAGEBREAKBEFOREPARAGRAPH), helpstring("Retrieves or sets whether the paragraph is forced to start on a new page by inserting a page break before the paragraph.")]
		HRESULT InsertPageBreakBeforeParagraph([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TP_INSERTPAGEBREAKBEFOREPARAGRAPH), helpstring("Retrieves or sets whether the paragraph is forced to start on a new page by inserting a page break before the paragraph.")]
		HRESULT InsertPageBreakBeforeParagraph([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies whether page breaks are allowed within the paragraph</em>
		///
		/// Retrieves or sets whether page breaks are allowed within the paragraph. Any of the values defined
		/// by the \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvFalse, page breaks
		/// are allowed; if set to \c bpvTrue, they are forbidden; and if set to \c bpvUndefined, some
		/// paragraphs in the text range allow page breaks and others don't.
		///
		/// \sa KeepWithNext, InsertPageBreakBeforeParagraph, BooleanPropertyValueConstants
		[propget, id(DISPID_TP_KEEPTOGETHER), helpstring("Retrieves or sets whether page breaks are allowed within the paragraph.")]
		HRESULT KeepTogether([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TP_KEEPTOGETHER), helpstring("Retrieves or sets whether page breaks are allowed within the paragraph.")]
		HRESULT KeepTogether([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies whether page breaks are allowed between paragraphs in the text range</em>
		///
		/// Retrieves or sets whether page breaks are allowed between paragraphs in the text range. Any of the
		/// values defined by the \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvFalse,
		/// page breaks are allowed; if set to \c bpvTrue, they are forbidden; and if set to \c bpvUndefined,
		/// settings in the text range are mixed.
		///
		/// \sa KeepTogether, InsertPageBreakBeforeParagraph, BooleanPropertyValueConstants
		[propget, id(DISPID_TP_KEEPWITHNEXT), helpstring("Retrieves or sets whether page breaks are allowed between paragraphs in the text range.")]
		HRESULT KeepWithNext([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TP_KEEPWITHNEXT), helpstring("Retrieves or sets whether page breaks are allowed between paragraphs in the text range.")]
		HRESULT KeepWithNext([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Controls indentation of the paragraph's text</em>
		///
		/// Retrieves or sets the indent (in points) of each line in the paragraph, relative to the control's
		/// left margin.
		///
		/// \sa FirstLineIndent, RightIndent, IRichTextBox::LeftMargin
		[propget, id(DISPID_TP_LEFTINDENT), helpstring("Retrieves or sets the indent (in points) of each line in the paragraph, relative to the control's left margin.")]
		HRESULT LeftIndent([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TP_LEFTINDENT), helpstring("Retrieves or sets the indent (in points) of each line in the paragraph, relative to the control's left margin.")]
		HRESULT LeftIndent([in] FLOAT newValue);
		/// \brief <em>Controls the line spacing within the paragraph</em>
		///
		/// Retrieves or sets the value by which lines are spaced within the paragraph. The meaning of this
		/// value depends on the value of the \c LineSpacingRule property.
		///
		/// \sa LineSpacingRule, SpaceBefore, SpaceAfter
		[propget, id(DISPID_TP_LINESPACING), helpstring("Retrieves or sets the value by which lines are spaced within the paragraph. The meaning of this value depends on the value of the 'LineSpacingRule' property.")]
		HRESULT LineSpacing([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TP_LINESPACING), helpstring("Retrieves or sets the value by which lines are spaced within the paragraph. The meaning of this value depends on the value of the 'LineSpacingRule' property.")]
		HRESULT LineSpacing([in] FLOAT newValue);
		/// \brief <em>Controls the line spacing within the paragraph</em>
		///
		/// Retrieves or sets the rule by which lines are spaced within the paragraph. Any of the values
		/// defined by the \c LineSpacingRuleConstants enumeration is valid. If the text range uses multiple
		/// line spacing rules, the rule will be reported as \c lsrUndefined.
		///
		/// \sa LineSpacing, SpaceBefore, SpaceAfter, IRichTextBox::AdjustLineHeightForEastAsianLanguages,
		///     LineSpacingRuleConstants
		[propget, id(DISPID_TP_LINESPACINGRULE), helpstring("Retrieves or sets the rule by which lines are spaced within the paragraph. If the text range uses multiple line spacing rules, the rule will be reported as 'lsrUndefined'.")]
		HRESULT LineSpacingRule([out, retval] LineSpacingRuleConstants* pValue);
		[propput, id(DISPID_TP_LINESPACINGRULE), helpstring("Retrieves or sets the rule by which lines are spaced within the paragraph. If the text range uses multiple line spacing rules, the rule will be reported as 'lsrUndefined'.")]
		HRESULT LineSpacingRule([in] LineSpacingRuleConstants newValue);
		/// \brief <em>Specifies the list level index of the paragraph</em>
		///
		/// Retrieves or sets a zero-based index specifying the list level of the paragraph. If set to 0, the
		/// paragraph is not part of a list. If set to 1, the paragraph is part of the outermost list. If set
		/// to 2, the paragraph is part of the second-level (nested) list, which is nested under a level 1 list
		/// item. If set to 3, the paragraph is part of the third-level (nested) list, which is nested under a
		/// level 2 list item and so forth.
		///
		/// \sa ListNumberingStyle, ListNumberingStart, ListNumberingHAlignment, ListNumberingTabStop
		[propget, id(DISPID_TP_LISTLEVELINDEX), helpstring("Retrieves or sets a zero-based index specifying the list level of the paragraph. If set to 0, the paragraph is not part of a list.")]
		HRESULT ListLevelIndex([out, retval] LONG* pValue);
		[propput, id(DISPID_TP_LISTLEVELINDEX), helpstring("Retrieves or sets a zero-based index specifying the list level of the paragraph. If set to 0, the paragraph is not part of a list.")]
		HRESULT ListLevelIndex([in] LONG newValue);
		/// \brief <em>Controls the horizontal alignment of the paragraph's list numbering</em>
		///
		/// Retrieves or sets the horizontal alignment of the paragraph's list item numbers. Some of the values
		/// defined by the \c HAlignmentConstants enumeration is valid. If the text range uses multiple
		/// alignments, the alignment will be reported as \c halUndefined.
		///
		/// \remarks Some alignment options require a left indent.
		///
		/// \sa LeftIndent, ListNumberingTabStop, ListLevelIndex, ListNumberingStyle, HAlignment,
		///     HAlignmentConstants
		[propget, id(DISPID_TP_LISTNUMBERINGHALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the paragraph's list item numbers. If the text range uses multiple alignments, the alignment will be reported as 'halUndefined'. Some alignment options require a left indent.")]
		HRESULT ListNumberingHAlignment([out, retval] HAlignmentConstants* pValue);
		[propput, id(DISPID_TP_LISTNUMBERINGHALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the paragraph's list item numbers. If the text range uses multiple alignments, the alignment will be reported as 'halUndefined'. Some alignment options require a left indent.")]
		HRESULT ListNumberingHAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Specifies the number at which list item numbering starts in this paragraph</em>
		///
		/// Retrieves or sets the number of the first list item in the current list. If the
		/// \c ListNumberingStyle property is set to \c lnsCustomSequence, this property specifies the unicode
		/// code point that is used as the first numbering sign.
		///
		/// \sa ListNumberingStyle, ListLevelIndex, ListNumberingHAlignment
		[propget, id(DISPID_TP_LISTNUMBERINGSTART), helpstring("Retrieves or sets the number of the first list item in the current list.")]
		HRESULT ListNumberingStart([out, retval] LONG* pValue);
		[propput, id(DISPID_TP_LISTNUMBERINGSTART), helpstring("Retrieves or sets the number of the first list item in the current list.")]
		HRESULT ListNumberingStart([in] LONG newValue);
		/// \brief <em>Specifies the list numbering type for the paragraph</em>
		///
		/// Retrieves or sets the kind of numbering of list items in the paragraph. Any of the values
		/// defined by the \c ListNumberingStyleConstants enumeration is valid. If the text range uses multiple
		/// list numbering styles, the style will be reported as \c lnsUndefined.
		///
		/// \sa ListLevelIndex, ListNumberingStart, ListNumberingHAlignment, ListNumberingStyleConstants
		[propget, id(DISPID_TP_LISTNUMBERINGSTYLE), helpstring("Retrieves or sets the kind of numbering of list items in the paragraph. Any of the values defined by the 'ListNumberingStyleConstants' enumeration is valid.")]
		HRESULT ListNumberingStyle([out, retval] ListNumberingStyleConstants* pValue);
		[propput, id(DISPID_TP_LISTNUMBERINGSTYLE), helpstring("Retrieves or sets the kind of numbering of list items in the paragraph. Any of the values defined by the 'ListNumberingStyleConstants' enumeration is valid.")]
		HRESULT ListNumberingStyle([in] ListNumberingStyleConstants newValue);
		/// \brief <em>Controls the space between list item number and list item text</em>
		///
		/// Retrieves or sets the distance (in pixels) between the right first list item's number and the first
		/// list item's text.
		///
		/// \sa ListNumberingHAlignment, ListLevelIndex, ListNumberingStyle
		[propget, id(DISPID_TP_LISTNUMBERINGTABSTOP), helpstring("Retrieves or sets the distance (in pixels) between the right first list item's number and the first list item's text.")]
		HRESULT ListNumberingTabStop([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TP_LISTNUMBERINGTABSTOP), helpstring("Retrieves or sets the distance (in pixels) between the right first list item's number and the first list item's text.")]
		HRESULT ListNumberingTabStop([in] FLOAT newValue);
		/// \brief <em>Specifies whether the paragraphs in the text range are numbered</em>
		///
		/// Retrieves or sets whether the paragraphs in the text range are numbered and the number is displayed
		/// in the first line of each paragraph. Any of the values defined by the
		/// \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the paragraphs are
		/// numbered; if set to \c bpvFalse, they are not numbered; and if set to \c bpvUndefined, some
		/// paragraphs in the text range are numbered and others are not.
		///
		/// \sa BooleanPropertyValueConstants
		[propget, id(DISPID_TP_NUMBERED), helpstring("Retrieves or sets whether the paragraphs in the text range are numbered and the number is displayed in the first line of each paragraph.")]
		HRESULT Numbered([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TP_NUMBERED), helpstring("Retrieves or sets whether the paragraphs in the text range are numbered and the number is displayed in the first line of each paragraph.")]
		HRESULT Numbered([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies whether widows and orphans are prevented in the paragraph</em>
		///
		/// Retrieves or sets whether the control prevents widows and orphans within the paragraph. A widow is
		/// created when the last line of a paragraph is printed by itself at the top of a page. An orphan is
		/// when the first line of a paragraph is printed by itself at the bottom of a page.\n
		/// Any of the values defined by the \c BooleanPropertyValueConstants enumeration is valid. If set to
		/// \c bpvTrue, widows and orphans are prevented; if set to \c bpvFalse, they are allowed; and if set
		/// to \c bpvUndefined, some paragraphs in the text range prevent widows and orphans and others don't.
		///
		/// \sa BooleanPropertyValueConstants
		[propget, id(DISPID_TP_PREVENTWIDOWSANDORPHANS), helpstring("Retrieves or sets whether the control prevents widows and orphans within the paragraph.")]
		HRESULT PreventWidowsAndOrphans([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TP_PREVENTWIDOWSANDORPHANS), helpstring("Retrieves or sets whether the control prevents widows and orphans within the paragraph.")]
		HRESULT PreventWidowsAndOrphans([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Controls indentation of the paragraph's text</em>
		///
		/// Retrieves or sets the indent (in points) of each line in the paragraph, relative to the control's
		/// right margin.
		///
		/// \sa LeftIndent, FirstLineIndent, IRichTextBox::RightMargin
		[propget, id(DISPID_TP_RIGHTINDENT), helpstring("Retrieves or sets the indent (in points) of each line in the paragraph, relative to the control's right margin.")]
		HRESULT RightIndent([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TP_RIGHTINDENT), helpstring("Retrieves or sets the indent (in points) of each line in the paragraph, relative to the control's right margin.")]
		HRESULT RightIndent([in] FLOAT newValue);
		/// \brief <em>Controls the paragraph's behavior in bidirectional documents</em>
		///
		/// Retrieves or sets whether the paragraph uses right-to-left layout.\n
		/// Any of the values defined by the \c BooleanPropertyValueConstants enumeration is valid. If set to
		/// \c bpvTrue, the paragraph's content uses right-to-left layout; if set to \c bpvFalse, it uses
		/// left-to-right layout; and if set to \c bpvUndefined, some parts in the text range use right-to-left
		/// layout and others use left-to-right layout.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.
		///
		/// \sa IRichTextBox::RightToLeft, IRichTextBox::RightToLeftMathZones, BooleanPropertyValueConstants
		[propget, id(DISPID_TP_RIGHTTOLEFT), helpstring("Retrieves or sets whether the paragraph uses right-to-left layout. Requires Rich Edit 7.5 or newer.")]
		HRESULT RightToLeft([out, retval] BooleanPropertyValueConstants* pValue);
		[propput, id(DISPID_TP_RIGHTTOLEFT), helpstring("Retrieves or sets whether the paragraph uses right-to-left layout. Requires Rich Edit 7.5 or newer.")]
		HRESULT RightToLeft([in] BooleanPropertyValueConstants newValue);
		/// \brief <em>Specifies the amount of vertical space below the paragraph</em>
		///
		/// Retrieves or sets the amount of vertical space below the paragraph. If the text range uses
		/// multiple spacings, the vertical space will be reported as -9999999.
		///
		/// \sa SpaceBefore, LineSpacing, IRichTextBox::AdjustLineHeightForEastAsianLanguages
		[propget, id(DISPID_TP_SPACEAFTER), helpstring("Retrieves or sets the amount of vertical space below the paragraph. If the text range uses multiple spacings, the vertical space will be reported as -9999999.")]
		HRESULT SpaceAfter([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TP_SPACEAFTER), helpstring("Retrieves or sets the amount of vertical space below the paragraph. If the text range uses multiple spacings, the vertical space will be reported as -9999999.")]
		HRESULT SpaceAfter([in] FLOAT newValue);
		/// \brief <em>Specifies the amount of vertical space above the paragraph</em>
		///
		/// Retrieves or sets the amount of vertical space above the paragraph. If the text range uses
		/// multiple spacings, the vertical space will be reported as -9999999.
		///
		/// \sa SpaceAfter, LineSpacing, IRichTextBox::AdjustLineHeightForEastAsianLanguages
		[propget, id(DISPID_TP_SPACEBEFORE), helpstring("Retrieves or sets the amount of vertical space above the paragraph. If the text range uses multiple spacings, the vertical space will be reported as -9999999.")]
		HRESULT SpaceBefore([out, retval] FLOAT* pValue);
		[propput, id(DISPID_TP_SPACEBEFORE), helpstring("Retrieves or sets the amount of vertical space above the paragraph. If the text range uses multiple spacings, the vertical space will be reported as -9999999.")]
		HRESULT SpaceBefore([in] FLOAT newValue);
		/// \brief <em>Specifies the style assigned to the paragraph</em>
		///
		/// Retrieves or sets the unique ID of the style assigned to the paragraph. If the text range uses
		/// multiple paragraph styles, the style will be reported as -9999999.\n
		/// This property can also be set to one of the built-in styles defined by the \c BuiltInStyleConstants
		/// enumeration.
		///
		/// \sa BuiltInStyleConstants
		[propget, id(DISPID_TP_STYLEID), helpstring("Retrieves or sets the unique ID of the style assigned to the paragraph. If the text range uses multiple paragraph styles, the style will be reported as -9999999.")]
		HRESULT StyleID([out, retval] LONG* pValue);
		[propput, id(DISPID_TP_STYLEID), helpstring("Retrieves or sets the unique ID of the style assigned to the paragraph. If the text range uses multiple paragraph styles, the style will be reported as -9999999.")]
		HRESULT StyleID([in] LONG newValue);
		/// \brief <em>Retrieves the paragraph's tabs</em>
		///
		/// Retrieves a collection object wrapping the paragraph's tabs.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTextParagraphTabs
		[propget, id(DISPID_TP_TABS), helpstring("Retrieves a collection object wrapping the paragraph's tabs."), nonbrowsable]
		HRESULT Tabs([out, retval] IRichTextParagraphTabs** ppTabs);

		/// \brief <em>Creates a new \c IRichTextParagraph instance with identical properties</em>
		///
		/// \return The new \c IRichTextParagraph instance.
		///
		/// \sa CopySettings, Equals
		[id(DISPID_TP_CLONE), helpstring("Creates a new 'TextParagraph' instance with identical properties.")]
		HRESULT Clone([out, retval] IRichTextParagraph** ppClone);
		/// \brief <em>Copies all settings from an other \c IRichTextParagraph instance</em>
		///
		/// \param[in] sourceObject The \c IRichTextParagraph instance to copy from.
		///
		/// \sa Clone, Equals
		[id(DISPID_TP_COPYSETTINGS), helpstring("Copies all settings from an other 'TextParagraph' instance.")]
		HRESULT CopySettings([in] IRichTextParagraph* sourceObject);
		/// \brief <em>Retrieves whether two \c IRichTextParagraph instances have the same properties</em>
		///
		/// \param[in] compareAgainst The \c IRichTextParagraph instance to compare with.
		///
		/// \return \c True, if the objects have the same properties; otherwise \c False.
		///
		/// \remarks Properties that are set to 'undefined' are ignored.
		///
		/// \sa Clone, CopySettings
		[id(DISPID_TP_EQUALS), helpstring("Retrieves whether two 'TextParagraph' instances have the same properties.")]
		HRESULT Equals([in] IRichTextParagraph* compareAgainst, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Resets the text range's paragraph formatting</em>
		///
		/// Resets the text range's paragraph formatting, applying the specified rules.
		///
		/// \param[in] rules The rules to apply. Some of the values defined by the \c ResetRulesConstants
		///            enumeration is valid.
		///
		/// \sa ResetRulesConstants
		[id(DISPID_TP_RESET), helpstring("Resets the text range's paragraph formatting, applying the specified rules.")]
		HRESULT Reset([in] ResetRulesConstants rules);
	}


	/// \interface _IRichTextParagraphEvents
	/// \brief <em>The \c TextParagraph class' events interface</em>
	///
	/// This interface defines all events the \c TextParagraph class may raise.
	///
	/// \sa IRichTextParagraph
	[
		uuid(76CC705B-716F-4F2F-8099-F8472A13568C),
		helpstring("IRichTextParagraph-event-interface")
	]
	dispinterface _IRichTextParagraphEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TextParagraph class</em>
	///
	/// This COM class implements the \c IRichTextParagraph and \c _IRichTextParagraphEvents interfaces.
	///
	/// \sa IRichTextParagraph, _IRichTextParagraphEvents, RichTextBox
	[
		uuid(612F7074-4E80-4C5E-836D-2A37C932BE9D),
		version(1.0),
		noncreatable,
		helpstring("TextParagraph Class 1.0 (ANSI)")
	]
	coclass TextParagraph
	{
		[default] interface IRichTextParagraph;
		[default, source] dispinterface _IRichTextParagraphEvents;
	};


	/// \interface IRichTableCell
	/// \brief <em>Wraps a table cell's styling, e.g. margins</em>
	///
	/// This interface is a wrapper around the styling of a table cell.
	///
	/// \sa _IRichTableCellEvents, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(54EB14CF-8687-49B9-BB7C-500EB8F4EE47),
		dual,
		nonextensible,
		helpstring("IRichTableCell interface"),
		pointer_default(unique)
	]
	interface IRichTableCell : IDispatch
	{
		/// \brief <em>Controls the table cell's background color</em>
		///
		/// Retrieves or sets the table cell's first background color. The actual background color is
		/// calculated from \c BackColor1 and \c BackColor2, with \c BackColorShading controlling the
		/// mixture.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.\n
		///          If this property is set for a cell, it also applies to all cells in the same row that
		///          follow this cell.
		///
		/// \sa BackColor2, BackColorShading, BorderColor
		[propget, id(DISPID_TBLC_BACKCOLOR1), helpstring("Retrieves or sets the table cell's first background color. The actual background color is calculated from 'BackColor1' and 'BackColor2', with 'BackColorShading' controlling the mixture. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT BackColor1([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TBLC_BACKCOLOR1), helpstring("Retrieves or sets the table cell's first background color. The actual background color is calculated from 'BackColor1' and 'BackColor2', with 'BackColorShading' controlling the mixture. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT BackColor1([in] OLE_COLOR newValue);
		/// \brief <em>Controls the table cell's background color</em>
		///
		/// Retrieves or sets the table cell's second background color. The actual background color is
		/// calculated from \c BackColor1 and \c BackColor2, with \c BackColorShading controlling the
		/// mixture.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.\n
		///          If this property is set for a cell, it also applies to all cells in the same row that
		///          follow this cell.
		///
		/// \sa BackColor1, BackColorShading, BorderColor
		[propget, id(DISPID_TBLC_BACKCOLOR2), helpstring("Retrieves or sets the table cell's second background color. The actual background color is calculated from 'BackColor1' and 'BackColor2', with 'BackColorShading' controlling the mixture. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT BackColor2([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TBLC_BACKCOLOR2), helpstring("Retrieves or sets the table cell's second background color. The actual background color is calculated from 'BackColor1' and 'BackColor2', with 'BackColorShading' controlling the mixture. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT BackColor2([in] OLE_COLOR newValue);
		/// \brief <em>Controls the table cell's background color</em>
		///
		/// Retrieves or sets the proportion by which both background colors are mixed to create the table
		/// cell's actual background color. \c BackColorShading can be a value between 0 and 10000. If set to
		/// 0, the actual background color will be the same as \c BackColor1. If set to 10000, the actual
		/// background color will be the same as \c BackColor2. Any value inbetween leads to a mixture of both
		/// colors.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.\n
		///          If this property is set for a cell, it also applies to all cells in the same row that
		///          follow this cell.
		///
		/// \sa BackColor1, BackColor2, BorderColor
		[propget, id(DISPID_TBLC_BACKCOLORSHADING), helpstring("Retrieves or sets the proportion by which both background colors are mixed to create the table cell's actual background color. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT BackColorShading([out, retval] LONG* pValue);
		[propput, id(DISPID_TBLC_BACKCOLORSHADING), helpstring("Retrieves or sets the proportion by which both background colors are mixed to create the table cell's actual background color. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT BackColorShading([in] LONG newValue);
		/// \brief <em>Controls the style of the table cell's borders</em>
		///
		/// Retrieves or sets the color of a cell border.
		///
		/// \param[in] border The border for which to retrieve or set the border color. Any of the values
		///            defined by the \c CellBorderConstants enumeration is valid.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa BorderSize, BackColor1, BackColor2, BackColorShading, CellBorderConstants
		[propget, id(DISPID_TBLC_BORDERCOLOR), helpstring("Retrieves or sets the color of a cell border. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT BorderColor([in] CellBorderConstants border, [out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_TBLC_BORDERCOLOR), helpstring("Retrieves or sets the color of a cell border. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT BorderColor([in] CellBorderConstants border, [in] OLE_COLOR newValue);
		/// \brief <em>Controls the style of the table cell's borders</em>
		///
		/// Retrieves or sets the width (in twips) of a cell border. If set to -1, the width of 1 pixel will be
		/// used.
		///
		/// \param[in] border The border for which to retrieve or set the border size. Any of the values
		///            defined by the \c CellBorderConstants enumeration is valid.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa BorderColor, CellMergeFlags, CellBorderConstants
		[propget, id(DISPID_TBLC_BORDERSIZE), helpstring("Retrieves or sets the width (in twips) of a cell border. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT BorderSize([in] CellBorderConstants border, [out, retval] SHORT* pValue);
		[propput, id(DISPID_TBLC_BORDERSIZE), helpstring("Retrieves or sets the width (in twips) of a cell border. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT BorderSize([in] CellBorderConstants border, [in] SHORT newValue);
		/// \brief <em>Controls table cell merging</em>
		///
		/// Retrieves or sets whether the table cell is merged with one or more surrounding cell. Any
		/// combination of the values defined by the \c CellMergeConstants enumeration is valid.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa BorderSize, CellMergeConstants
		[propget, id(DISPID_TBLC_CELLMERGEFLAGS), helpstring("Retrieves or sets whether the table cell is merged with one or more surrounding cell. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT CellMergeFlags([out, retval] CellMergeConstants* pValue);
		[propput, id(DISPID_TBLC_CELLMERGEFLAGS), helpstring("Retrieves or sets whether the table cell is merged with one or more surrounding cell. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT CellMergeFlags([in] CellMergeConstants newValue);
		/// \brief <em>Specifies whether this cell is the master cell that inherits its style to subsequent cells</em>
		///
		/// Retrieves whether subsequent table cells inherit their style from this cell. If set to \c True,
		/// this cell inherits its style to subsequent cells; otherwise not.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.\n
		///          This property is read-only.
		///
		/// \sa IRichTableRow::MasterCell
		[propget, id(DISPID_TBLC_DEFINESSTYLEFORSUBSEQUENTCELLS), helpstring("Retrieves whether subsequent table cells inherit their style from this cell. Requires Rich Edit 7.5 or newer. This property is read-only."), nonbrowsable]
		HRESULT DefinesStyleForSubsequentCells([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves the table cell's zero-based index</em>
		///
		/// Retrieves the zero-based index identifying this table cell.
		///
		/// \remarks This property is read-only.
		///
		/// \sa CellIdentifierTypeConstants
		[propget, id(DISPID_TBLC_INDEX), helpstring("Retrieves the zero-based index identifying this table cell. This property is read-only."), nonbrowsable]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the table cell's parent \c TableRow object</em>
		///
		/// Retrieves a \c TableRow object that wraps the table row that the table cell refers to.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTableRow
		[propget, id(DISPID_TBLC_PARENTROW), helpstring("Retrieves a 'TableRow' object that wraps the table row that the table cell refers to. This property is read-only."), nonbrowsable]
		HRESULT ParentRow([out, retval] IRichTableRow** ppRow);
		/// \brief <em>Retrieves the table cell's parent \c Table object</em>
		///
		/// Retrieves a \c Table object that wraps the table that the table cell refers to.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTable
		[propget, id(DISPID_TBLC_PARENTTABLE), helpstring("Retrieves a 'Table' object that wraps the table that the table cell refers to. This property is read-only."), nonbrowsable]
		HRESULT ParentTable([out, retval] IRichTable** ppTable);
		/// \brief <em>Specifies the text flow direction in the table cell</em>
		///
		/// Retrieves or sets how the text flows within the table cell. Some of the values defined by the
		/// \c TextFlowConstants enumeration is valid.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa IRichTextBox::TextFlow, TextFlowConstants
		[propget, id(DISPID_TBLC_TEXTFLOW), helpstring("Retrieves or sets how the text flows within the table cell. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT TextFlow([out, retval] TextFlowConstants* pValue);
		[propput, id(DISPID_TBLC_TEXTFLOW), helpstring("Retrieves or sets how the text flows within the table cell. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT TextFlow([in] TextFlowConstants newValue);
		/// \brief <em>Retrieves a \c TextRange object for the table cell</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTextRange
		[propget, id(DISPID_TBLC_TEXTRANGE), helpstring("Retrieves a 'TextRange' object for the table cell. This property is read-only."), nonbrowsable]
		HRESULT TextRange([out, retval] IRichTextRange** ppTextRange);
		/// \brief <em>Controls the vertical alignment of the table cell's content</em>
		///
		/// Retrieves or sets the vertical alignment of the table cell's content within the cell.
		/// Any of the values defined by the \c VAlignmentConstants enumeration is valid.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa IRichTableRow::Height, VAlignmentConstants
		[propget, id(DISPID_TBLC_VALIGNMENT), helpstring("Retrieves or sets the vertical alignment of the table cell's content within the cell. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT VAlignment([out, retval] VAlignmentConstants* pValue);
		[propput, id(DISPID_TBLC_VALIGNMENT), helpstring("Retrieves or sets the vertical alignment of the table cell's content within the cell. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT VAlignment([in] VAlignmentConstants newValue);
		/// \brief <em>Controls the table cell's width</em>
		///
		/// Retrieves or sets the table cell's width (in twips).
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa IRichTableRow::Height
		[propget, id(DISPID_TBLC_WIDTH), helpstring("Retrieves or sets the table cell's width (in twips). Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT Width([out, retval] LONG* pValue);
		[propput, id(DISPID_TBLC_WIDTH), helpstring("Retrieves or sets the table cell's width (in twips). Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT Width([in] LONG newValue);
	}


	/// \interface _IRichTableCellEvents
	/// \brief <em>The \c TableCell class' events interface</em>
	///
	/// This interface defines all events the \c TableCell class may raise.
	///
	/// \sa IRichTableCell
	[
		uuid(A74DC6A4-2CC9-43FA-B293-F0C3239ED140),
		helpstring("IRichTableCell-event-interface")
	]
	dispinterface _IRichTableCellEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TableCell class</em>
	///
	/// This COM class implements the \c IRichTableCell and \c _IRichTableCellEvents interfaces.
	///
	/// \sa IRichTableCell, _IRichTableCellEvents, RichTextBox
	[
		uuid(FF05A617-CF33-494F-9447-752264853177),
		version(1.0),
		noncreatable,
		helpstring("TableCell Class 1.0 (ANSI)")
	]
	coclass TableCell
	{
		[default] interface IRichTableCell;
		[default, source] dispinterface _IRichTableCellEvents;
	};


	/// \interface IRichTableCells
	/// \brief <em>Manages a collection of \c TableCell objects</em>
	///
	/// This interface provides easy access to collections of \c TableCell objects.
	/// A \c TableCells object is used to group table cells that have certain properties in common.
	///
	/// \sa _IRichTableCellsEvents, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(BCB272B3-02BE-447A-B712-8836347D2C54),
		dual,
		nonextensible,
		helpstring("IRichTableCells interface"),
		pointer_default(unique)
	]
	interface IRichTableCells : IDispatch
	{
		/// \brief <em>Retrieves a \c TableCell object from the collection</em>
		///
		/// Retrieves a \c TableCell object from the collection that wraps the table cell identified by
		/// \c cellIdentifier.
		///
		/// \param[in] cellIdentifier A value that identifies the table cell to be retrieved.
		/// \param[in] cellIdentifierType A value specifying the meaning of \c cellIdentifier. Any of the
		///            values defined by the \c CellIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks This is the default property of the \c IRichTableCells interface.\n
		///          This property is read-only.
		///
		/// \sa IRichTableCell, CellIdentifierTypeConstants, Add, Remove, Contains
		[propget, id(DISPID_TBLCS_ITEM), helpstring("Retrieves a 'TableCell' object from the collection that wraps the table cell identified by 'cellIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG cellIdentifier, [in, defaultvalue(citIndex)] CellIdentifierTypeConstants cellIdentifierType, [out, retval] IRichTableCell** ppCell);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c TableCell objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_TBLCS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);
		/// \brief <em>Retrieves the collection's parent \c TableRow object</em>
		///
		/// Retrieves a \c TableRow object that wraps the table row that the collection refers to.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTableRow
		[propget, id(DISPID_TBLCS_PARENTROW), helpstring("Retrieves a 'TableRow' object that wraps the table row that the collection refers to. This property is read-only."), nonbrowsable]
		HRESULT ParentRow([out, retval] IRichTableRow** ppRow);
		/// \brief <em>Retrieves the collection's parent \c Table object</em>
		///
		/// Retrieves a \c Table object that wraps the table that the collection refers to.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTable
		[propget, id(DISPID_TBLCS_PARENTTABLE), helpstring("Retrieves a 'Table' object that wraps the table that the collection refers to. This property is read-only."), nonbrowsable]
		HRESULT ParentTable([out, retval] IRichTable** ppTable);

		/// \brief <em>Adds a cell to the table row</em>
		///
		/// Adds a cell with the specified properties at the specified position in the table row and returns
		/// a \c TableCell object wrapping the inserted cell.
		///
		/// \param[in] width The width (in twips) of the new cell.
		/// \param[in] insertAt The zero-based index at which to insert the new cell. If set to -1, the cell is
		///            inserted after the last cell in the row.
		/// \param[in] borderSize The width (in twips) of the cell borders. If set to -1, the width of 1 pixel
		///            will be used.
		/// \param[in] verticalAlignment The vertical alignment of the cell's content within the table
		///            cell. Any of the values defined by the \c VAlignmentConstants enumeration is valid.
		///
		/// \return The inserted cell.
		///
		/// \sa Count, Remove, RemoveAll, IRichTableCell::Width, IRichTableCell::Index,
		///     IRichTableCell::BorderSize, IRichTableCell::VAlignment, VAlignmentConstants
		[id(DISPID_TBLCS_ADD), helpstring("Adds a new table cell with the specified properties.")]
		HRESULT Add([in] LONG Width, [in, defaultvalue(-1)] LONG insertAt, [in, defaultvalue(-1)] SHORT borderSize, [in, defaultvalue(valCenter)] VAlignmentConstants verticalAlignment, [out, retval] IRichTableCell** ppAddedCell);
		/// \brief <em>Retrieves whether the specified table cell is part of the table cell collection</em>
		///
		/// \param[in] cellIdentifier A value that identifies the table cell to be checked.
		/// \param[in] cellIdentifierType A value specifying the meaning of \c cellIdentifier. Any of the
		///            values defined by the \c CellIdentifierTypeConstants enumeration is valid.
		///
		/// \return \c True, if the specified table cell is part of the collection; otherwise \c False.
		///
		/// \sa Add, Remove, CellIdentifierTypeConstants
		[id(DISPID_TBLCS_CONTAINS), helpstring("Retrieves whether the specified table cell is part of the table cell collection.")]
		HRESULT Contains([in] LONG cellIdentifier, [in, defaultvalue(citIndex)] CellIdentifierTypeConstants cellIdentifierType, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the table cells in the collection</em>
		///
		/// Retrieves the number of \c TableCell objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_TBLCS_COUNT), helpstring("Retrieves the number of 'TableCell' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the specified cell in the collection from the table row</em>
		///
		/// \param[in] cellIdentifier A value that identifies the table cell to be removed.
		/// \param[in] cellIdentifierType A value specifying the meaning of \c cellIdentifier. Any of the
		///            values defined by the \c CellIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.
		///
		/// \sa Add, Count, RemoveAll, Contains, CellIdentifierTypeConstants
		[id(DISPID_TBLCS_REMOVE), helpstring("Removes the specified cell in the collection from the table row. Requires Rich Edit 7.5 or newer.")]
		HRESULT Remove([in] LONG cellIdentifier, [in, defaultvalue(citIndex)] CellIdentifierTypeConstants cellIdentifierType);
		/// \brief <em>Removes all cells in the collection from the table row</em>
		///
		/// \sa Add, Count, Remove
		[id(DISPID_TBLCS_REMOVEALL), helpstring("Removes all cells in the collection from the table row.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IRichTableCellsEvents
	/// \brief <em>The \c TableCells class' events interface</em>
	///
	/// This interface defines all events the \c TableCells class may raise.
	///
	/// \sa IRichTableCells
	[
		uuid(1B14F3FE-7276-47BF-8EF4-33A3B6DDF4F0),
		helpstring("IRichTableCells-event-interface")
	]
	dispinterface _IRichTableCellsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TableCells class</em>
	///
	/// This COM class implements the \c IRichTableCells and \c _IRichTableCellsEvents interfaces.
	///
	/// \sa IRichTableCells, _IRichTableCellsEvents, RichTextBox
	[
		uuid(BA75C1AD-1D60-470A-BCCC-0F23F4395D6A),
		version(1.0),
		noncreatable,
		helpstring("TableCells Class 1.0 (ANSI)")
	]
	coclass TableCells
	{
		[default] interface IRichTableCells;
		[default, source] dispinterface _IRichTableCellsEvents;
	};


	/// \interface IRichTableRow
	/// \brief <em>Wraps a table row's styling, e.g. margins</em>
	///
	/// This interface is a wrapper around the styling of a table row.
	///
	/// \sa _IRichTableRowEvents, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(9F46563B-A322-4D37-ACAE-81183CAC428B),
		dual,
		nonextensible,
		helpstring("IRichTableRow interface"),
		pointer_default(unique)
	]
	interface IRichTableRow : IDispatch
	{
		/// \brief <em>Specifies whether page breaks are allowed within the row</em>
		///
		/// Retrieves or sets whether a page break is allowed within the table row. If set to \c True, page
		/// breaks are allowed; otherwise not.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa KeepTogetherWithNextRow
		[propget, id(DISPID_TBLR_ALLOWPAGEBREAKWITHINROW), helpstring("Retrieves or sets whether a page break is allowed within the table row. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT AllowPageBreakWithinRow([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBLR_ALLOWPAGEBREAKWITHINROW), helpstring("Retrieves or sets whether a page break is allowed within the table row. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT AllowPageBreakWithinRow([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves whether the table row can be changed</em>
		///
		/// Retrieves whether the table row can be changed. Any of the values defined by the
		/// \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the row can be
		/// changed; if set to \c bpvFalse, it cannot be changed; and if set to \c bpvUndefined, parts of the
		/// row can be changed and others can't.
		/// The row cannot be changed, if the document is read-only or any part of the row is protected.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.\n
		///          This property is read-only.
		///
		/// \sa BooleanPropertyValueConstants
		[propget, id(DISPID_TBLR_CANCHANGE), helpstring("Retrieves whether the table row can be changed. Requires Rich Edit 7.5 or newer. This property is read-only."), nonbrowsable]
		HRESULT CanChange([out, retval] BooleanPropertyValueConstants* pValue);
		/// \brief <em>Retrieves the table row's cells</em>
		///
		/// Retrieves a collection object wrapping the table row's cells.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTableCells
		[propget, id(DISPID_TBLR_CELLS), helpstring("Retrieves a collection object wrapping the table row's cells."), nonbrowsable]
		HRESULT Cells([out, retval] IRichTableCells** ppCells);
		/// \brief <em>Controls the horizontal alignment of the table row</em>
		///
		/// Retrieves or sets the horizontal alignment of the table row. The following of the values defined by
		/// the \c HAlignmentConstants enumeration are valid: \c halLeft, \c halCenter, \c halRight.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa Indent, IRichTableCell::Width, HAlignmentConstants
		[propget, id(DISPID_TBLR_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the table row. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT HAlignment([out, retval] HAlignmentConstants* pValue);
		[propput, id(DISPID_TBLR_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the table row. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT HAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Controls the table row's height</em>
		///
		/// Retrieves or sets the table row's height (in twips).
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa IRichTableCell::Width, IRichTableCell::VAlignment
		[propget, id(DISPID_TBLR_HEIGHT), helpstring("Retrieves or sets the table row's height (in twips). Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT Height([out, retval] LONG* pValue);
		[propput, id(DISPID_TBLR_HEIGHT), helpstring("Retrieves or sets the table row's height (in twips). Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT Height([in] LONG newValue);
		/// \brief <em>Controls the table row's indent</em>
		///
		/// Retrieves or sets the size (in twips) of the left and right margin in each table cell.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa IRichTextParagraph::LeftIndent
		[propget, id(DISPID_TBLR_HORIZONTALCELLMARGIN), helpstring("Retrieves or sets the size (in twips) of the left and right margin in each table cell. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT HorizontalCellMargin([out, retval] LONG* pValue);
		[propput, id(DISPID_TBLR_HORIZONTALCELLMARGIN), helpstring("Retrieves or sets the size (in twips) of the left and right margin in each table cell. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT HorizontalCellMargin([in] LONG newValue);
		/// \brief <em>Controls the table row's indent</em>
		///
		/// Retrieves or sets the size (in twips) by which the table row is indented horizontally. The
		/// indent is measured from the control's left border.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa HAlignment
		[propget, id(DISPID_TBLR_INDENT), helpstring("Retrieves or sets the size (in twips) by which the table row is indented horizontally. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT Indent([out, retval] LONG* pValue);
		[propput, id(DISPID_TBLR_INDENT), helpstring("Retrieves or sets the size (in twips) by which the table row is indented horizontally. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT Indent([in] LONG newValue);
		/// \brief <em>Retrieves the table row's zero-based index</em>
		///
		/// Retrieves the zero-based index identifying this table row.
		///
		/// \remarks This property is read-only.
		///
		/// \sa RowIdentifierTypeConstants
		[propget, id(DISPID_TBLR_INDEX), helpstring("Retrieves the zero-based index identifying this table row. This property is read-only."), nonbrowsable]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Specifies whether page breaks are allowed between this row and the next row</em>
		///
		/// Retrieves or sets whether the table row is kept on the same page as the following row. If set to
		/// \c True, the rows are kept together; otherwise a page break is allowed in between.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa AllowPageBreakWithinRow
		[propget, id(DISPID_TBLR_KEEPTOGETHERWITHNEXTROW), helpstring("Retrieves or sets whether the table row is kept on the same page as the following row. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT KeepTogetherWithNextRow([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBLR_KEEPTOGETHERWITHNEXTROW), helpstring("Retrieves or sets whether the table row is kept on the same page as the following row. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT KeepTogetherWithNextRow([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the cell that all subsequent cells in the same row inherit their style from</em>
		///
		/// Retrieves or sets the cell that all subsequent cells in the same row inherit their style from. If
		/// set to \c Nothing, no cell in the row inherits its style from another cell.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.
		///
		/// \attention This property cannot be set, because as of June 2015 all Rich Edit versions seem to ignore it.
		///
		/// \sa IRichTableCell::DefinesStyleForSubsequentCells
		[propget, id(DISPID_TBLR_MASTERCELL), helpstring("Retrieves or sets the cell that all subsequent cells in the same row inherit their style from. Requires Rich Edit 7.5 or newer.")]
		HRESULT MasterCell([out, retval] IRichTableCell** ppMasterCell);
		//[propputref, id(DISPID_TBLR_MASTERCELL), helpstring("Retrieves or sets the cell that all subsequent cells in the same row inherit their style from. Requires Rich Edit 7.5 or newer.")]
		//HRESULT MasterCell([in] IRichTableCell* pNewMasterCell);
		/// \brief <em>Retrieves the table row's parent \c Table object</em>
		///
		/// Retrieves a \c Table object that wraps the table that the table row refers to.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTable
		[propget, id(DISPID_TBLR_PARENTTABLE), helpstring("Retrieves a 'Table' object that wraps the table that the table row refers to. This property is read-only."), nonbrowsable]
		HRESULT ParentTable([out, retval] IRichTable** ppTable);
		/// \brief <em>Controls the table row's behavior in bidirectional documents</em>
		///
		/// Retrieves or sets whether the cells in the table row have right-to-left precedence. If set to
		/// \c True, the row's cells are prepared for right-to-left text, otherwise for left-to-right text.
		///
		/// \remarks Changing this property requires Rich Edit 7.5 or newer.
		///
		/// \sa TextRange, IRichTextParagraph::RightToLeft
		[propget, id(DISPID_TBLR_RIGHTTOLEFT), helpstring("Retrieves or sets whether the cells in the table row have right-to-left precedence. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT RightToLeft([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_TBLR_RIGHTTOLEFT), helpstring("Retrieves or sets whether the cells in the table row have right-to-left precedence. Changing this property requires Rich Edit 7.5 or newer.")]
		HRESULT RightToLeft([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves a \c TextRange object for the table row</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTextRange
		[propget, id(DISPID_TBLR_TEXTRANGE), helpstring("Retrieves a 'TextRange' object for the table row. This property is read-only."), nonbrowsable]
		HRESULT TextRange([out, retval] IRichTextRange** ppTextRange);

		/// \brief <em>Retrieves whether two \c IRichTableRow instances have the same properties</em>
		///
		/// \param[in] compareAgainst The \c IRichTableRow instance to compare with.
		///
		/// \return \c True, if the objects have the same properties; otherwise \c False.
		///
		/// \remarks Properties that are set to 'undefined' are ignored.\n
		///          Requires Rich Edit 7.5 or newer.
		[id(DISPID_TBLR_EQUALS), helpstring("Retrieves whether two 'TableRow' instances have the same properties. Requires Rich Edit 7.5 or newer.")]
		HRESULT Equals([in] IRichTableRow* compareAgainst, [out, retval] VARIANT_BOOL* pValue);
	}


	/// \interface _IRichTableRowEvents
	/// \brief <em>The \c TableRow class' events interface</em>
	///
	/// This interface defines all events the \c TableRow class may raise.
	///
	/// \sa IRichTableRow
	[
		uuid(D97A605A-4EEE-4F9B-8264-FA697E68BC97),
		helpstring("IRichTableRow-event-interface")
	]
	dispinterface _IRichTableRowEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TableRow class</em>
	///
	/// This COM class implements the \c IRichTableRow and \c _IRichTableRowEvents interfaces.
	///
	/// \sa IRichTableRow, _IRichTableRowEvents, RichTextBox
	[
		uuid(4765AB04-7ABA-4413-9F5B-B8673CDC1F57),
		version(1.0),
		noncreatable,
		helpstring("TableRow Class 1.0 (ANSI)")
	]
	coclass TableRow
	{
		[default] interface IRichTableRow;
		[default, source] dispinterface _IRichTableRowEvents;
	};


	/// \interface IRichTableRows
	/// \brief <em>Manages a collection of \c TableRow objects</em>
	///
	/// This interface provides easy access to collections of \c TableRow objects.
	/// A \c TableRows object is used to group table rows that have certain properties in common.
	///
	/// \sa _IRichTableRowsEvents, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(1AF97888-96BA-4F35-B7A3-3764FDFC63B4),
		dual,
		nonextensible,
		helpstring("IRichTableRows interface"),
		pointer_default(unique)
	]
	interface IRichTableRows : IDispatch
	{
		/// \brief <em>Retrieves a \c TableRow object from the collection</em>
		///
		/// Retrieves a \c TableRow object from the collection that wraps the table row identified by
		/// \c rowIdentifier.
		///
		/// \param[in] rowIdentifier A value that identifies the table row to be retrieved.
		/// \param[in] rowIdentifierType A value specifying the meaning of \c rowIdentifier. Any of the
		///            values defined by the \c RowIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks This is the default property of the \c IRichTableRows interface.\n
		///          This property is read-only.
		///
		/// \sa IRichTableRow, RowIdentifierTypeConstants, Add, Remove, Contains
		[propget, id(DISPID_TBLRS_ITEM), helpstring("Retrieves a 'TableRow' object from the collection that wraps the table row identified by 'rowIdentifier'."), nonbrowsable]
		HRESULT Item([in] LONG rowIdentifier, [in, defaultvalue(ritIndex)] RowIdentifierTypeConstants rowIdentifierType, [out, retval] IRichTableRow** ppRow);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c TableRow objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_TBLRS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);
		/// \brief <em>Retrieves the collection's parent \c Table object</em>
		///
		/// Retrieves a \c Table object that wraps the table that the collection refers to.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTable
		[propget, id(DISPID_TBLRS_PARENTTABLE), helpstring("Retrieves a 'Table' object that wraps the table that the collection refers to. This property is read-only."), nonbrowsable]
		HRESULT ParentTable([out, retval] IRichTable** ppTable);

		/// \brief <em>Adds a row to the table</em>
		///
		/// Adds a row with the specified properties at the specified position in the table and returns
		/// a \c TableRow object wrapping the inserted row.
		///
		/// \param[in] insertAt The zero-based index at which to insert the new row. If set to -1, the row is
		///            inserted after the last row in the table.
		/// \param[in] horizontalAlignment The horizontal alignment of the table row. The following of the
		///            values defined by the \c HAlignmentConstants enumeration are valid: \c halLeft,
		///            \c halCenter, \c halRight.
		/// \param[in] indent The size (in twips) by which the table row is indented horizontally. The indent
		///            is measured from the control's left border.
		/// \param[in] horizontalCellMargin The size (in twips) of the left and right margin in each cell. If
		///            set to -1, the default margin is used.
		/// \param[in] height The row's height (in twips). If set to -1, the default height is used.
		///
		/// \return The inserted row.
		///
		/// \sa Count, Remove, RemoveAll, IRichTableRow::Index, IRichTableRow::HAlignment,
		///     IRichTableRow::HorizontalCellMargin, IRichTableRow::Height, HAlignmentConstants
		[id(DISPID_TBLRS_ADD), helpstring("Adds a new table row with the specified properties.")]
		HRESULT Add([in, defaultvalue(-1)] LONG insertAt, [in, defaultvalue(halLeft)] HAlignmentConstants horizontalAlignment, [in, defaultvalue(-1)] LONG Indent, [in, defaultvalue(-1)] LONG horizontalCellMargin, [in, defaultvalue(-1)] LONG Height, [out, retval] IRichTableRow** ppAddedRow);
		/// \brief <em>Retrieves whether the specified table row is part of the table row collection</em>
		///
		/// \param[in] rowIdentifier A value that identifies the table row to be checked.
		/// \param[in] rowIdentifierType A value specifying the meaning of \c rowIdentifier. Any of the
		///            values defined by the \c RowIdentifierTypeConstants enumeration is valid.
		///
		/// \return \c True, if the specified table row is part of the collection; otherwise \c False.
		///
		/// \sa Add, Remove, RowIdentifierTypeConstants
		[id(DISPID_TBLRS_CONTAINS), helpstring("Retrieves whether the specified table row is part of the table row collection.")]
		HRESULT Contains([in] LONG rowIdentifier, [in, defaultvalue(ritIndex)] RowIdentifierTypeConstants rowIdentifierType, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the table rows in the collection</em>
		///
		/// Retrieves the number of \c TableRow objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_TBLRS_COUNT), helpstring("Retrieves the number of 'TableRow' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the specified row in the collection from the table</em>
		///
		/// \param[in] rowIdentifier A value that identifies the table row to be removed.
		/// \param[in] rowIdentifierType A value specifying the meaning of \c rowIdentifier. Any of the
		///            values defined by the \c RowIdentifierTypeConstants enumeration is valid.
		///
		/// \sa Add, Count, RemoveAll, Contains, RowIdentifierTypeConstants
		[id(DISPID_TBLRS_REMOVE), helpstring("Removes the specified row in the collection from the table.")]
		HRESULT Remove([in] LONG rowIdentifier, [in, defaultvalue(ritIndex)] RowIdentifierTypeConstants rowIdentifierType);
		/// \brief <em>Removes all tabs in the collection from the table</em>
		///
		/// \sa Add, Count, Remove
		[id(DISPID_TBLRS_REMOVEALL), helpstring("Removes all rows in the collection from the table.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IRichTableRowsEvents
	/// \brief <em>The \c TableRows class' events interface</em>
	///
	/// This interface defines all events the \c TableRows class may raise.
	///
	/// \sa IRichTableRows
	[
		uuid(459F2E99-258A-4B64-B392-99DC8E2A991C),
		helpstring("IRichTableRows-event-interface")
	]
	dispinterface _IRichTableRowsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TableRows class</em>
	///
	/// This COM class implements the \c IRichTableRows and \c _IRichTableRowsEvents interfaces.
	///
	/// \sa IRichTableRows, _IRichTableRowsEvents, RichTextBox
	[
		uuid(94C63FEB-5793-4E56-9508-4DA1D179B409),
		version(1.0),
		noncreatable,
		helpstring("TableRows Class 1.0 (ANSI)")
	]
	coclass TableRows
	{
		[default] interface IRichTableRows;
		[default, source] dispinterface _IRichTableRowsEvents;
	};


	/// \interface IRichTable
	/// \brief <em>Wraps a table's styling, e.g. alignment</em>
	///
	/// This interface is a wrapper around the styling of a table.
	///
	/// \sa _IRichTableEvents, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(75A348CF-10C4-4575-B52E-7A8E1AC35789),
		dual,
		nonextensible,
		helpstring("IRichTable interface"),
		pointer_default(unique)
	]
	interface IRichTable : IDispatch
	{
		/// \brief <em>Retrieves the table's nesting level</em>
		///
		/// Retrieves an integer value describing the nesting of tables. If the table is the outermost table,
		/// its nesting level is 1. If it is embedded in another table, that is the outermost table, its
		/// nesting level is 2 and so on.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTextRange::ReplaceWithTable
		[propget, id(DISPID_TBL_NESTINGLEVEL), helpstring("Retrieves an integer value describing the nesting of tables. This property is read-only.")]
		HRESULT NestingLevel([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the table's rows</em>
		///
		/// Retrieves a collection object wrapping the table's rows.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTableRows
		[propget, id(DISPID_TBL_ROWS), helpstring("Retrieves a collection object wrapping the table's rows."), nonbrowsable]
		HRESULT Rows([out, retval] IRichTableRows** ppRows);
		/// \brief <em>Retrieves a \c TextRange object for the table</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTextRange
		[propget, id(DISPID_TBL_TEXTRANGE), helpstring("Retrieves a 'TextRange' object for the table. This property is read-only.")]
		HRESULT TextRange([out, retval] IRichTextRange** ppTextRange);
	}


	/// \interface _IRichTableEvents
	/// \brief <em>The \c Table class' events interface</em>
	///
	/// This interface defines all events the \c Table class may raise.
	///
	/// \sa IRichTable
	[
		uuid(076C05DE-6006-485F-A58F-2087A1EE0710),
		helpstring("IRichTable-event-interface")
	]
	dispinterface _IRichTableEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c Table class</em>
	///
	/// This COM class implements the \c IRichTable and \c _IRichTableEvents interfaces.
	///
	/// \sa IRichTable, _IRichTableEvents, RichTextBox
	[
		uuid(8DB68DDC-2C3D-4B45-ADC6-7C46C144F8BE),
		version(1.0),
		noncreatable,
		helpstring("Table Class 1.0 (ANSI)")
	]
	coclass Table
	{
		[default] interface IRichTable;
		[default, source] dispinterface _IRichTableEvents;
	};


	/// \interface IRichTextSubRanges
	/// \brief <em>Manages a collection of \c TextRange objects</em>
	///
	/// This interface provides easy access to collections of \c TextRange objects that are sub-ranges of
	/// another \c TextRange object.
	/// A \c TextSubRanges object is used to group text sub-ranges that have certain properties in common.
	///
	/// \sa _IRichTextSubRangesEvents, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(93737AB3-28A7-4869-A46E-3EC96D96B48F),
		dual,
		nonextensible,
		helpstring("IRichTextSubRanges interface"),
		pointer_default(unique)
	]
	interface IRichTextSubRanges : IDispatch
	{
		/// \brief <em>Specifies the sub-range within the text range that has the keyboard focus</em>
		///
		/// Retrieves or sets the sub-range that is affected by operations such as [SHIFT]+Arrow keys if the
		/// parent text range is the selection.
		///
		/// \attention This property cannot be set, because as of June 2015 all Rich Edit versions seem to ignore it.
		///
		/// \sa IRichTextBox::MultiSelect
		[propget, id(DISPID_TSRS_ACTIVESUBRANGE), helpstring("Retrieves or sets the sub-range that is affected by operations such as [SHIFT]+Arrow keys if the parent text range is the selection.")]
		HRESULT ActiveSubRange([out, retval] IRichTextRange** ppActiveSubRange);
		//[propputref, id(DISPID_TSRS_ACTIVESUBRANGE), helpstring("Retrieves or sets the sub-range that is affected by operations such as [SHIFT]+Arrow keys if the parent text range is the selection.")]
		//HRESULT ActiveSubRange([in] IRichTextRange* pNewActiveSubRange);
		/// \brief <em>Retrieves a \c TextRange object from the collection</em>
		///
		/// Retrieves a \c TextRange object from the collection that wraps the sub-range identified by
		/// \c subRangeIdentifier.
		///
		/// \param[in] subRangeIdentifier A value that identifies the sub-range to be retrieved.
		/// \param[in] subRangeIdentifierType A value specifying the meaning of \c subRangeIdentifier. Any of
		///            the values defined by the \c SubRangeIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks This is the default property of the \c IRichTextSubRanges interface.\n
		///          This property is read-only.
		///
		/// \sa IRichTextRange, SubRangeIdentifierTypeConstants, Add, Remove, Contains
		[propget, id(DISPID_TSRS_ITEM), helpstring("Retrieves a 'TextRange' object from the collection that wraps the sub-range identified by 'subRangeIdentifier'."), nonbrowsable]
		HRESULT Item([in] VARIANT subRangeIdentifier, [in, defaultvalue(sritIndex)] SubRangeIdentifierTypeConstants subRangeIdentifierType, [out, retval] IRichTextRange** ppSubRange);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c TextRange objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_TSRS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds a sub-range to the text range</em>
		///
		/// Adds a sub-range with the specified properties to the text range and returns a \c TextRange
		/// object wrapping the inserted sub-range.
		///
		/// \param[in] activeSubRangeEnd The character position of the active end of the sub-range. The active
		///            end is the end with the cursor.
		/// \param[in] anchorSubRangeEnd The character position of the anchor end of the sub-range. The anchor
		///            end is the end at which selecting the text range starts.
		/// \param[in] activateSubRange Specifies whether the new sub-range will become the active sub-range
		///            within its parent text range. If set to \c True, it will become the active sub-range;
		///            otherwise not.
		///
		/// \return The inserted sub-range.
		///
		/// \sa ActiveSubRange, Count, Remove, RemoveAll
		[id(DISPID_TSRS_ADD), helpstring("Adds a new sub-range with the specified properties.")]
		HRESULT Add([in] LONG activeSubRangeEnd, [in] LONG anchorSubRangeEnd, [in, defaultvalue(-1)] VARIANT_BOOL activateSubRange, [out, retval] IRichTextRange** ppAddedSubRange);
		/// \brief <em>Retrieves whether the specified sub-range is part of the sub-range collection</em>
		///
		/// \param[in] subRangeIdentifier A value that identifies the sub-range to be checked.
		/// \param[in] subRangeIdentifierType A value specifying the meaning of \c subRangeIdentifier. Any of
		///            the values defined by the \c SubRangeIdentifierTypeConstants enumeration is valid.
		///
		/// \return \c True, if the specified sub-range is part of the collection; otherwise \c False.
		///
		/// \sa Add, Remove, SubRangeIdentifierTypeConstants
		[id(DISPID_TSRS_CONTAINS), helpstring("Retrieves whether the specified sub-range is part of the sub-range collection.")]
		HRESULT Contains([in] VARIANT subRangeIdentifier, [in, defaultvalue(sritIndex)] SubRangeIdentifierTypeConstants subRangeIdentifierType, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the sub-ranges in the collection</em>
		///
		/// Retrieves the number of \c TextRange objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_TSRS_COUNT), helpstring("Retrieves the number of 'TextRange' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the specified sub-range in the collection from the text range</em>
		///
		/// \param[in] subRangeIdentifier A value that identifies the sub-range to be removed.
		/// \param[in] subRangeIdentifierType A value specifying the meaning of \c subRangeIdentifier. Any of
		///            the values defined by the \c SubRangeIdentifierTypeConstants enumeration is valid.
		///
		/// \attention As of June 2015 no Rich Edit version seems to support this method.
		///
		/// \sa Add, Count, RemoveAll, Contains, SubRangeIdentifierTypeConstants
		[id(DISPID_TSRS_REMOVE), helpstring("Removes the specified sub-range in the collection from the text range.")]
		HRESULT Remove([in] VARIANT subRangeIdentifier, [in, defaultvalue(sritIndex)] SubRangeIdentifierTypeConstants subRangeIdentifierType);
		/// \brief <em>Removes all sub-ranges in the collection from the text range</em>
		///
		/// \attention As of June 2015 no Rich Edit version seems to support this method.
		///
		/// \sa Add, Count, Remove
		[id(DISPID_TSRS_REMOVEALL), helpstring("Removes all sub-ranges in the collection from the text range.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IRichTextSubRangesEvents
	/// \brief <em>The \c TextSubRanges class' events interface</em>
	///
	/// This interface defines all events the \c TextSubRanges class may raise.
	///
	/// \sa IRichTextSubRanges
	[
		uuid(42590F00-A95F-48AF-A776-B0D43051BEA8),
		helpstring("IRichTextSubRanges-event-interface")
	]
	dispinterface _IRichTextSubRangesEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TextSubRanges class</em>
	///
	/// This COM class implements the \c IRichTextSubRanges and \c _IRichTextSubRangesEvents interfaces.
	///
	/// \sa IRichTextSubRanges, _IRichTextSubRangesEvents, RichTextBox
	[
		uuid(FDACC8C7-9C66-4429-999B-8D236EDF677F),
		version(1.0),
		noncreatable,
		helpstring("TextSubRanges Class 1.0 (ANSI)")
	]
	coclass TextSubRanges
	{
		[default] interface IRichTextSubRanges;
		[default, source] dispinterface _IRichTextSubRangesEvents;
	};


	/// \interface IRichOLEObject
	/// \brief <em>Wraps an embedded OLE object's attributes</em>
	///
	/// This interface is a wrapper around the attributes of an embedded OLE object.
	///
	/// \sa _IRichOLEObjectEvents, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(99ACEE4F-8E3B-46A5-BAE0-7579D708CF37),
		dual,
		nonextensible,
		helpstring("IRichOLEObject interface"),
		pointer_default(unique)
	]
	interface IRichOLEObject : IDispatch
	{
		/// \brief <em>Retrieves the OLE object's class identifier</em>
		///
		/// Retrieves an OLE object's class identifier, the \c CLSID corresponding to the string identifying
		/// the object to an end user.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ProgID, TypeName
		[propget, id(DISPID_OO_CLASSID), helpstring("Retrieves an OLE object's class identifier, the \c CLSID corresponding to the string identifying the object to an end user. This property is read-only."), nonbrowsable]
		HRESULT ClassID([out, retval] BSTR* pValue);
		/// \brief <em>Specifies how the embedded OLE object is displayed</em>
		///
		/// Retrieves or sets the embedded OLE object's display aspect, i.e. whether it is displayed as an icon
		/// or as an embedded object. Any of the values defined by the \c DisplayAspectConstants enumeration is
		/// valid. Other display aspects as specified on MSDN may work as well.
		///
		/// \sa DisplayAspectConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">Display Aspects</a>
		[propget, id(DISPID_OO_DISPLAYASPECT), helpstring("Retrieves or sets the embedded OLE object's display aspect, i.e. whether it is displayed as an icon or as an embedded object.")]
		HRESULT DisplayAspect([out, retval] DisplayAspectConstants* pValue);
		[propput, id(DISPID_OO_DISPLAYASPECT), helpstring("Retrieves or sets the embedded OLE object's display aspect, i.e. whether it is displayed as an icon or as an embedded object.")]
		HRESULT DisplayAspect([in] DisplayAspectConstants newValue);
		/// \brief <em>Specifies extended properties of the embedded OLE object</em>
		///
		/// Retrieves or sets flags that control how the OLE object is embedded, e.g. how it is aligned. Any
		/// combination of the values defined by the \c OLEObjectFlagsConstants enumeration is valid.
		///
		/// \sa OLEObjectFlagsConstants
		[propget, id(DISPID_OO_FLAGS), helpstring("Retrieves or sets flags that control how the OLE object is embedded, e.g. how it is aligned.")]
		HRESULT Flags([out, retval] OLEObjectFlagsConstants* pValue);
		[propput, id(DISPID_OO_FLAGS), helpstring("Retrieves or sets flags that control how the OLE object is embedded, e.g. how it is aligned.")]
		HRESULT Flags([in] OLEObjectFlagsConstants newValue);
		/// \brief <em>Retrieves the embedded OLE object's zero-based index</em>
		///
		/// Retrieves the zero-based index identifying this embedded OLE object.
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_OO_INDEX), helpstring("Retrieves the zero-based index identifying this embedded OLE object. This property is read-only."), nonbrowsable]
		HRESULT Index([out, retval] LONG* pValue);
		/// \brief <em>Sepecifies the fully qualified path to the OLE object's source file if it is a link</em>
		///
		/// Retrieves or sets the fully qualified path to the source file, if the OLE object is a link.
		///
		/// \remarks This property will fail if the \c Flags property does not include the \c oofIsLink flag.
		///
		/// \sa Flags, TypeName
		[propget, id(DISPID_OO_LINKSOURCE), helpstring("Retrieves or sets the fully qualified path to the source file, if the OLE object is a link. This property will fail if the \c Flags property does not include the 'oofIsLink' flag.")]
		HRESULT LinkSource([out, retval] BSTR* pValue);
		[propput, id(DISPID_OO_LINKSOURCE), helpstring("Retrieves or sets the fully qualified path to the source file, if the OLE object is a link. This property will fail if the \c Flags property does not include the 'oofIsLink' flag.")]
		HRESULT LinkSource([in] BSTR newValue);
		/// \brief <em>Retrieves the OLE object's programmatic identifier</em>
		///
		/// Retrieves an OLE object's programmatic identifier, the \c ProgID corresponding to the string
		/// identifying the object to an end user.
		///
		/// \remarks This is the default property of the \c IRichOLEObject interface.\n
		///          This property is read-only.
		///
		/// \sa ClassID, TypeName
		[propget, id(DISPID_OO_PROGID), helpstring("Retrieves an OLE object's programmatic identifier, the \c ProgID corresponding to the string identifying the object to an end user. This property is read-only."), nonbrowsable]
		HRESULT ProgID([out, retval] BSTR* pValue);
		/// \brief <em>Retrieves a \c TextRange object for the embedded OLE object</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTextRange
		[propget, id(DISPID_OO_TEXTRANGE), helpstring("Retrieves a 'TextRange' object for the embedded OLE object. This property is read-only."), nonbrowsable]
		HRESULT TextRange([out, retval] IRichTextRange** ppTextRange);
		/// \brief <em>Retrieves the OLE object's user-friendly type name</em>
		///
		/// Retrieves the user-type name of an object for display in user-interface elements such as menus,
		/// list boxes, and dialog boxes.
		///
		/// \param[in] format The kind of type name to retrieve. Any of the values defined by the
		///            \c OLEObjectTypeNameFormatConstants enumeration is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa ClassID, ProgID, OLEObjectTypeNameFormatConstants
		[propget, id(DISPID_OO_TYPENAME), helpstring("Retrieves the user-type name of an object for display in user-interface elements such as menus, list boxes, and dialog boxes. This property is read-only."), nonbrowsable]
		HRESULT TypeName([in] OLEObjectTypeNameFormatConstants format, [out, retval] BSTR* pValue);
		/// \brief <em>Specifies the OLE object's associated data</em>
		///
		/// Retrieves or sets the \c Long value associated with the OLE object. Use this property to associate
		/// any data with the object.
		[propget, id(DISPID_OO_USERDATA), helpstring("Retrieves or sets the Long value associated with the OLE object.")]
		HRESULT UserData([out, retval] LONG* pValue);
		[propput, id(DISPID_OO_USERDATA), helpstring("Retrieves or sets the Long value associated with the OLE object.")]
		HRESULT UserData([in] LONG newValue);

		/// \brief <em>Executes the specified verb</em>
		///
		/// Executes the specified verb on the embedded OLE object.
		///
		/// \param[in] verbID The unique identifier of the verb to execute.
		///
		/// \sa GetVerbs, OLEVERBDETAILS::ID
		[id(DISPID_OO_EXECUTEVERB), helpstring("Executes the specified verb on the embedded OLE object.")]
		HRESULT ExecuteVerb([in] LONG verbID);
		/// \brief <em>Retrieves the OLE object's bounding rectangle</em>
		///
		/// Retrieves the OLE object's bounding rectangle in pixels relative to the control's upper-left
		/// corner.
		///
		/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border.
		/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border.
		/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border.
		/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border.
		///
		/// \sa SetSize, GetRectangle
		[id(DISPID_OO_GETRECTANGLE), helpstring("Retrieves the OLE object's bounding rectangle in pixels relative to the control's upper-left corner.")]
		HRESULT GetRectangle([in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xLeft, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yTop, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* xRight, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* yBottom);
		/// \brief <em>Retrieves the OLE object's extent</em>
		///
		/// Retrieves the OLE object's extent (in himetrics).
		///
		/// \param[out] width The OLE object's current width in himetrics.
		/// \param[out] height The OLE object's current height in himetrics.
		///
		/// \sa SetSize, GetRectangle
		[id(DISPID_OO_GETSIZE), helpstring("Retrieves the OLE object's extent (in himetrics).")]
		HRESULT GetSize([in, out, defaultvalue(0)] OLE_XSIZE_HIMETRIC* Width, [in, out, defaultvalue(0)] OLE_YSIZE_HIMETRIC* Height);
		/// \brief <em>Retrieves the OLE object's verbs</em>
		///
		/// Retrieves the verbs provided by the object. The client application may execute these verbs to
		/// perform operations on the object.
		///
		/// \param[out] verbs Will be set to an array of \c OLEVERBDETAILS structures, each defining a verb.
		///
		/// \return The number of verbs.
		///
		/// \sa ExecuteVerb, OLEVERBDETAILS
		[id(DISPID_OO_GETVERBS), helpstring("Retrieves the verbs provided by the object. The client application may execute these verbs to perform operations on the object.")]
		HRESULT GetVerbs([in, out] VARIANT* verbs, [out, retval] LONG* pCount);
		/// \brief <em>Sets the OLE object's extent</em>
		///
		/// Sets the OLE object's extent (in himetrics).
		///
		/// \param[in] width The OLE object's desired width in himetrics.
		/// \param[in] height The OLE object's desired height in himetrics.
		///
		/// \sa GetSize, GetRectangle
		[id(DISPID_OO_SETSIZE), helpstring("Sets the OLE object's extent (in himetrics).")]
		HRESULT SetSize([in] OLE_XSIZE_HIMETRIC Width, [in] OLE_YSIZE_HIMETRIC Height);
	}


	/// \interface _IRichOLEObjectEvents
	/// \brief <em>The \c OLEObject class' events interface</em>
	///
	/// This interface defines all events the \c OLEObject class may raise.
	///
	/// \sa IRichOLEObject
	[
		uuid(FD9B3892-7E48-42B4-B249-3026A8C3B6C2),
		helpstring("IRichOLEObject-event-interface")
	]
	dispinterface _IRichOLEObjectEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c OLEObject class</em>
	///
	/// This COM class implements the \c IRichOLEObject and \c _IRichOLEObjectEvents interfaces.
	///
	/// \sa IRichOLEObject, _IRichOLEObjectEvents, RichTextBox
	[
		uuid(8C269988-3E7D-4EFB-B4AA-28F2CF7D9767),
		version(1.0),
		noncreatable,
		helpstring("OLEObject Class 1.0 (ANSI)")
	]
	coclass OLEObject
	{
		[default] interface IRichOLEObject;
		[default, source] dispinterface _IRichOLEObjectEvents;
	};


	/// \interface IRichOLEObjects
	/// \brief <em>Manages a collection of \c OLEObject objects</em>
	///
	/// This interface provides easy access to collections of \c OLEObject objects.
	/// A \c OLEObjects object is used to group embedded OLE objects that have certain properties in common.
	///
	/// \sa _IRichOLEObjectsEvents, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(1AAF1650-33E4-4501-BC8C-B37737095318),
		dual,
		nonextensible,
		helpstring("IRichOLEObjects interface"),
		pointer_default(unique)
	]
	interface IRichOLEObjects : IDispatch
	{
		/// \brief <em>Retrieves an \c OLEObject object from the collection</em>
		///
		/// Retrieves an \c OLEObject object from the collection that wraps the embedded OLE object identified
		/// by \c objectIdentifier.
		///
		/// \param[in] objectIdentifier A value that identifies the embedded OLE object to be retrieved.
		/// \param[in] objectIdentifierType A value specifying the meaning of \c objectIdentifier. Any of the
		///            values defined by the \c ObjectIdentifierTypeConstants enumeration is valid.
		///
		/// \remarks This is the default property of the \c IRichOLEObjects interface.\n
		///          This property is read-only.
		///
		/// \sa IRichOLEObject, ObjectIdentifierTypeConstants, Add, Remove, Contains
		[propget, id(DISPID_OOS_ITEM), helpstring("Retrieves an 'OLEObject' object from the collection that wraps the embedded OLE object identified by 'objectIdentifier'."), nonbrowsable]
		HRESULT Item([in] VARIANT objectIdentifier, [in, defaultvalue(oitIndex)] ObjectIdentifierTypeConstants objectIdentifierType, [out, retval] IRichOLEObject** ppObject);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves a \c VARIANT enumerator</em>
		///
		///   Retrieves a \c VARIANT enumerator that may be used to iterate the \c OLEObject objects
		///   managed by this collection object. This iterator is used by Visual Basic's \c For...Each
		///   construct.
		///
		///   \remarks This property is read-only and hidden.
		///
		///   \sa <a href="https://msdn.microsoft.com/en-us/library/ms221053.aspx">IEnumVARIANT</a>
		/// \endif
		[propget, id(DISPID_OOS__NEWENUM), restricted]
		HRESULT _NewEnum([out, retval] IUnknown** ppEnumerator);

		/// \brief <em>Adds an embedded OLE object to the control</em>
		///
		/// Adds an embedded OLE object with the specified properties at the specified position into the
		/// document and returns a \c OLEObject object wrapping the inserted object.
		///
		/// \param[in] objectReference Identifies the object to insert. May be:
		///            - Empty or not set, if \c fileToCreateFrom is set.
		///            - A programmatic identifier (e.g. "WordPad.Document.1"). The control will create an
		///              instance of this class.
		///            - A \c CLSID (e.g. "{73FDDC80-AEA9-101A-98A7-00AA00374959}"). The control will create an
		///              instance of this class.
		///            - An object that implements the \c IOleObject interface. The control will use this
		///              object directly.
		/// \param[in] fileToCreateFrom Optionally an absolute path to a file to create the object from. This
		///            parameter will be ignored, if \c objectReference contains an object.
		/// \param[in] insertAsLink If the object is created from a file, set this parameter to \c True to link
		///            the inserted object with the file. Otherwise a copy of the file will be inserted. If
		///            the object is linked to the file, it will reflect changes to the file.
		/// \param[in] characterPosition The zero-based character position at which to insert the new object.
		///            If set to -1, the object will replace the current selection.
		/// \param[in] displayAspect The object's display aspect, i.e. whether it is displayed as an icon or as
		///            an embedded object. Any of the values defined by the \c DisplayAspectConstants
		///            enumeration is valid. Other display aspects as specified on MSDN may work as well.
		/// \param[in] flags A bit field that controls how the OLE object is embedded, e.g. how it is aligned.
		///            Any combination of the values defined by the \c OLEObjectFlagsConstants enumeration is
		///            valid.
		/// \param[in] width The object's width (in himetric). If set to 0, the object defines its size itself.
		/// \param[in] height The object's height (in himetric). If set to 0, the object defines its size
		///            itself.
		/// \param[in] userData A \c Long value associated with the OLE object. Use this property to associate
		///            any data with the object.
		///
		/// \return The inserted OLE object.
		///
		/// \sa AddImage, Count, Remove, RemoveAll, IRichOLEObject::ClassID, IRichOLEObject::ProgID,
		///     IRichOLEObject::LinkSource, IRichOLEObject::TextRange, IRichOLEObject::DisplayAspect,
		///     DisplayAspectConstants, IRichOLEObject::Flags, OLEObjectFlagsConstants,
		///     IRichOLEObject::GetSize, IRichOLEObject::UserData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">Display Aspects</a>
		[id(DISPID_OOS_ADD), helpstring("Adds a new embedded OLE object with the specified properties.")]
		HRESULT Add([in, optional] VARIANT objectReference, [in, defaultvalue("")] BSTR fileToCreateFrom, [in, defaultvalue(0)] VARIANT_BOOL insertAsLink, [in, defaultvalue(-1/*REO_CP_SELECTION*/)] LONG characterPosition, [in, defaultvalue(daContent)] DisplayAspectConstants displayAspect, [in, defaultvalue(oofDynamicSize | oofResizable)] OLEObjectFlagsConstants Flags, [in, defaultvalue(0)] OLE_XSIZE_HIMETRIC Width, [in, defaultvalue(0)] OLE_YSIZE_HIMETRIC Height, [in, defaultvalue(0)] LONG UserData, [out, retval] IRichOLEObject** ppAddedObject);
		/// \brief <em>Adds an embedded image to the control</em>
		///
		/// Adds an embedded image with the specified properties at the specified position into the document
		/// and returns a \c OLEObject object wrapping the inserted image.
		///
		/// \param[in] imageData Identifies the image to insert. May be:
		///            - A fully qualified path to a file that can be loaded by GDI+ (e.g. JPG, PNG, BMP, GIF,
		///              EMF, WMF). The image will be embedded as bitmap.
		///            - A handle to a metafile, enhanced metafile, DIB, or bitmap.
		///            - An \c IPictureDisp object (VB6 \c StdPicture).
		///            - An object that implements the \c IDataObject interface.
		/// \param[in] characterPosition The zero-based character position at which to insert the new image.
		///            If set to -1, the image will replace the current selection.
		/// \param[in] flags A bit field that controls how the image is embedded, e.g. how it is aligned.
		///            Any combination of the values defined by the \c OLEObjectFlagsConstants enumeration is
		///            valid.
		/// \param[in] width The image's width (in himetric). If set to 0, the image defines its size itself.
		/// \param[in] height The image's height (in himetric). If set to 0, the image defines its size itself.
		/// \param[in] userData A \c Long value associated with the image. Use this property to associate any
		///            data with the image.
		///
		/// \return The inserted image as OLE object.
		///
		/// \sa Add, Count, Remove, RemoveAll, IRichOLEObject::TextRange, IRichOLEObject::Flags,
		///     OLEObjectFlagsConstants, IRichOLEObject::GetSize, IRichOLEObject::UserData,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
		[id(DISPID_OOS_ADDIMAGE), helpstring("Adds an embedded image with the specified properties.")]
		HRESULT AddImage([in] VARIANT imageData, [in, defaultvalue(-1/*REO_CP_SELECTION*/)] LONG characterPosition, [in, defaultvalue(oofDynamicSize | oofResizable)] OLEObjectFlagsConstants Flags, [in, defaultvalue(0)] OLE_XSIZE_HIMETRIC Width, [in, defaultvalue(0)] OLE_YSIZE_HIMETRIC Height, [in, defaultvalue(0)] LONG UserData, [out, retval] IRichOLEObject** ppAddedObject);
		/// \brief <em>Retrieves whether the specified object is part of the OLE object collection</em>
		///
		/// \param[in] objectIdentifier A value that identifies the embedded OLE object to be checked.
		/// \param[in] objectIdentifierType A value specifying the meaning of \c objectIdentifier. Any of the
		///            values defined by the \c ObjectIdentifierTypeConstants enumeration is valid.
		///
		/// \return \c True, if the specified OLE object is part of the collection; otherwise \c False.
		///
		/// \sa Add, Remove, ObjectIdentifierTypeConstants
		[id(DISPID_OOS_CONTAINS), helpstring("Retrieves whether the specified tab is part of the tab collection.")]
		HRESULT Contains([in] VARIANT objectIdentifier, [in, defaultvalue(oitIndex)] ObjectIdentifierTypeConstants objectIdentifierType, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Counts the OLE objects in the collection</em>
		///
		/// Retrieves the number of \c OLEObject objects in the collection.
		///
		/// \return The number of elements in the collection.
		///
		/// \sa Add, Remove, RemoveAll
		[id(DISPID_OOS_COUNT), helpstring("Retrieves the number of 'OLEObject' objects in the collection.")]
		HRESULT Count([out, retval] LONG* pValue);
		/// \brief <em>Removes the specified embedded OLE object in the collection from the document</em>
		///
		/// \param[in] objectIdentifier A value that identifies the embedded OLE object to be removed.
		/// \param[in] objectIdentifierType A value specifying the meaning of \c objectIdentifier. Any of the
		///            values defined by the \c ObjectIdentifierTypeConstants enumeration is valid.
		///
		/// \sa Add, Count, RemoveAll, Contains, ObjectIdentifierTypeConstants
		[id(DISPID_OOS_REMOVE), helpstring("Removes the specified embedded OLE object in the collection from the document.")]
		HRESULT Remove([in] VARIANT objectIdentifier, [in, defaultvalue(oitIndex)] ObjectIdentifierTypeConstants objectIdentifierType);
		/// \brief <em>Removes all embedded OLE objects in the collection from the document</em>
		///
		/// \sa Add, Count, Remove
		[id(DISPID_OOS_REMOVEALL), helpstring("Removes all embedded OLE objects in the collection from the document.")]
		HRESULT RemoveAll(void);
	}


	/// \interface _IRichOLEObjectsEvents
	/// \brief <em>The \c OLEObjects class' events interface</em>
	///
	/// This interface defines all events the \c OLEObjects class may raise.
	///
	/// \sa IRichOLEObjects
	[
		uuid(11BE0048-4BBF-46D3-B416-19B27B57C49D),
		helpstring("IRichOLEObjects-event-interface")
	]
	dispinterface _IRichOLEObjectsEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c OLEObjects class</em>
	///
	/// This COM class implements the \c IRichOLEObjects and \c _IRichOLEObjectsEvents interfaces.
	///
	/// \sa IRichOLEObjects, _IRichOLEObjectsEvents, RichTextBox
	[
		uuid(AFBD8074-82CD-470A-AE78-CB65CFDF4AF1),
		version(1.0),
		noncreatable,
		helpstring("OLEObjects Class 1.0 (ANSI)")
	]
	coclass OLEObjects
	{
		[default] interface IRichOLEObjects;
		[default, source] dispinterface _IRichOLEObjectsEvents;
	};


	/// \interface IRichTextRange
	/// \brief <em>Wraps a range of text</em>
	///
	/// This interface is a wrapper around a range of text.
	///
	/// \sa _IRichTextRangeEvents, IRichTextBox, _IRichTextBoxEvents
	[
		object,
		uuid(FA5E6F69-1105-483D-9582-34834B5C9B9A),
		dual,
		nonextensible,
		helpstring("IRichTextRange interface"),
		pointer_default(unique)
	]
	interface IRichTextRange : IDispatch
	{
		/// \brief <em>Retrieves whether the text in the text range can be edited</em>
		///
		/// Retrieves whether the text in the text range can be edited. Any of the values defined by the
		/// \c BooleanPropertyValueConstants enumeration is valid. If set to \c bpvTrue, the text can be
		/// edited; if set to \c bpvFalse, it cannot be edited; and if set to \c bpvUndefined, parts of the
		/// text range can be edited and others can't.
		/// The text cannot be edited, if the document is read-only or any part of the text is protected.
		///
		/// \remarks This property is read-only.
		///
		/// \sa CanPaste, Text, BooleanPropertyValueConstants
		[propget, id(DISPID_TR_CANEDIT), helpstring("Retrieves whether the text in the text range can be edited. This property is read-only."), nonbrowsable]
		HRESULT CanEdit([out, retval] BooleanPropertyValueConstants* pValue);
		/// \brief <em>Retrieves the embedded OLE object identified by the text range</em>
		///
		/// Retrieves the embedded OLE object that is positioned at the text range's start point. If the text
		/// range spans more than the embedded object, this property will be \c Nothing.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichOLEObject, IRichTextBox::EmbeddedObjects
		[propget, id(DISPID_TR_EMBEDDEDOBJECT), helpstring("Retrieves the embedded OLE object that is positioned at the text range's start point. If the text range spans more than the embedded object, this property will be 'Nothing'. This property is read-only."), nonbrowsable]
		HRESULT EmbeddedObject([out, retval] IRichOLEObject** ppOLEObject);
		/// \brief <em>Specifies the text range's first character</em>
		///
		/// Retrieves or sets the first character of the text range.
		///
		/// \sa Text, RangeStart
		[propget, id(DISPID_TR_FIRSTCHAR), helpstring("Retrieves or sets the first character of the text range."), nonbrowsable]
		HRESULT FirstChar([out, retval] LONG* pValue);
		[propput, id(DISPID_TR_FIRSTCHAR), helpstring("Retrieves or sets the first character of the text range."), nonbrowsable]
		HRESULT FirstChar([in] LONG newValue);
		/// \brief <em>Controls the text range's styling</em>
		///
		/// Retrieves or sets an object that can be used to retrieve and set the text range's styling, e.g.
		/// font and colors.
		///
		/// \sa IRichTextFont, Paragraph, IRichTextBox::DocumentFont
		[propget, id(DISPID_TR_FONT), helpstring("Retrieves or sets an object that can be used to retrieve and set the text range's styling, e.g. font and colors."), nonbrowsable]
		HRESULT Font([out, retval] IRichTextFont** ppTextFont);
		[propput, id(DISPID_TR_FONT), helpstring("Retrieves or sets an object that can be used to retrieve and set the text range's styling, e.g. font and colors."), nonbrowsable]
		HRESULT Font([in] IRichTextFont* pNewTextFont);
		/// \brief <em>Controls the text range's styling that applies to the current paragraph</em>
		///
		/// Retrieves or sets an object that can be used to retrieve and set the text range's styling that
		/// applies to the whole paragraph, e.g. alignment and line spacing.
		///
		/// \sa IRichTextParagraph, Font, IRichTextBox::DocumentParagraph
		[propget, id(DISPID_TR_PARAGRAPH), helpstring("Retrieves or sets an object that can be used to retrieve and set the text range's styling that applies to the whole paragraph, e.g. alignment and line spacing."), nonbrowsable]
		HRESULT Paragraph([out, retval] IRichTextParagraph** ppTextParagraph);
		[propput, id(DISPID_TR_PARAGRAPH), helpstring("Retrieves or sets an object that can be used to retrieve and set the text range's styling that applies to the whole paragraph, e.g. alignment and line spacing."), nonbrowsable]
		HRESULT Paragraph([in] IRichTextParagraph* pNewTextParagraph);
		/// \brief <em>Specifies the end of the text range</em>
		///
		/// Retrieves or sets the zero-based index of the first character after the text range.
		///
		/// \sa RangeStart, SetStartAndEnd, RangeLength, Text
		[propget, id(DISPID_TR_RANGEEND), helpstring("Retrieves or sets the zero-based index of the first character after the text range."), nonbrowsable]
		HRESULT RangeEnd([out, retval] LONG* pValue);
		[propput, id(DISPID_TR_RANGEEND), helpstring("Retrieves or sets the zero-based index of the first character after the text range."), nonbrowsable]
		HRESULT RangeEnd([in] LONG newValue);
		/// \brief <em>Retrieves the length of the text range</em>
		///
		/// Retrieves the length (in characters) of the text range.
		///
		/// \remarks This property is read-only.
		///
		/// \sa RangeStart, RangeEnd, Text
		[propget, id(DISPID_TR_RANGELENGTH), helpstring("Retrieves the length (in characters) of the text range. This property is read-only."), nonbrowsable]
		HRESULT RangeLength([out, retval] LONG* pValue);
		/// \brief <em>Specifies the start of the text range</em>
		///
		/// Retrieves or sets the zero-based index of the first character in the text range.
		///
		/// \sa RangeEnd, SetStartAndEnd, RangeLength, Text
		[propget, id(DISPID_TR_RANGESTART), helpstring("Retrieves or sets the zero-based index of the first character in the text range."), nonbrowsable]
		HRESULT RangeStart([out, retval] LONG* pValue);
		[propput, id(DISPID_TR_RANGESTART), helpstring("Retrieves or sets the zero-based index of the first character in the text range."), nonbrowsable]
		HRESULT RangeStart([in] LONG newValue);
		/// \brief <em>Specifies the text range's content, including control words for formatting</em>
		///
		/// Retrieves or sets the text range's content, including RTF control words for formatting.
		///
		/// \sa Text, Font, Paragraph, IRichTextBox::RichText, CopyRichTextFromTextRange
		[propget, id(DISPID_TR_RICHTEXT), helpstring("Retrieves or sets the text range's content, including RTF control words for formatting."), nonbrowsable]
		HRESULT RichText([out, retval] BSTR* pValue);
		[propput, id(DISPID_TR_RICHTEXT), helpstring("Retrieves or sets the text range's content, including RTF control words for formatting."), nonbrowsable]
		HRESULT RichText([in] BSTR newValue);
		/// \brief <em>Retrieves the length of the text range's story</em>
		///
		/// Retrieves the count of characters in the story that the text range belongs to.
		///
		/// \remarks This property is read-only.
		///
		/// \sa StoryType
		[propget, id(DISPID_TR_STORYLENGTH), helpstring("Retrieves the count of characters in the story that the text range belongs to. This property is read-only."), nonbrowsable]
		HRESULT StoryLength([out, retval] LONG* pValue);
		/// \brief <em>Retrieves the type of the text range's story</em>
		///
		/// Retrieves the type of the story that the text range belongs to. Any of the values defined by the
		/// \c StoryTypeConstants enumeration is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa StoryLength, StoryTypeConstants
		[propget, id(DISPID_TR_STORYTYPE), helpstring("Retrieves the type of the story that the text range belongs to. This property is read-only."), nonbrowsable]
		HRESULT StoryType([out, retval] StoryTypeConstants* pValue);
		/// \brief <em>Retrieves additional text ranges assigned to this text range</em>
		///
		/// Retrieves a collection object wrapping the additional text ranges that are assigned to this text
		/// range. For instance sub-ranges are used with multi-selection.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.\n
		///          This property is read-only.
		///
		/// \sa IRichTextBox::MultiSelect, IRichTextSubRanges
		[propget, id(DISPID_TR_SUBRANGES), helpstring("Retrieves a collection object wrapping the additional text ranges that are assigned to this text range. This property is read-only."), nonbrowsable]
		HRESULT SubRanges([out, retval] IRichTextSubRanges** ppSubRanges);
		/// \brief <em>Specifies the text range's content</em>
		///
		/// Retrieves or sets the text range's content. It is the plain text, without RTF formatting.
		///
		/// \remarks This is the default property of the \c IRichTextRange interface.\n
		///
		/// \sa RichText, URL, FindText, Delete, Font, IRichTextBox::Text
		[propget, id(DISPID_TR_TEXT), helpstring("Retrieves or sets the text range's content. It is the plain text, without RTF formatting."), nonbrowsable]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_TR_TEXT), helpstring("Retrieves or sets the text range's content. It is the plain text, without RTF formatting."), nonbrowsable]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Retrieves the index of the specified unit at the text range's start position</em>
		///
		/// Retrieves the one-based index of the specified unit (within the story) at the text range's start
		/// position. For instance, if the range starts within line 10, its index of the \c uLine unit is 10.
		///
		/// \param[in] unit The unit for which to retrieve the index. Any of the values defined by the
		///            \c UnitConstants enumeration is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MoveToUnitIndex, MoveInsertionPointByUnit, UnitConstants
		[propget, id(DISPID_TR_UNITINDEX), helpstring("Retrieves the one-based index of the specified unit (within the story) at the text range's start position. This property is read-only."), nonbrowsable]
		HRESULT UnitIndex([in] UnitConstants unit, [out, retval] LONG* pValue);
		/// \brief <em>Specifies the text range's associated URL</em>
		///
		/// Retrieves or sets the URL that is associated with the text range. It is used to turn arbitrary text
		/// into a hyperlink.
		///
		/// \remarks Requires Rich Edit 6.0 or newer.\n
		///          Transforming the link into normal text by setting the URL to an empty string requires Rich
		///          Edit 7.0 or newer.
		///
		/// \sa Text, RichText, IRichTextBox::AutoDetectURLs
		[propget, id(DISPID_TR_URL), helpstring("Retrieves or sets the URL that is associated with the text range. It is used to turn arbitrary text into a hyperlink. Requires Rich Edit 6.0 or newer."), nonbrowsable]
		HRESULT URL([out, retval] BSTR* pValue);
		[propput, id(DISPID_TR_URL), helpstring("Retrieves or sets the URL that is associated with the text range. It is used to turn arbitrary text into a hyperlink. Requires Rich Edit 6.0 or newer."), nonbrowsable]
		HRESULT URL([in] BSTR newValue);

		/// \brief <em>Changes the math in the text range from built-up form to linear format</em>
		///
		/// Modifies the representation of math in the text range.\n
		/// Math can be displayed in linear format, e.g. \c a=(b^2+c^2)/d, or it can be displayed in built-up
		/// form: \f$a=\frac{b^2+c^2}{d}\f$. This method changes from built-up form to linear format.
		///
		/// \param[in] flags Influences the build-down operation. Some combinations of the values defined by
		///            the \c BuildUpMathConstants enumeration are valid.
		///
		/// \return \c True, if the range has been changed; otherwise \c False.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa BuildUpMath, IRichTextBox::AllowMathZoneInsertion, IRichTextFont::IsMathZone,
		///     BuildUpMathConstants
		[id(DISPID_TR_BUILDDOWNMATH), helpstring("Modifies the representation of math in the text range. Requires Rich Edit 8.0 or newer.")]
		HRESULT BuildDownMath([in] BuildUpMathConstants flags, [out, retval] VARIANT_BOOL* pDidAnyChanges);
		/// \brief <em>Changes the math in the text range from linear format to built-up form</em>
		///
		/// Modifies the representation of math in the text range.\n
		/// Math can be displayed in linear format, e.g. \c a=(b^2+c^2)/d, or it can be displayed in built-up
		/// form: \f$a=\frac{b^2+c^2}{d}\f$. This method changes from linear format to built-up form, or it
		/// modifies the built-up form.
		///
		/// \param[in] flags Influences the build-up operation. Some combinations of the values defined by
		///            the \c BuildUpMathConstants enumeration are valid.
		///
		/// \return \c True, if the range has been changed; otherwise \c False.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa BuildDownMath, IRichTextBox::AllowMathZoneInsertion, IRichTextFont::IsMathZone,
		///     BuildUpMathConstants
		[id(DISPID_TR_BUILDUPMATH), helpstring("Modifies the representation of math in the text range. Requires Rich Edit 8.0 or newer.")]
		HRESULT BuildUpMath([in] BuildUpMathConstants flags, [out, retval] VARIANT_BOOL* pDidAnyChanges);
		/// \brief <em>Determines whether the content of the clipboard can be pasted to the text range</em>
		///
		/// Determines whether the content of the clipboard or a specific data object can be pasted to the
		/// text range, replacing its content.
		///
		/// \param[in] dataObject The \c OLEDataObject object from which to paste. If this parameter is not
		///            specified or does not refer to an object, the text will be pasted from the clipboard.
		/// \param[in] formatID An integer value specifying the format in which to paste the data. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.\n
		///            If set to \c 0, the format will be chosen automatically.
		///
		/// \return \c True, if the text can be pasted; otherwise \c False.
		///
		/// \sa Paste, Copy, Cut, Text, IOLEDataObject,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>
		[id(DISPID_TR_CANPASTE), helpstring("Determines whether the content of the clipboard or a specific data object can be pasted to the text range, replacing its content.")]
		HRESULT CanPaste([in, defaultvalue(0)] IOLEDataObject* dataObject, [in, defaultvalue(0)] LONG formatID, [out, retval] VARIANT_BOOL* pCanPaste);
		/// \brief <em>Changes the case of the letters in the text range</em>
		///
		/// \param[in] newCase The case to apply. Any of the values defined by the
		///            \c CaseConstants enumeration is valid.
		///
		/// \sa Text, CaseConstants
		[id(DISPID_TR_CHANGECASE), helpstring("Changes the case of the letters in the text range.")]
		HRESULT ChangeCase([in] CaseConstants newCase);
		/// \brief <em>Creates a new \c IRichTextRange instance with identical properties</em>
		///
		/// \return The new \c IRichTextRange instance.
		///
		/// \sa CopyRichTextFromTextRange, Equals
		[id(DISPID_TR_CLONE), helpstring("Creates a new 'TextRange' instance with identical properties.")]
		HRESULT Clone([out, retval] IRichTextRange** ppClone);
		/// \brief <em>Collapses the text range into a degenerate point at either end of the text range</em>
		///
		/// Collapses the text range into a degenerate point (insertion point) at either the beginning or end
		/// of the text range.
		///
		/// \param[in] collapseToStart If \c True, the text range is collapsed to its beginning, otherwise to
		///            its end.
		///
		/// \return \c True, if the range has been collapsed; otherwise \c False.
		///
		/// \sa ExpandToUnit, MoveStartToStartOfUnit, MoveEndToEndOfUnit
		[id(DISPID_TR_COLLAPSE), helpstring("Collapses the text range into a degenerate point (insertion point) at either the beginning or end of the text range.")]
		HRESULT Collapse([in, defaultvalue(-1)] VARIANT_BOOL collapseToStart, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Retrieves whether the text range contains another text range</em>
		///
		/// Retrieves whether the text range contains the specified text range.
		///
		/// \param[in] compareAgainst The \c IRichTextRange instance to compare with.
		///
		/// \return \c True, if the specified text range is contained by this text range; otherwise \c False.
		///
		/// \sa Equals
		[id(DISPID_TR_CONTAINSRANGE), helpstring("Retrieves whether the text range contains the specified text range.")]
		HRESULT ContainsRange([in] IRichTextRange* compareAgainst, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Copies the content of the text range to the clipboard</em>
		///
		/// Copies the text range's content to the clipboard or to a specific data object.
		///
		/// \param[out] dataObject Receives an \c OLEDataObject object, to which the text range's content will
		///             have been copied. If this parameter is not specified or does not refer to an object,
		///             the content will have been copied to the clipboard.
		///
		/// \return \c True, if the range has been copied; otherwise \c False.
		///
		/// \sa Cut, Paste, Text, IOLEDataObject
		[id(DISPID_TR_COPY), helpstring("Copies the text range's content to the clipboard or to a specific data object.")]
		HRESULT Copy([in, out, optional] VARIANT* dataObject, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Replaces the text range's content with the formatted (rich) text of another text range</em>
		///
		/// Replaces the text range's content with the content of another text range, including RTF control
		/// words for formatting.
		///
		/// \param[in] sourceObject The \c TextRange object from which to copy the content.
		///
		/// \return \c True, if the content has been copied; otherwise \c False.
		///
		/// \sa RichText, Copy
		[id(DISPID_TR_COPYRICHTEXTFROMTEXTRANGE), helpstring("Replaces the text range's content with the content of another text range, including RTF control words for formatting.")]
		HRESULT CopyRichTextFromTextRange([in] IRichTextRange* sourceObject, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Cuts the content of the text range to the clipboard</em>
		///
		/// Copies the text range's content to the clipboard or to a specific data object and deletes it from
		/// the control.
		///
		/// \param[out] dataObject Receives an \c OLEDataObject object, to which the text range's content will
		///             have been copied. If this parameter is not specified or does not refer to an object,
		///             the content will have been copied to the clipboard.
		///
		/// \return \c True, if the range has been cut; otherwise \c False.
		///
		/// \sa Copy, Paste, Text, IOLEDataObject
		[id(DISPID_TR_CUT), helpstring("Copies the text range's content to the clipboard or to a specific data object and deletes it from the control.")]
		HRESULT Cut([in, out, optional] VARIANT* dataObject, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Deletes text from the text range</em>
		///
		/// Mimics the [DEL] or [BACKSPACE] key deleting the specified number of units, e.g. the next 2 words,
		/// or the previous 3 characters.
		///
		/// \param[in] unit The unit by which to select the text to delete. Any of the values defined by the
		///            \c UnitConstants enumeration is valid.
		/// \param[in] Count The number of units to delete. If \c Count is greater than zero, the method acts
		///            as if the [DEL] key was pressed \c Count times. If \c Count is less than zero, the
		///            method acts as if the [BACKSPACE] key was pressed \c Count times. If \c Count is zero,
		///            the whole text in the range is deleted.
		///
		/// \return The actual number of units that has been deleted.
		///
		/// \sa Text, UnitIndex, UnitConstants
		[id(DISPID_TR_DELETE), helpstring("Mimics the [DEL] or [BACKSPACE] key deleting the specified number of units, e.g. the next 2 words, or the previous 3 characters.")]
		HRESULT Delete([in, defaultvalue(uCharacter)] UnitConstants unit, [in, defaultvalue(0)] LONG Count, [out, retval] LONG* pDelta);
		/// \brief <em>Retrieves whether two \c IRichTextRange instances have the same properties</em>
		///
		/// \param[in] compareAgainst The \c IRichTextRange instance to compare with.
		///
		/// \return \c True, if the objects have the same properties; otherwise \c False.
		///
		/// \remarks Properties that are set to 'undefined' are ignored.
		///
		/// \sa EqualsStory, Clone, ContainsRange
		[id(DISPID_TR_EQUALS), helpstring("Retrieves whether two 'TextRange' instances have the same properties.")]
		HRESULT Equals([in] IRichTextRange* compareAgainst, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Retrieves whether two \c IRichTextRange instances belong to the same story</em>
		///
		/// \param[in] compareAgainst The \c IRichTextRange instance to compare with.
		///
		/// \return \c True, if the objects belong to the same story; otherwise \c False.
		///
		/// \sa Equals
		[id(DISPID_TR_EQUALSSTORY), helpstring("Retrieves whether two 'TextRange' instances belong to the same story.")]
		HRESULT EqualsStory([in] IRichTextRange* compareAgainst, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Expand the text range's boundaries to include the specified overlapping unit</em>
		///
		/// Moves the start and/or end position of the text range to completely include the specified unit.
		///
		/// \param[in] unit The unit which to include in the text range. Any of the values defined by the
		///            \c UnitConstants enumeration is valid.
		///
		/// \return The count of characters that have been added to the text range.
		///
		/// \sa Collapse, MoveStartToStartOfUnit, MoveEndToEndOfUnit, UnitConstants
		[id(DISPID_TR_EXPANDTOUNIT), helpstring("Moves the start and/or end position of the text range to completely include the specified unit.")]
		HRESULT ExpandToUnit([in] UnitConstants unit, [out, retval] LONG* pDelta);
		/// \brief <em>Searches for the specified text and moves the text range to the match if found</em>
		///
		/// Moves the text range or one of its boundaries to the first occurance of the specified string. The
		/// method is able to search for text, words and regular expressions. The search can be limited to a
		/// specific range of text.
		///
		/// \param[in] searchFor The string to search for. Depending on the \c searchMode parameter, this
		///            string will be treated as plain text, as a word, or as a regular expression.
		/// \param[in] searchDirectionAndMaxCharsToPass Specifies whether to search forward, backward or within
		///            the text range only. Any of the values defined by the \c SearchDirectionConstants
		///            enumeration and any integer value is valid.\n
		///            If \c searchDirectionAndMaxCharsToPass is greater than zero, the search moves forward,
		///            toward the end of the story, and is aborted after this number of characters has been
		///            passed, starting at the text range's start position. If
		///            \c searchDirectionAndMaxCharsToPass is less than zero, the search moves backward, toward
		///            the beginning of the story, and is aborted after this number of characters has been
		///            passed, starting at the text range's start position.\n
		///            If \c searchDirectionAndMaxCharsToPass is \c sdWithinRange and the text range is
		///            degenerated (an insertion point), the search starts after the range and is not limited
		///            in its length. If \c searchDirectionAndMaxCharsToPass is \c sdWithinRange and the text
		///            range has a length greater than zero, the search is limited to the text range.
		/// \param[in] searchMode Specifies whether to perform a case-sensitive or case-insensitive search,
		///            whether to search for whole words, and whether to treat the search string as regular
		///            expression. Any combination of the values defined by the \c SearchModeConstants
		///            enumeration is valid.
		/// \param[in] moveRangeBoundaries Specifies which ends of the text range shall be moved to the match,
		///            in case a match is found. Any of the values defined by the
		///            \c MoveRangeBoundariesConstants enumeration is valid.
		///
		/// \return The length of the string that did match.
		///
		/// \sa Text, SearchDirectionConstants, SearchModeConstants, MoveRangeBoundariesConstants
		[id(DISPID_TR_FINDTEXT), helpstring("Moves the text range or one of its boundaries to the first occurance of the specified string. The method is able to search for text, words and regular expressions. The search can be limited to a specific range of text.")]
		HRESULT FindText([in] BSTR searchFor, [in, defaultvalue(sdForward)] SearchDirectionConstants searchDirectionAndMaxCharsToPass, [in, defaultvalue(smDefault)] SearchModeConstants searchMode, [in, defaultvalue(mrbMoveBoth)] MoveRangeBoundariesConstants moveRangeBoundaries, [out, retval] LONG* pLengthMatched);
		/// \brief <em>Retrieves the coordinates of the text range's end position</em>
		///
		/// Retrieves the coordinates of the text range's end position.
		///
		/// \param[in] horizontalPosition Specifies the horizontal position for which to retrieve the
		///            coordinates. Any of the values defined by the \c HorizontalPositionConstants enumeration
		///            is valid.
		/// \param[in] verticalPosition Specifies the vertical position for which to retrieve the coordinates.
		///            Any of the values defined by the \c VerticalPositionConstants enumeration is valid.
		/// \param[in] flags Controls the method's behavior. Any combination of the values defined by the
		///            \c RangePositionConstants enumeration is valid.
		/// \param[out] x Receives the x-coordinate (in twips) of the text range's end position relative to
		///             either the control's or the screen's upper-left corner, as specified by the \c flags
		///             parameter.
		/// \param[out] y Receives the y-coordinate (in twips) of the text range's end position relative to
		///             either the control's or the screen's upper-left corner, as specified by the \c flags
		///             parameter.
		///
		/// \return \c True, if the position could be retrieved; otherwise \c False.
		///
		/// \sa GetStartPosition, MoveEndToPosition, HorizontalPositionConstants, VerticalPositionConstants,
		///     RangePositionConstants
		[id(DISPID_TR_GETENDPOSITION), helpstring("Retrieves the coordinates of the text range's end position.")]
		HRESULT GetEndPosition([in] HorizontalPositionConstants horizontalPosition, [in] VerticalPositionConstants verticalPosition, [in] RangePositionConstants flags, [in, out] OLE_XPOS_PIXELS* x, [in, out] OLE_YPOS_PIXELS* y, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Retrieves the coordinates of the text range's start position</em>
		///
		/// Retrieves the coordinates of the text range's start position.
		///
		/// \param[in] horizontalPosition Specifies the horizontal position for which to retrieve the
		///            coordinates. Any of the values defined by the \c HorizontalPositionConstants enumeration
		///            is valid.
		/// \param[in] verticalPosition Specifies the vertical position for which to retrieve the coordinates.
		///            Any of the values defined by the \c VerticalPositionConstants enumeration is valid.
		/// \param[in] flags Controls the method's behavior. Any combination of the values defined by the
		///            \c RangePositionConstants enumeration is valid.
		/// \param[out] x Receives the x-coordinate (in twips) of the text range's end position relative to
		///             either the control's or the screen's upper-left corner, as specified by the \c flags
		///             parameter.
		/// \param[out] y Receives the y-coordinate (in twips) of the text range's end position relative to
		///             either the control's or the screen's upper-left corner, as specified by the \c flags
		///             parameter.
		///
		/// \return \c True, if the position could be retrieved; otherwise \c False.
		///
		/// \sa GetEndPosition, MoveStartToPosition, HorizontalPositionConstants, VerticalPositionConstants,
		///     RangePositionConstants
		[id(DISPID_TR_GETSTARTPOSITION), helpstring("Retrieves the coordinates of the text range's start position.")]
		HRESULT GetStartPosition([in] HorizontalPositionConstants horizontalPosition, [in] VerticalPositionConstants verticalPosition, [in] RangePositionConstants flags, [in, out] OLE_XPOS_PIXELS* x, [in, out] OLE_YPOS_PIXELS* y, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Retrieves whether the text range is located within a table</em>
		///
		/// Retrieves whether the text range is contained entirely by a table and returns the \c Table,
		/// \c TableRow, and \c TableCell object if applicable.
		///
		/// \param[out] Table Receives the \c IRichTable object that the text range lies within.
		/// \param[out] TableRow Receives the \c IRichTableRow object that the text range lies within.
		/// \param[out] TableCell Receives the \c IRichTableCell object that the text range lies within.
		///
		/// \return \c True, if the text range lies entirely within a table; otherwise \c False.
		///
		/// \sa ReplaceWithTable, IRichTable, IRichTableRow, IRichTableCell
		[id(DISPID_TR_ISWITHINTABLE), helpstring("Retrieves whether the text range lies entirely within a table.")]
		HRESULT IsWithinTable([in, out, optional] VARIANT* Table, [in, out, optional] VARIANT* TableRow, [in, out, optional] VARIANT* TableCell, [out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Moves the text range's end position by the specified number of the specified units</em>
		///
		/// Moves the text range's end position forward or backward by the specified number of units, e.g. by 2
		/// words forward. If the new end position precedes the old start position, the range is collapsed to
		/// an insertion point at the new end position.
		///
		/// \param[in] unit The unit by which to move. Any of the values defined by the \c UnitConstants
		///            enumeration is valid.
		/// \param[in] Count The number of units by which to move. If \c Count is greater than zero, motion
		///            is forward, toward the end of the story; if it is less than zero, motion is backward.
		///
		/// \return The actual number of units that the range's end position moved past.
		///
		/// \sa MoveStartByUnit, MoveInsertionPointByUnit, MoveEndUntil, MoveEndWhile, UnitConstants
		[id(DISPID_TR_MOVEENDBYUNIT), helpstring("Moves the text range's end position forward or backward by the specified number of units, e.g. by 2 words forward.")]
		HRESULT MoveEndByUnit([in] UnitConstants unit, [in] LONG Count, [out, retval] LONG* pDelta);
		/// \brief <em>Moves the text range's end to the end of the specified overlapping unit</em>
		///
		/// Moves the end position of the text range to the end of the last overlapping specified unit in the
		/// text range.
		///
		/// \param[in] unit The unit to which to move. Any of the values defined by the \c UnitConstants
		///            enumeration is valid.
		/// \param[in] doNotMoveStart If \c True, only the text range's end position is moved to the end of the
		///            specified unit, while the range's start position is not moved. If \c False, the text
		///            range is collapsed to the end of the specified unit, creating an insertion point.
		///
		/// \return The actual number of units that the range's end position has been moved past.
		///
		/// \sa MoveStartToStartOfUnit, ExpandToUnit, MoveToUnitIndex, MoveInsertionPointByUnit, UnitConstants
		[id(DISPID_TR_MOVEENDTOENDOFUNIT), helpstring("Moves the end position of the text range to the end of the last overlapping specified unit in the text range.")]
		HRESULT MoveEndToEndOfUnit([in] UnitConstants unit, [in] VARIANT_BOOL doNotMoveStart, [out, retval] LONG* pDelta);
		/// \brief <em>Moves the text range's end to the specified screen coordinates</em>
		///
		/// Moves the end position of the text range to the specified point or the nearest point with
		/// selectable text.
		///
		/// \param[in] x The x-coordinate (in twips) to which to move the text range's end position, relative
		///            to the screen's upper-left corner.
		/// \param[in] y The y-coordinate (in twips) to which to move the text range's end position, relative
		///            to the screen's upper-left corner.
		/// \param[in] doNotMoveStart If \c True, only the text range's end position is moved to the specified
		///            point, while the range's start position is not moved. If \c False, the text range is
		///            collapsed to the specified position, creating an insertion point.
		///
		/// \sa MoveStartToPosition, GetEndPosition
		[id(DISPID_TR_MOVEENDTOPOSITION), helpstring("Moves the end position of the text range to the specified point or the nearest point with selectable text.")]
		HRESULT MoveEndToPosition([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in] VARIANT_BOOL doNotMoveStart);
		/// \brief <em>Moves the text range's end position to the position of the first character found that is in the specified character set</em>
		///
		/// Moves the text range's end position forward or backward, to the position of the first character
		/// found that is in the set of characters specified by \c characterSet, provided that the character is
		/// found within \c maximumCharactersToPass characters of the range's end.\n
		/// If the new end position precedes the old start position, the range is collapsed to an insertion
		/// point at the new end position. If no character from the set specified by \c characterSet is found
		/// within \c maximumCharactersToPass positions of the range's end, the range is left unchanged.
		///
		/// \param[in] characterSet The character set to use in the match. This could be an explicit string of
		///            characters or a character-set index. For instance passing "0123456789" has the same
		///            effect as passing 4 (\c C1_DIGIT): The method finds the first digit.\n
		///            For more information see <a href="https://msdn.microsoft.com/en-us/library/bb787724.aspx#tom_character_match_sets">Character Match Sets</a>.
		/// \param[in] maximumCharactersToPass The maximum number of characters to move past. If
		///            \c maximumCharactersToPass is greater than zero, the search moves forward, toward the
		///            end of the story; if it is less than zero, the search moves backward.
		///
		/// \return The actual number of characters that the range's end position moved past, plus 1 for a
		///         match.
		///
		/// \sa MoveStartUntil, MoveInsertionPointUntil, MoveEndWhile, MoveEndByUnit
		[id(DISPID_TR_MOVEENDUNTIL), helpstring("Moves the text range's end position forward or backward, to the position of the first character found that is in the set of characters specified by 'characterSet'.")]
		HRESULT MoveEndUntil([in] VARIANT* characterSet, [in, defaultvalue(sdForward)] LONG maximumCharactersToPass, [out, retval] LONG* pDelta);
		/// \brief <em>Moves the text range's end position to the position of the first character found that is not in the specified character set</em>
		///
		/// Moves the text range's end position forward or backward, to the position of the first character
		/// found that is not in the set of characters specified by \c characterSet, or by
		/// \c maximumCharactersToPass characters, whichever is less.\n
		/// If the new end position precedes the old start position, the range is collapsed to an insertion
		/// point at the new end position.
		///
		/// \param[in] characterSet The character set to use in the match. This could be an explicit string of
		///            characters or a character-set index. For instance passing "0123456789" has the same
		///            effect as passing 4 (\c C1_DIGIT): The method finds the first digit.\n
		///            For more information see <a href="https://msdn.microsoft.com/en-us/library/bb787724.aspx#tom_character_match_sets">Character Match Sets</a>.
		/// \param[in] maximumCharactersToPass The maximum number of characters to move past. If
		///            \c maximumCharactersToPass is greater than zero, the search moves forward, toward the
		///            end of the story; if it is less than zero, the search moves backward.
		///
		/// \return The actual number of characters that the range's end position moved past.
		///
		/// \sa MoveStartWhile, MoveInsertionPointWhile, MoveEndUntil, MoveEndByUnit
		[id(DISPID_TR_MOVEENDWHILE), helpstring("Moves the text range's end position forward or backward, to the position of the first character found that is not in the set of characters specified by 'characterSet', or by 'maximumCharactersToPass' characters, whichever is less.")]
		HRESULT MoveEndWhile([in] VARIANT* characterSet, [in, defaultvalue(sdForward)] LONG maximumCharactersToPass, [out, retval] LONG* pDelta);
		/// \brief <em>Moves the insertion point by the specified number of the specified units</em>
		///
		/// Moves the insertion point forward or backward by the specified number of units, e.g. by 2 words
		/// forward. If the text range is nondegenerate (i.e. it is not an insertion point), it is collapsed to
		/// an insertion point at either end before it is moved.
		///
		/// \param[in] unit The unit by which to move. Any of the values defined by the \c UnitConstants
		///            enumeration is valid.
		/// \param[in] Count The number of units by which to move. If \c Count is greater than zero, motion
		///            is forward, toward the end of the story; if it is less than zero, motion is backward.
		///
		/// \return The actual number of units that the insertion point moved past.
		///
		/// \remarks The insertion point is never moved beyond the story boundaries.
		///
		/// \sa MoveStartByUnit, MoveEndByUnit, MoveToUnitIndex, MoveStartToStartOfUnit, MoveEndToEndOfUnit,
		///     UnitConstants
		[id(DISPID_TR_MOVEINSERTIONPOINTBYUNIT), helpstring("Moves the insertion point forward or backward by the specified number of units, e.g. by 2 words forward. The insertion point is never moved beyond the story boundaries.")]
		HRESULT MoveInsertionPointByUnit([in] UnitConstants unit, [in] LONG Count, [out, retval] LONG* pDelta);
		/// \brief <em>Moves the insertion point to the position of the first character found that is in the specified character set</em>
		///
		/// Moves the insertion point forward or backward, to the position of the first character found that is
		/// in the set of characters specified by \c characterSet, provided that the character is found within
		/// \c maximumCharactersToPass characters of the range's boundaries.\n
		/// If no character from the set specified by \c characterSet is found within
		/// \c maximumCharactersToPass positions of the range's boundaries, the range is left unchanged.
		///
		/// \param[in] characterSet The character set to use in the match. This could be an explicit string of
		///            characters or a character-set index. For instance passing "0123456789" has the same
		///            effect as passing 4 (\c C1_DIGIT): The method finds the first digit.\n
		///            For more information see <a href="https://msdn.microsoft.com/en-us/library/bb787724.aspx#tom_character_match_sets">Character Match Sets</a>.
		/// \param[in] maximumCharactersToPass The maximum number of characters to move past. If
		///            \c maximumCharactersToPass is greater than zero, the search moves forward starting at
		///            the text range's end position, toward the end of the story; if it is less than zero, the
		///            search moves backward starting at the text range's start position.
		///
		/// \return The actual number of characters that the insertion point moved past, plus 1 for a match.
		///
		/// \sa MoveStartUntil, MoveEndUntil, MoveInsertionPointWhile, MoveInsertionPointByUnit
		[id(DISPID_TR_MOVEINSERTIONPOINTUNTIL), helpstring("Moves the insertion point forward or backward, to the position of the first character found that is in the set of characters specified by 'characterSet'.")]
		HRESULT MoveInsertionPointUntil([in] VARIANT* characterSet, [in, defaultvalue(sdForward)] LONG maximumCharactersToPass, [out, retval] LONG* pDelta);
		/// \brief <em>Moves the insertion point to the position of the first character found that is not in the specified character set</em>
		///
		/// Moves the insertion point forward or backward, to the position of the first character found that is
		/// not in the set of characters specified by \c characterSet, or by \c maximumCharactersToPass
		/// characters, whichever is less.
		///
		/// \param[in] characterSet The character set to use in the match. This could be an explicit string of
		///            characters or a character-set index. For instance passing "0123456789" has the same
		///            effect as passing 4 (\c C1_DIGIT): The method finds the first digit.\n
		///            For more information see <a href="https://msdn.microsoft.com/en-us/library/bb787724.aspx#tom_character_match_sets">Character Match Sets</a>.
		/// \param[in] maximumCharactersToPass The maximum number of characters to move past. If
		///            \c maximumCharactersToPass is greater than zero, the search moves forward starting at
		///            the text range's end position, toward the end of the story; if it is less than zero, the
		///            search moves backward starting at the text range's start position.
		///
		/// \return The actual number of characters that the insertion point moved past.
		///
		/// \sa MoveStartWhile, MoveEndWhile, MoveInsertionPointUntil, MoveInsertionPointByUnit
		[id(DISPID_TR_MOVEINSERTIONPOINTWHILE), helpstring("Moves the insertion point forward or backward, to the position of the first character found that is not in the set of characters specified by 'characterSet', or by 'maximumCharactersToPass' characters, whichever is less.")]
		HRESULT MoveInsertionPointWhile([in] VARIANT* characterSet, [in, defaultvalue(sdForward)] LONG maximumCharactersToPass, [out, retval] LONG* pDelta);
		/// \brief <em>Moves the text range's start position by the specified number of the specified units</em>
		///
		/// Moves the text range's start position forward or backward by the specified number of units, e.g. by
		/// 2 words backward. If the new start position follows the old end position, the range is collapsed to
		/// an insertion point at the new start position.
		///
		/// \param[in] unit The unit by which to move. Any of the values defined by the \c UnitConstants
		///            enumeration is valid.
		/// \param[in] Count The number of units by which to move. If \c Count is greater than zero, motion
		///            is forward, toward the end of the story; if it is less than zero, motion is backward.
		///
		/// \return The actual number of units that the range's start position moved past.
		///
		/// \sa MoveEndByUnit, MoveInsertionPointByUnit, MoveStartUntil, MoveStartWhile, UnitConstants
		[id(DISPID_TR_MOVESTARTBYUNIT), helpstring("Moves the text range's start position forward or backward by the specified number of units, e.g. by 2 words backward.")]
		HRESULT MoveStartByUnit([in] UnitConstants unit, [in] LONG Count, [out, retval] LONG* pDelta);
		/// \brief <em>Moves the text range's start to the specified screen coordinates</em>
		///
		/// Moves the start position of the text range to the specified point or the nearest point with
		/// selectable text.
		///
		/// \param[in] x The x-coordinate (in twips) to which to move the text range's start position, relative
		///            to the screen's upper-left corner.
		/// \param[in] y The y-coordinate (in twips) to which to move the text range's start position, relative
		///            to the screen's upper-left corner.
		/// \param[in] doNotMoveEnd If \c True, only the text range's start position is moved to the specified
		///            point, while the range's end position is not moved. If \c False, the text range is
		///            collapsed to the specified position, creating an insertion point.
		///
		/// \sa MoveEndToPosition, GetStartPosition
		[id(DISPID_TR_MOVESTARTTOPOSITION), helpstring("Moves the start position of the text range to the specified point or the nearest point with selectable text.")]
		HRESULT MoveStartToPosition([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in] VARIANT_BOOL doNotMoveEnd);
		/// \brief <em>Moves the text range's start to the start of the specified overlapping unit</em>
		///
		/// Moves the start position of the text range to the start of the first overlapping specified unit in
		/// the text range.
		///
		/// \param[in] unit The unit to which to move. Any of the values defined by the \c UnitConstants
		///            enumeration is valid.
		/// \param[in] doNotMoveEnd If \c True, only the text range's start position is moved to the start of
		///            the specified unit, while the range's end position is not moved. If \c False, the text
		///            range is collapsed to the start of the specified unit, creating an insertion point.
		///
		/// \return The actual number of units that the range's start position has been moved past.
		///
		/// \sa MoveEndToEndOfUnit, ExpandToUnit, MoveToUnitIndex, MoveInsertionPointByUnit, UnitConstants
		[id(DISPID_TR_MOVESTARTTOSTARTOFUNIT), helpstring("Moves the start position of the text range to the start of the last overlapping specified unit in the text range.")]
		HRESULT MoveStartToStartOfUnit([in] UnitConstants unit, [in] VARIANT_BOOL doNotMoveEnd, [out, retval] LONG* pDelta);
		/// \brief <em>Moves the text range's start position to the position of the first character found that is in the specified character set</em>
		///
		/// Moves the text range's start position forward or backward, to the position of the first character
		/// found that is in the set of characters specified by \c characterSet, provided that the character is
		/// found within \c maximumCharactersToPass characters of the range's start.\n
		/// If the new start position follows the old end position, the range is collapsed to an insertion
		/// point at the new start position. If no character from the set specified by \c characterSet is found
		/// within \c maximumCharactersToPass positions of the range's start, the range is left unchanged.
		///
		/// \param[in] characterSet The character set to use in the match. This could be an explicit string of
		///            characters or a character-set index. For instance passing "0123456789" has the same
		///            effect as passing 4 (\c C1_DIGIT): The method finds the first digit.\n
		///            For more information see <a href="https://msdn.microsoft.com/en-us/library/bb787724.aspx#tom_character_match_sets">Character Match Sets</a>.
		/// \param[in] maximumCharactersToPass The maximum number of characters to move past. If
		///            \c maximumCharactersToPass is greater than zero, the search moves forward, toward the
		///            end of the story; if it is less than zero, the search moves backward.
		///
		/// \return The actual number of characters that the range's start position moved past, plus 1 for a
		///         match.
		///
		/// \sa MoveEndUntil, MoveInsertionPointUntil, MoveStartWhile, MoveStartByUnit
		[id(DISPID_TR_MOVESTARTUNTIL), helpstring("Moves the text range's start position forward or backward, to the position of the first character found that is in the set of characters specified by 'characterSet'.")]
		HRESULT MoveStartUntil([in] VARIANT* characterSet, [in, defaultvalue(sdForward)] LONG maximumCharactersToPass, [out, retval] LONG* pDelta);
		/// \brief <em>Moves the text range's start position to the position of the first character found that is not in the specified character set</em>
		///
		/// Moves the text range's start position forward or backward, to the position of the first character
		/// found that is not in the set of characters specified by \c characterSet, or by
		/// \c maximumCharactersToPass characters, whichever is less.\n
		/// If the new start position follows the old end position, the range is collapsed to an insertion
		/// point at the new start position.
		///
		/// \param[in] characterSet The character set to use in the match. This could be an explicit string of
		///            characters or a character-set index. For instance passing "0123456789" has the same
		///            effect as passing 4 (\c C1_DIGIT): The method finds the first digit.\n
		///            For more information see <a href="https://msdn.microsoft.com/en-us/library/bb787724.aspx#tom_character_match_sets">Character Match Sets</a>.
		/// \param[in] maximumCharactersToPass The maximum number of characters to move past. If
		///            \c maximumCharactersToPass is greater than zero, the search moves forward, toward the
		///            end of the story; if it is less than zero, the search moves backward.
		///
		/// \return The actual number of characters that the range's start position moved past.
		///
		/// \sa MoveEndWhile, MoveInsertionPointWhile, MoveStartUntil, MoveStartByUnit
		[id(DISPID_TR_MOVESTARTWHILE), helpstring("Moves the text range's start position forward or backward, to the position of the first character found that is not in the set of characters specified by 'characterSet', or by 'maximumCharactersToPass' characters, whichever is less.")]
		HRESULT MoveStartWhile([in] VARIANT* characterSet, [in, defaultvalue(sdForward)] LONG maximumCharactersToPass, [out, retval] LONG* pDelta);
		/// \brief <em>Changes the range to the x-th unit of the current story</em>
		///
		/// Relocates the text range to the specified unit that has the specified index number, e.g. to the
		/// third word from the start of the story, or to the second word from the end of the story.
		///
		/// \param[in] unit The unit used to index the range. Any of the values defined by the \c UnitConstants
		///            enumeration is valid.
		/// \param[in] Index The one-based index of the unit. If \c Index is greater than zero, the numbering
		///            of units begins at the start of the story and proceeds forward; if it is less than zero,
		///            the numbering begins at the end of the story and proceeds backward.
		/// \param[in] setRangeToEntireUnit If \c True, the range is set to the entire unit; otherwise it is
		///            collapsed to an insertion point at the start position of the unit.
		///
		/// \return \c True, if the text range has been relocated successfully; otherwise \c False.
		///
		/// \remarks The text range is never moved beyond the story boundaries.
		///
		/// \sa MoveInsertionPointByUnit, MoveStartToStartOfUnit, MoveEndToEndOfUnit, UnitIndex, UnitConstants
		[id(DISPID_TR_MOVETOUNITINDEX), helpstring("Relocates the text range to the specified unit that has the specified index number, e.g. to the third word from the start of the story, or to the second word from the end of the story. The text range is never moved beyond the story boundaries.")]
		HRESULT MoveToUnitIndex([in] UnitConstants unit, [in] LONG Index, [in, defaultvalue(0)] VARIANT_BOOL setRangeToEntireUnit, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Replaces the content of the text range with the content of the clipboard</em>
		///
		/// Pastes text from the clipboard or a specific data object, replacing the text range's current
		/// content.
		///
		/// \param[in] dataObject The \c OLEDataObject object from which to paste. If this parameter is not
		///            specified or does not refer to an object, the text will be pasted from the clipboard.
		/// \param[in] formatID An integer value specifying the format in which to paste the data. Valid values
		///            are those defined by VB's \c ClipBoardConstants enumeration, but also any other format
		///            that has been registered using the \c RegisterClipboardFormat API function.\n
		///            If set to \c 0, the format will be chosen automatically.
		///
		/// \return \c True, if the text has been pasted; otherwise \c False.
		///
		/// \sa CanPaste, Copy, Cut, Text, IOLEDataObject,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>
		[id(DISPID_TR_PASTE), helpstring("Pastes text from the clipboard or a specific data object, replacing the text range's current content.")]
		HRESULT Paste([in, defaultvalue(0)] IOLEDataObject* dataObject, [in, defaultvalue(0)] LONG formatID, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Inserts a table</em>
		///
		/// Replaces the text range with a table and returns a \c Table object wrapping the inserted table.
		///
		/// \param[in] columnCount The number of columns that the table will have. A maximum of 63 columns is
		///            supported.
		/// \param[in] rowCount The number of rows that the table will have.
		/// \param[in] allowIndividualCellStyles If set to \c True, each table cell can be styled individually;
		///            otherwise all cells in a row will have the same style. This refers to cell properties
		///            like margins, vertical alignments etc. Individual font styling (e.g. colors, bold,
		///            italics) always is possible, regardless of this setting.
		/// \param[in] borderSize The width (in twips) of the cell borders. If set to -1, the width of 1 pixel
		///            will be used.
		/// \param[in] horizontalRowAlignment The horizontal alignment of the table rows. The following of the
		///            values defined by the \c HAlignmentConstants enumeration are valid: \c halLeft,
		///            \c halCenter, \c halRight.
		/// \param[in] verticalCellAlignment The vertical alignment of the cells' content within the table
		///            cell. Any of the values defined by the \c VAlignmentConstants enumeration is valid.
		/// \param[in] rowIndent The size (in twips) by which the table rows are indented horizontally. The
		///            indent is measured from the control's left border.
		/// \param[in] columnWidth The width (in twips) of each column. If set to -1, the columns are sized
		///            evenly over the available space.
		/// \param[in] horizontalCellMargin The size (in twips) of the left and right margin in each cell. If
		///            set to -1, the default margin is used.
		/// \param[in] rowHeight The height (in twips) of each row. If set to -1, the default height is used.
		///
		/// \return The inserted table.
		///
		/// \sa IRichTextBox::AllowTableInsertion, IRichTextBox::DisplayZeroWidthTableCellBorders, IRichTable,
		///     HAlignmentConstants, VAlignmentConstants
		[id(DISPID_TR_REPLACEWITHTABLE), helpstring("Replaces the text range with a table.")]
		HRESULT ReplaceWithTable([in] LONG columnCount, [in] LONG rowCount, [in, defaultvalue(-1)] VARIANT_BOOL allowIndividualCellStyles, [in, defaultvalue(-1)] SHORT borderSize, [in, defaultvalue(halLeft)] HAlignmentConstants horizontalRowAlignment, [in, defaultvalue(valCenter)] VAlignmentConstants verticalCellAlignment, [in, defaultvalue(-1)] LONG rowIndent, [in, defaultvalue(-1)] LONG columnWidth, [in, defaultvalue(-1)] LONG horizontalCellMargin, [in, defaultvalue(-1)] LONG rowHeight, [out, retval] IRichTable** ppAddedTable);
		/// \brief <em>Scrolls the text range into view</em>
		///
		/// \param[in] flags A value controlling which part of the range is scrolled into view. Some
		///            combinations of the values defined by the \c ScrollIntoViewConstants enumeration
		///            is valid.
		///
		/// \sa ScrollIntoViewConstants
		[id(DISPID_TR_SCROLLINTOVIEW), helpstring("Scrolls the text range into view.")]
		HRESULT ScrollIntoView([in, defaultvalue(sivScrollRangeStartToTop)] ScrollIntoViewConstants flags);
		/// \brief <em>Selects the current range of text</em>
		///
		/// \sa IRichTextBox::SelectedTextRange
		[id(DISPID_TR_SELECT), helpstring("Selects the current range of text.")]
		HRESULT Select(void);
		/// \brief <em>Sets the text range's start and end</em>
		///
		/// Sets the text range's start and end. The range's start position will be set to the minimum of
		/// \c anchorEnd and \c activeEnd; the range's end position will be set to the maximum.
		///
		/// \param[in] anchorEnd The character position of the anchor end of the text range.
		/// \param[in] activeEnd The character position of the active end of the text range.
		///
		/// \sa RangeStart, RangeEnd
		[id(DISPID_TR_SETSTARTANDEND), helpstring("Sets the text range's start and end.")]
		HRESULT SetStartAndEnd([in] LONG anchorEnd, [in] LONG activeEnd);
	}


	/// \interface _IRichTextRangeEvents
	/// \brief <em>The \c TextRange class' events interface</em>
	///
	/// This interface defines all events the \c TextRange class may raise.
	///
	/// \sa IRichTextRange
	[
		uuid(9D715EE0-B59E-4476-9F7C-9928B669AF6E),
		helpstring("IRichTextRange-event-interface")
	]
	dispinterface _IRichTextRangeEvents
	{
		properties:
		methods:
	};


	/// \brief <em>The \c TextRange class</em>
	///
	/// This COM class implements the \c IRichTextRange and \c _IRichTextRangeEvents interfaces.
	///
	/// \sa IRichTextRange, _IRichTextRangeEvents, RichTextBox
	[
		uuid(34F1949F-2CA8-4A4D-B1C1-CEA7AD5EFAB6),
		version(1.0),
		noncreatable,
		helpstring("TextRange Class 1.0 (ANSI)")
	]
	coclass TextRange
	{
		[default] interface IRichTextRange;
		[default, source] dispinterface _IRichTextRangeEvents;
	};


	/// \interface IRichTextBox
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The main interface</em>
	///
	/// This is the RichTextBox control's main interface. It wraps the control window.
	///
	/// \sa _IRichTextBoxEvents
	[
		object,
		uuid(3B493AAC-4714-43C3-BB37-E954DD27AA9F),
		dual,
		nonextensible,
		helpstring("IRichTextBox interface"),
		pointer_default(unique)
	]
	interface IRichTextBox : IDispatch
	{
		/// \brief <em>Specifies whether the control processes the [TAB] key</em>
		///
		/// Retrieves or sets whether pressing the [TAB] key inserts a tabulator into the control. If set to
		/// \c True, a tabulator is inserted; otherwise the keyboard focus is transfered to the next control.
		///
		/// \sa TabStops, TabWidth, Text, _IRichTextBoxEvents::KeyDown
		[propget, id(DISPID_RTB_ACCEPTTABKEY), helpstring("Retrieves or sets whether pressing the [TAB] key inserts a tabulator into the control.")]
		HRESULT AcceptTabKey([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_ACCEPTTABKEY), helpstring("Retrieves or sets whether pressing the [TAB] key inserts a tabulator into the control.")]
		HRESULT AcceptTabKey([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the line height is increased for east-asian text</em>
		///
		/// Retrieves or sets whether the line height is increased by 15%, if the line contains text in an
		/// east-asian language. If set to \c True, the line height is increased; otherwise not.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.
		///
		/// \sa IRichTextParagraph::LineSpacingRule, IRichTextParagraph::SpaceBefore,
		///     IRichTextParagraph::SpaceAfter
		[propget, id(DISPID_RTB_ADJUSTLINEHEIGHTFOREASTASIANLANGUAGES), helpstring("Retrieves or sets whether the line height is increased by 15%, if the line contains text in an east-asian language. Requires Rich Edit 7.5 or newer.")]
		HRESULT AdjustLineHeightForEastAsianLanguages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_ADJUSTLINEHEIGHTFOREASTASIANLANGUAGES), helpstring("Retrieves or sets whether the line height is increased by 15%, if the line contains text in an east-asian language. Requires Rich Edit 7.5 or newer.")]
		HRESULT AdjustLineHeightForEastAsianLanguages([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether text can be inserted using TSF</em>
		///
		/// Retrieves or sets whether it is possible to insert text using Windows Text Services Framework
		/// (TSF). If set to \c True, text can be inserted through TSF; otherwise not.
		///
		/// \remarks Usually input is disabled only temporarily to make sure the control's content is not
		///          locked by TSF.\n
		///          Requires Rich Edit 7.5 or newer.
		///
		/// \sa AllowObjectInsertionThroughTSF, UseTextServicesFramework, IMEMode
		[propget, id(DISPID_RTB_ALLOWINPUTTHROUGHTSF), helpstring("Retrieves or sets whether it is possible to insert text using Windows Text Services Framework (TSF). Usually input is disabled only temporarily to make sure the control's content is not locked by TSF. Requires Rich Edit 7.5 or newer.")]
		HRESULT AllowInputThroughTSF([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_ALLOWINPUTTHROUGHTSF), helpstring("Retrieves or sets whether it is possible to insert text using Windows Text Services Framework (TSF). Usually input is disabled only temporarily to make sure the control's content is not locked by TSF. Requires Rich Edit 7.5 or newer.")]
		HRESULT AllowInputThroughTSF([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether math zones can be inserted</em>
		///
		/// Retrieves or sets whether it is possible to insert math zones, i.e. paragraphs that contain
		/// formulas. If set to \c True, math zones can be inserted; otherwise not.
		///
		/// \remarks This property can be changed only before inserting any math zone.\n
		///          Requires Rich Edit 8.0 or newer.
		///
		/// \sa IRichTextRange::BuildUpMath, IRichTextFont::IsMathZone
		[propget, id(DISPID_RTB_ALLOWMATHZONEINSERTION), helpstring("Retrieves or sets whether it is possible to insert math zones, i.e. paragraphs that contain formulas. This property can be changed only before inserting any math zone. Requires Rich Edit 8.0 or newer.")]
		HRESULT AllowMathZoneInsertion([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_ALLOWMATHZONEINSERTION), helpstring("Retrieves or sets whether it is possible to insert math zones, i.e. paragraphs that contain formulas. This property can be changed only before inserting any math zone. Requires Rich Edit 8.0 or newer.")]
		HRESULT AllowMathZoneInsertion([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether embedded objects can be inserted using TSF</em>
		///
		/// Retrieves or sets whether it is possible to insert embedded objects using Windows Text Services
		/// Framework (TSF). If set to \c True, embedded objects can be inserted through TSF; otherwise not.
		///
		/// \sa AllowInputThroughTSF, UseTextServicesFramework, IMEMode
		[propget, id(DISPID_RTB_ALLOWOBJECTINSERTIONTHROUGHTSF), helpstring("Retrieves or sets whether it is possible to insert embedded objects using Windows Text Services Framework (TSF).")]
		HRESULT AllowObjectInsertionThroughTSF([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_ALLOWOBJECTINSERTIONTHROUGHTSF), helpstring("Retrieves or sets whether it is possible to insert embedded objects using Windows Text Services Framework (TSF).")]
		HRESULT AllowObjectInsertionThroughTSF([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether tables can be inserted</em>
		///
		/// Retrieves or sets whether it is possible to insert tables. If set to \c True, tables can be
		/// inserted; otherwise not.
		///
		/// \remarks This property can be changed only before inserting any table.\n
		///          Requires Rich Edit 7.5 or newer.
		///
		/// \sa IRichTextRange::ReplaceWithTable
		[propget, id(DISPID_RTB_ALLOWTABLEINSERTION), helpstring("Retrieves or sets whether it is possible to insert tables. This property can be changed only before inserting any table. Requires Rich Edit 7.5 or newer.")]
		HRESULT AllowTableInsertion([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_ALLOWTABLEINSERTION), helpstring("Retrieves or sets whether it is possible to insert tables. This property can be changed only before inserting any table. Requires Rich Edit 7.5 or newer.")]
		HRESULT AllowTableInsertion([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether TSF is allowed to display proofing tips</em>
		///
		/// Retrieves or sets whether Windows Text Services Framework (TSF) may display proofing tips. If set
		/// to \c True, proofing tips are allowed; otherwise not.
		///
		/// \sa AllowTSFSmartTags, UseTextServicesFramework
		[propget, id(DISPID_RTB_ALLOWTSFPROOFINGTIPS), helpstring("Retrieves or sets whether Windows Text Services Framework (TSF) may display proofing tips.")]
		HRESULT AllowTSFProofingTips([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_ALLOWTSFPROOFINGTIPS), helpstring("Retrieves or sets whether Windows Text Services Framework (TSF) may display proofing tips.")]
		HRESULT AllowTSFProofingTips([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether TSF is allowed to display SmartTag tips</em>
		///
		/// Retrieves or sets whether Windows Text Services Framework (TSF) may display SmartTag tips. If set
		/// to \c True, SmartTag tips are allowed; otherwise not.
		///
		/// \sa AllowTSFProofingTips, UseTextServicesFramework
		[propget, id(DISPID_RTB_ALLOWTSFSMARTTAGS), helpstring("Retrieves or sets whether Windows Text Services Framework (TSF) may display SmartTag tips.")]
		HRESULT AllowTSFSmartTags([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_ALLOWTSFSMARTTAGS), helpstring("Retrieves or sets whether Windows Text Services Framework (TSF) may display SmartTag tips.")]
		HRESULT AllowTSFSmartTags([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the visibility of the scroll bars</em>
		///
		/// Retrieves or sets whether the scroll bars are disabled instead of hidden if not needed. If set to
		/// \c True, the scroll bars are disabled; otherwise they are hidden.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa ScrollBars
		[propget, id(DISPID_RTB_ALWAYSSHOWSCROLLBARS), helpstring("Retrieves or sets whether the scroll bars are disabled instead of hidden if not needed. Changing this property destroys and recreates the control window.")]
		HRESULT AlwaysShowScrollBars([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_ALWAYSSHOWSCROLLBARS), helpstring("Retrieves or sets whether the scroll bars are disabled instead of hidden if not needed. Changing this property destroys and recreates the control window.")]
		HRESULT AlwaysShowScrollBars([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls how selected text is displayed</em>
		///
		/// Retrieves or sets whether the selected text will be highlighted even if the control doesn't
		/// have the focus. If set to \c True, selected text is drawn as selected if the control does not
		/// have the focus; otherwise it's drawn as normal text.
		///
		/// \sa Text
		[propget, id(DISPID_RTB_ALWAYSSHOWSELECTION), helpstring("Retrieves or sets whether the selected text will be highlighted even if the control doesn't have the focus.")]
		HRESULT AlwaysShowSelection([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_ALWAYSSHOWSELECTION), helpstring("Retrieves or sets whether the selected text will be highlighted even if the control doesn't have the focus.")]
		HRESULT AlwaysShowSelection([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the style of the control's outer border</em>
		///
		/// Retrieves or sets the kind of border that is drawn around the control. Any of the values defined
		/// by the \c AppearanceConstants enumeration except \c aDefault is valid.
		///
		/// \sa BorderStyle, UseWindowsThemes, AppearanceConstants
		[propget, id(DISPID_RTB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([out, retval] AppearanceConstants* pValue);
		[propput, id(DISPID_RTB_APPEARANCE), helpstring("Retrieves or sets the kind of border that is drawn around the control.")]
		HRESULT Appearance([in] AppearanceConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application ID</em>
		///
		///   Retrieves the control's application ID. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppName, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RTB_APPID), hidden]
		HRESULT AppID([out, retval] SHORT* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's application name</em>
		///
		///   Retrieves the control's application name. This property is part of the fingerprint that
		///   uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppShortName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RTB_APPNAME), hidden]
		HRESULT AppName([out, retval] BSTR* pValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's short application name</em>
		///
		///   Retrieves the control's short application name. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, Build, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RTB_APPSHORTNAME), hidden]
		HRESULT AppShortName([out, retval] BSTR* pValue);
		/// \brief <em>Controls automatic detection of links in the user input</em>
		///
		/// Retrieves or sets the URL schemes recognized if the \c AutoDetectURLs property contains the
		/// \c aduURLs flag. If set to an empty string, the system's default scheme name list is used.\n
		/// The schemes have to include the colon (":") and are simply concatenated, e.g.
		/// "news:http:ftp:telnet:".
		///
		/// \sa AutoDetectURLs, IRichTextRange::URL
		[propget, id(DISPID_RTB_AUTODETECTEDURLSCHEMES), helpstring("Retrieves or sets the URL schemes recognized if the 'AutoDetectURLs' property contains the 'aduURLs' flag. If set to an empty string, the system's default scheme name list is used.")]
		HRESULT AutoDetectedURLSchemes([out, retval] BSTR* pValue);
		[propput, id(DISPID_RTB_AUTODETECTEDURLSCHEMES), helpstring("Retrieves or sets the URL schemes recognized if the 'AutoDetectURLs' property contains the 'aduURLs' flag. If set to an empty string, the system's default scheme name list is used.")]
		HRESULT AutoDetectedURLSchemes([in] BSTR newValue);
		/// \brief <em>Controls automatic detection of links in the user input</em>
		///
		/// Retrieves or sets whether and how the user input is parsed to detect URLs, email addresses, phone
		/// numbers etc. If such content is found in the user input, it is formatted accordingly. Any
		/// combination of the values defined by the \c AutoDetectURLsConstants enumeration is valid.
		///
		/// \sa AutoDetectedURLSchemes, DisplayHyperlinkTooltips, IRichTextRange::URL, AutoDetectURLsConstants
		[propget, id(DISPID_RTB_AUTODETECTURLS), helpstring("Retrieves or sets whether and how the user input is parsed to detect URLs, email addresses, phone numbers etc. If such content is found in the user input, it is formatted accordingly."), nonbrowsable]
		HRESULT AutoDetectURLs([out, retval] AutoDetectURLsConstants* pValue);
		[propput, id(DISPID_RTB_AUTODETECTURLS), helpstring("Retrieves or sets whether and how the user input is parsed to detect URLs, email addresses, phone numbers etc. If such content is found in the user input, it is formatted accordingly."), nonbrowsable]
		HRESULT AutoDetectURLs([in] AutoDetectURLsConstants newValue);
		/// \brief <em>Controls the control's automatic scrolling features</em>
		///
		/// Retrieves or sets the directions into which the control scrolls automatically, if the caret reaches
		/// the borders of the control's client area. Any combination of the values defined by the
		/// \c AutoScrollingConstants enumeration is valid.
		///
		/// \sa ScrollBars, MultiLine, _IRichTextBoxEvents::TruncatedText, AutoScrollingConstants
		[propget, id(DISPID_RTB_AUTOSCROLLING), helpstring("Retrieves or sets the directions into which the control scrolls automatically, if the caret reaches the borders of the control's client area.")]
		HRESULT AutoScrolling([out, retval] AutoScrollingConstants* pValue);
		[propput, id(DISPID_RTB_AUTOSCROLLING), helpstring("Retrieves or sets the directions into which the control scrolls automatically, if the caret reaches the borders of the control's client area.")]
		HRESULT AutoScrolling([in] AutoScrollingConstants newValue);
		/// \brief <em>Specifies whether selection by mouse selects whole words</em>
		///
		/// Retrieves or sets whether whole words are selected, if the user selects text using the mouse.
		/// If set to \c True, track-selection selects whole words; otherwise the selection ends at the current
		/// mouse position which can be within a word.
		///
		/// \sa DropWordsOnWordBoundariesOnly, _IRichTextBoxEvents::DblClick
		[propget, id(DISPID_RTB_AUTOSELECTWORDONTRACKSELECTION), helpstring("Retrieves or sets whether whole words are selected, if the user selects text using the mouse.")]
		HRESULT AutoSelectWordOnTrackSelection([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_AUTOSELECTWORDONTRACKSELECTION), helpstring("Retrieves or sets whether whole words are selected, if the user selects text using the mouse.")]
		HRESULT AutoSelectWordOnTrackSelection([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the control's background color</em>
		///
		/// Retrieves or sets the control's background color.
		///
		/// \sa IRichTextFont::BackColor
		[propget, id(DISPID_RTB_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_RTB_BACKCOLOR), helpstring("Retrieves or sets the control's background color.")]
		HRESULT BackColor([in] OLE_COLOR newValue);
		/// \brief <em>Controls whether the system beeps if the control's maximum text length is reached</em>
		///
		/// Retrieves or sets whether the control plays the system beep sound if the user tries to enter more
		/// characters than allowed by the \c MaxTextLength property. If set to \c True, the system beep is
		/// played; otherwise not.
		///
		/// \sa MaxTextLength
		[propget, id(DISPID_RTB_BEEPONMAXTEXT), helpstring("Retrieves or sets whether the control plays the system beep sound if the user tries to enter more characters than allowed by the 'MaxTextLength' property.")]
		HRESULT BeepOnMaxText([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_BEEPONMAXTEXT), helpstring("Retrieves or sets whether the control plays the system beep sound if the user tries to enter more characters than allowed by the 'MaxTextLength' property.")]
		HRESULT BeepOnMaxText([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the style of the control's inner border</em>
		///
		/// Retrieves or sets the kind of inner border that is drawn around the control. Any of the values
		/// defined by the \c BorderStyleConstants enumeration is valid.
		///
		/// \sa Appearance, UseWindowsThemes, BorderStyleConstants
		[propget, id(DISPID_RTB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([out, retval] BorderStyleConstants* pValue);
		[propput, id(DISPID_RTB_BORDERSTYLE), helpstring("Retrieves or sets the kind of inner border that is drawn around the control.")]
		HRESULT BorderStyle([in] BorderStyleConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's build number</em>
		///
		///   Retrieves the control's build number. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa Version, AppID, AppName, AppShortName, CharSet, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RTB_BUILD), hidden]
		HRESULT Build([out, retval] LONG* pValue);
		/// \brief <em>Controls the control's automatic character conversion features</em>
		///
		/// Retrieves or sets the kind of conversion that is applied to characters that are typed into the
		/// control. Any of the values defined by the \c CharacterConversionConstants enumeration is valid.
		///
		/// \sa Text, CharacterConversionConstants
		[propget, id(DISPID_RTB_CHARACTERCONVERSION), helpstring("Retrieves or sets the kind of conversion that is applied to characters that are typed into the control.")]
		HRESULT CharacterConversion([out, retval] CharacterConversionConstants* pValue);
		[propput, id(DISPID_RTB_CHARACTERCONVERSION), helpstring("Retrieves or sets the kind of conversion that is applied to characters that are typed into the control.")]
		HRESULT CharacterConversion([in] CharacterConversionConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's character set</em>
		///
		///   Retrieves the control's character set (Unicode or ANSI). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, IsRelease, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RTB_CHARSET), hidden]
		HRESULT CharSet([out, retval] BSTR* pValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves the control's current IME composition mode. IME (Input Method Editor) is a Windows
		/// feature making it easy to enter Asian characters. Any of the values defined by the
		/// \c IMECompositionModeConstants enumeration is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa GetCurrentIMECompositionText, IMEMode, UseTextServicesFramework, IMECompositionModeConstants
		[propget, id(DISPID_RTB_CURRENTIMECOMPOSITIONMODE), helpstring("Retrieves the control's current IME composition mode. This property is read-only."), nonbrowsable]
		HRESULT CurrentIMECompositionMode([out, retval] IMECompositionModeConstants* pValue);
		/// \brief <em>Controls the default horizontal alignment of math zones</em>
		///
		/// Retrieves or sets the default horizontal alignment of math zones. Some of the values defined by the
		/// \c HAlignmentConstants enumeration is valid.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IRichTextParagraph::HAlignment, IRichTextFont::IsMathZone, IRichTextRange::BuildUpMath,
		///     HAlignmentConstants
		[propget, id(DISPID_RTB_DEFAULTMATHZONEHALIGNMENT), helpstring("Retrieves or sets the default horizontal alignment of math zones. Requires Rich Edit 8.0 or newer.")]
		HRESULT DefaultMathZoneHAlignment([out, retval] HAlignmentConstants* pValue);
		[propput, id(DISPID_RTB_DEFAULTMATHZONEHALIGNMENT), helpstring("Retrieves or sets the default horizontal alignment of math zones. Requires Rich Edit 8.0 or newer.")]
		HRESULT DefaultMathZoneHAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Specifies the width of a tab character</em>
		///
		/// Retrieves or sets the width (in points) of a tabulator character. It is used if no tab stop is
		/// specified for the paragraph.
		///
		/// \remarks The system's default tab width is 36.0 points.
		///
		/// \sa IRichTextParagraph::Tabs
		[propget, id(DISPID_RTB_DEFAULTTABWIDTH), helpstring("Retrieves or sets the width (in points) of a tabulator character. It is used if no tab stop is specified for the paragraph.")]
		HRESULT DefaultTabWidth([out, retval] FLOAT* pValue);
		[propput, id(DISPID_RTB_DEFAULTTABWIDTH), helpstring("Retrieves or sets the width (in points) of a tabulator character. It is used if no tab stop is specified for the paragraph.")]
		HRESULT DefaultTabWidth([in] FLOAT newValue);
		/// \brief <em>Controls how empty arguments are denoted in a math zone</em>
		///
		/// Retrieves or sets which kinds of empty arguments in a math zone are denoted by a dotted square. Any
		/// of the values defined by the \c DenoteEmptyMathArgumentsConstants enumeration is valid.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IRichTextFont::IsMathZone, IRichTextRange::BuildUpMath, DenoteEmptyMathArgumentsConstants
		[propget, id(DISPID_RTB_DENOTEEMPTYMATHARGUMENTS), helpstring("Retrieves or sets which kinds of empty arguments in a math zone are denoted by a dotted square. Requires Rich Edit 8.0 or newer.")]
		HRESULT DenoteEmptyMathArguments([out, retval] DenoteEmptyMathArgumentsConstants* pValue);
		[propput, id(DISPID_RTB_DENOTEEMPTYMATHARGUMENTS), helpstring("Retrieves or sets which kinds of empty arguments in a math zone are denoted by a dotted square. Requires Rich Edit 8.0 or newer.")]
		HRESULT DenoteEmptyMathArguments([in] DenoteEmptyMathArgumentsConstants newValue);
		/// \brief <em>Specifies whether the control detects drag'n'drop operations</em>
		///
		/// Retrieves or sets whether <b>advanced</b> drag'n'drop mode can be entered. If set to \c True,
		/// <b>advanced</b> drag'n'drop mode can be entered by pressing the left or right mouse button over
		/// selected text and then moving the mouse with the button still pressed. If set to \c False,
		/// <b>advanced</b> drag'n'drop mode is not available - this also means the \c BeginDrag and
		/// \c BeginRDrag events don't get fired.
		///
		/// \remarks This affects advanced drag'n'drop mode only. Built-in drag'n'drop is not affected by this
		///          property.
		///
		/// \sa RegisterForOLEDragDrop, DragScrollTimeBase, _IRichTextBoxEvents::BeginDrag,
		///     _IRichTextBoxEvents::BeginRDrag
		[propget, id(DISPID_RTB_DETECTDRAGDROP), helpstring("Retrieves or sets whether advanced drag'n'drop mode can be entered.")]
		HRESULT DetectDragDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_DETECTDRAGDROP), helpstring("Retrieves or sets whether advanced drag'n'drop mode can be entered.")]
		HRESULT DetectDragDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls which events are fired</em>
		///
		/// Retrieves or sets the events that won't be fired. Disabling events increases performance.
		/// Any combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
		///
		/// \sa DisabledEventsConstants
		[propget, id(DISPID_RTB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([out, retval] DisabledEventsConstants* pValue);
		[propput, id(DISPID_RTB_DISABLEDEVENTS), helpstring("Retrieves or sets the events that won't be fired. Disabling events increases performance."), nonbrowsable]
		HRESULT DisabledEvents([in] DisabledEventsConstants newValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets whether IME operation is enabled. IME (Input Method Editor) is a Windows feature
		/// making it easy to enter Asian characters. On east-asian systems it can be explicitly disabled by
		/// setting this property to \c False.
		///
		/// \sa LetClientHandleAllIMEOperations, IMEMode, IMEConversionMode
		[propget, id(DISPID_RTB_DISABLEIMEOPERATIONS), helpstring("Retrieves or sets whether IME operation is enabled. On east-asian systems it can be explicitly disabled by setting this property to False.")]
		HRESULT DisableIMEOperations([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_DISABLEIMEOPERATIONS), helpstring("Retrieves or sets whether IME operation is enabled. On east-asian systems it can be explicitly disabled by setting this property to False.")]
		HRESULT DisableIMEOperations([in] VARIANT_BOOL newValue);
		// \brief <em>Specifies whether to discard the composition string if the user cancels IME</em>
		//
		// Retrieves or sets whether the current composition string of an IME (Input Method Editor) is
		// discarded, if the user cancels it. If set to \c True, the composition string is discarded;
		// otherwise it is used as result string.
		//
		// \sa IMEMode
		//[propget, id(DISPID_RTB_DISCARDCOMPOSITIONSTRINGONIMECANCEL), helpstring("Retrieves or sets whether the current composition string of an IME (Input Method Editor) is discarded, if the user cancels it.")]
		//HRESULT DiscardCompositionStringOnIMECancel([out, retval] VARIANT_BOOL* pValue);
		//[propput, id(DISPID_RTB_DISCARDCOMPOSITIONSTRINGONIMECANCEL), helpstring("Retrieves or sets whether the current composition string of an IME (Input Method Editor) is discarded, if the user cancels it.")]
		//HRESULT DiscardCompositionStringOnIMECancel([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls whether the control displays tool tips for links</em>
		///
		/// Retrieves or sets whether a tool tip with the link target is displayed if the mouse cursor is
		/// located over a link. If set to \c True, tool tips are displayed; otherwise not.
		///
		/// \attention Changing this property from \c True to \c False destroys and recreates the control
		///            window.
		///
		/// \remarks Requires Rich Edit 5.0 or newer.
		///
		/// \sa AutoDetectURLs, AutoDetectedURLSchemes
		[propget, id(DISPID_RTB_DISPLAYHYPERLINKTOOLTIPS), helpstring("Retrieves or sets whether a tool tip with the link target is displayed if the mouse cursor is located over a link. Changing this property from 'True' to 'False' destroys and recreates the control window. Requires Rich Edit 5.0 or newer.")]
		HRESULT DisplayHyperlinkTooltips([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_DISPLAYHYPERLINKTOOLTIPS), helpstring("Retrieves or sets whether a tool tip with the link target is displayed if the mouse cursor is located over a link. Changing this property from 'True' to 'False' destroys and recreates the control window. Requires Rich Edit 5.0 or newer.")]
		HRESULT DisplayHyperlinkTooltips([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls how zero-width table cell borders are displayed</em>
		///
		/// Retrieves or sets whether table cell borders are displayed as thin lines if the border width is set
		/// to 0. If set to \c True, such borders are displayed as thin lines; otherwise they are not displayed
		/// at all.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa IRichTextRange::ReplaceWithTable
		[propget, id(DISPID_RTB_DISPLAYZEROWIDTHTABLECELLBORDERS), helpstring("Retrieves or sets whether table cell borders are displayed as thin lines if the border width is set to 0. Changing this property destroys and recreates the control window.")]
		HRESULT DisplayZeroWidthTableCellBorders([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_DISPLAYZEROWIDTHTABLECELLBORDERS), helpstring("Retrieves or sets whether table cell borders are displayed as thin lines if the border width is set to 0. Changing this property destroys and recreates the control window.")]
		HRESULT DisplayZeroWidthTableCellBorders([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the document's default font settings</em>
		///
		/// Retrieves or sets the document's default font settings.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IRichTextFont, DocumentParagraph, IRichTextRange::Font
		[propget, id(DISPID_RTB_DOCUMENTFONT), helpstring("Retrieves or sets the document's default font settings. Requires Rich Edit 8.0 or newer."), nonbrowsable]
		HRESULT DocumentFont([out, retval] IRichTextFont** ppTextFont);
		[propput, id(DISPID_RTB_DOCUMENTFONT), helpstring("Retrieves or sets the document's default font settings. Requires Rich Edit 8.0 or newer."), nonbrowsable]
		HRESULT DocumentFont([in] IRichTextFont* pNewTextFont);
		/// \brief <em>Specifies the document's default paragraph settings</em>
		///
		/// Retrieves or sets the document's default paragraph settings.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IRichTextParagraph, DocumentFont, IRichTextRange::Paragraph
		[propget, id(DISPID_RTB_DOCUMENTPARAGRAPH), helpstring("Retrieves or sets the document's default paragraph settings. Requires Rich Edit 8.0 or newer."), nonbrowsable]
		HRESULT DocumentParagraph([out, retval] IRichTextParagraph** ppTextParagraph);
		[propput, id(DISPID_RTB_DOCUMENTPARAGRAPH), helpstring("Retrieves or sets the document's default paragraph settings. Requires Rich Edit 8.0 or newer."), nonbrowsable]
		HRESULT DocumentParagraph([in] IRichTextParagraph* pNewTextParagraph);
		/// \brief <em>Controls how the control draws its content</em>
		///
		/// Retrieves or sets whether a single font is used to draw all content. The font is determined by the
		/// system setting for the font used in message boxes. For example, accessible users may read text
		/// easier if it is uniform, rather than a mix of fonts and styles.\n
		/// If set to \c True, a uniform font is used; otherwise the used fonts are specified by the document.
		///
		/// \sa IRichTextFont::Name
		[propget, id(DISPID_RTB_DRAFTMODE), helpstring("Retrieves or sets whether a single font is used to draw all content.")]
		HRESULT DraftMode([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_DRAFTMODE), helpstring("Retrieves or sets whether a single font is used to draw all content.")]
		HRESULT DraftMode([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves a \c TextRange object for the currently dragged text</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTextRange, OLEDrag, TextRange
		[propget, id(DISPID_RTB_DRAGGEDTEXTRANGE), helpstring("Retrieves a 'TextRange' object for the currently dragged text. This property is read-only."), nonbrowsable]
		HRESULT DraggedTextRange([out, retval] IRichTextRange** ppTextRange);
		/// \brief <em>Controls the speed of automatic scrolling during drag'n'drop</em>
		///
		/// Retrieves or sets the period of time (in milliseconds) that is used as the time-base to
		/// calculate the velocity of auto-scrolling during a drag'n'drop operation. If set to 0,
		/// auto-scrolling is disabled. If set to -1, the system's double-click time, divided by 4, is
		/// used.
		///
		/// \sa DetectDragDrop, RegisterForOLEDragDrop, _IRichTextBoxEvents::OLEDragMouseMove
		[propget, id(DISPID_RTB_DRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT DragScrollTimeBase([out, retval] LONG* pValue);
		[propput, id(DISPID_RTB_DRAGSCROLLTIMEBASE), helpstring("Retrieves or sets the period of time (in milliseconds) that is used as the time-base to calculate the velocity of auto-scrolling during a drag'n'drop operation.")]
		HRESULT DragScrollTimeBase([in] LONG newValue);
		/// \brief <em>Controls whether dragged words can be dropped within other words</em>
		///
		/// Retrieves or sets whether the insertion mark is placed on word boundaries only, if the dragged text
		/// range is a whole word. If set to \c True, words can be dropped on word boundaries only; otherwise
		/// they can be dropped within other words.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.
		///
		/// \sa SmartSpacingOnDrop, RegisterForOLEDragDrop, AutoSelectWordOnTrackSelection
		[propget, id(DISPID_RTB_DROPWORDSONWORDBOUNDARIESONLY), helpstring("Retrieves or sets whether the insertion mark is placed on word boundaries only, if the dragged text range is a whole word. Requires Rich Edit 7.5 or newer.")]
		HRESULT DropWordsOnWordBoundariesOnly([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_DROPWORDSONWORDBOUNDARIESONLY), helpstring("Retrieves or sets whether the insertion mark is placed on word boundaries only, if the dragged text range is a whole word. Requires Rich Edit 7.5 or newer.")]
		HRESULT DropWordsOnWordBoundariesOnly([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the colors that are used for some text effects</em>
		///
		/// Retrieves or sets the colors that the control uses to draw some text effects. For instance these
		/// colors can be used for text underlines.\n
		/// Currently 16 colors can be defined.
		///
		/// \param[in] index The one-based index of the color to retrieve or set.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.
		///
		/// \sa IRichTextFont::UnderlineColorIndex, IRichTextFont::UnderlineType,
		///     IRichTextFont::UnderlinePosition, IRichTextFont::ForeColor
		[propget, id(DISPID_RTB_EFFECTCOLOR), helpstring("Retrieves or sets the colors that the control uses to draw some text effects. For instance these colors can be used for text underlines. Requires Rich Edit 7.5 or newer.")]
		HRESULT EffectColor([in] LONG Index, [out, retval] OLE_COLOR* pValue);
		[propput, id(DISPID_RTB_EFFECTCOLOR), helpstring("Retrieves or sets the colors that the control uses to draw some text effects. For instance these colors can be used for text underlines. Requires Rich Edit 7.5 or newer.")]
		HRESULT EffectColor([in] LONG Index, [in] OLE_COLOR newValue);
		/// \brief <em>Retrieves a collection of all embedded OLE objects</em>
		///
		/// Retrieves a collection of all OLE objects embedded in the document.
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichOLEObjects, IRichTextRange::EmbeddedObject
		[propget, id(DISPID_RTB_EMBEDDEDOBJECTS), helpstring("Retrieves a collection of all OLE objects embedded in the document. This property is read-only."), nonbrowsable]
		HRESULT EmbeddedObjects([out, retval] IRichOLEObjects** ppOLEObjects);
		/// \brief <em>Controls whether the control emulates a simple (non-RTF) text box</em>
		///
		/// Retrieves or sets whether the control deactivates a couple of features like most keyboard shortcuts
		/// and pasting rich text in order to give the client application much more control over the available
		/// rich edit features. If set to \c True, the control disables some rich edit features; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		[propget, id(DISPID_RTB_EMULATESIMPLETEXTBOX), helpstring("Retrieves or sets whether the control deactivates a couple of features (keyboard shortcuts, pasting rich text etc.) to give the client app more control over the available rich edit features. Changing this property destroys+recreates the control window.")]
		HRESULT EmulateSimpleTextBox([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_EMULATESIMPLETEXTBOX), helpstring("Retrieves or sets whether the control deactivates a couple of features (keyboard shortcuts, pasting rich text etc.) to give the client app more control over the available rich edit features. Changing this property destroys+recreates the control window.")]
		HRESULT EmulateSimpleTextBox([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls whether the control accepts user input</em>
		///
		/// Enables or disables the control for user input. If set to \c True, it reacts to user input;
		/// otherwise not.
		///
		/// \sa ReadOnly
		[propget, id(DISPID_RTB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_ENABLED), helpstring("Enables or disables the control for user input.")]
		HRESULT Enabled([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the background color of a line of text</em>
		///
		/// Retrieves or sets whether the background color of the first character in a line of text is used as
		/// the background color of the whole line. If set to \c True, the first character's background color
		/// is used as background color of the whole line. If subsequent text ranges have different background
		/// colors, those are applied to the corresponding text range only. If set to \c False, the line's
		/// background color remains transparent.
		///
		/// \sa IRichTextFont::BackColor, BackColor
		[propget, id(DISPID_RTB_EXTENDFONTBACKCOLORTOWHOLELINE), helpstring("Retrieves or sets whether the background color of the first character in a line of text is used as the background color of the whole line.")]
		HRESULT ExtendFontBackColorToWholeLine([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_EXTENDFONTBACKCOLORTOWHOLELINE), helpstring("Retrieves or sets whether the background color of the first character in a line of text is used as the background color of the whole line.")]
		HRESULT ExtendFontBackColorToWholeLine([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's first visible line</em>
		///
		/// Retrieves the zero-based index of the uppermost visible line in a multiline control.
		///
		/// \remarks This property is read-only.
		///
		/// \sa MultiLine, GetLineCount
		[propget, id(DISPID_RTB_FIRSTVISIBLELINE), helpstring("Retrieves the zero-based index of the uppermost visible line in a multiline control. This property is read-only."), nonbrowsable]
		HRESULT FirstVisibleLine([out, retval] LONG* pValue);
		/// \brief <em>Specifies the control's font</em>
		///
		/// Retrieves or sets the control's font. It's used to draw the control's content.
		///
		/// \sa Text, ZoomRatio
		[propget, id(DISPID_RTB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([out, retval] IFontDisp** ppFont);
		[propput, id(DISPID_RTB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		[propputref, id(DISPID_RTB_FONT), helpstring("Retrieves or sets the control's font.")]
		HRESULT Font([in] IFontDisp* pNewFont);
		/// \brief <em>Specifies the height of the control's formatting rectangle</em>
		///
		/// Retrieves or sets the height (in pixels) of the control's formatting rectangle.\n
		/// The visibility of the control's text is governed by the dimensions of its window rectangle and its
		/// formatting rectangle. The formatting rectangle is a construct maintained by the system for
		/// formatting the text displayed in the window rectangle. When the control is first displayed, the two
		/// rectangles are identical on the screen. An application can make the formatting rectangle larger
		/// than the window rectangle (thereby limiting the visibility of the control's text) or smaller than
		/// the window rectangle (thereby creating extra white space around the text).
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa FormattingRectangleLeft, FormattingRectangleTop, FormattingRectangleWidth,
		///     UseCustomFormattingRectangle, MultiLine
		[propget, id(DISPID_RTB_FORMATTINGRECTANGLEHEIGHT), helpstring("Retrieves or sets the height (in pixels) of the control's formatting rectangle. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleHeight([out, retval] OLE_YSIZE_PIXELS* pValue);
		[propput, id(DISPID_RTB_FORMATTINGRECTANGLEHEIGHT), helpstring("Retrieves or sets the height (in pixels) of the control's formatting rectangle. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleHeight([in] OLE_YSIZE_PIXELS newValue);
		/// \brief <em>Specifies the x-coordinate of the control's formatting rectangle</em>
		///
		/// Retrieves or sets the distance (in pixels) between the left borders of the control's formatting
		/// rectangle and its client area.\n
		/// The visibility of the control's text is governed by the dimensions of its window rectangle and its
		/// formatting rectangle. The formatting rectangle is a construct maintained by the system for
		/// formatting the text displayed in the window rectangle. When the control is first displayed, the two
		/// rectangles are identical on the screen. An application can make the formatting rectangle larger
		/// than the window rectangle (thereby limiting the visibility of the control's text) or smaller than
		/// the window rectangle (thereby creating extra white space around the text).
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa FormattingRectangleHeight, FormattingRectangleTop, FormattingRectangleWidth,
		///     UseCustomFormattingRectangle, MultiLine
		[propget, id(DISPID_RTB_FORMATTINGRECTANGLELEFT), helpstring("Retrieves or sets the distance (in pixels) between the left borders of the control's formatting rectangle and its client area. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleLeft([out, retval] OLE_XPOS_PIXELS* pValue);
		[propput, id(DISPID_RTB_FORMATTINGRECTANGLELEFT), helpstring("Retrieves or sets the distance (in pixels) between the left borders of the control's formatting rectangle and its client area. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleLeft([in] OLE_XPOS_PIXELS newValue);
		/// \brief <em>Specifies the y-coordinate of the control's formatting rectangle</em>
		///
		/// Retrieves or sets the distance (in pixels) between the upper borders of the control's formatting
		/// rectangle and its client area.\n
		/// The visibility of the control's text is governed by the dimensions of its window rectangle and its
		/// formatting rectangle. The formatting rectangle is a construct maintained by the system for
		/// formatting the text displayed in the window rectangle. When the control is first displayed, the two
		/// rectangles are identical on the screen. An application can make the formatting rectangle larger
		/// than the window rectangle (thereby limiting the visibility of the control's text) or smaller than
		/// the window rectangle (thereby creating extra white space around the text).
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa FormattingRectangleHeight, FormattingRectangleLeft, FormattingRectangleWidth,
		///     UseCustomFormattingRectangle, MultiLine
		[propget, id(DISPID_RTB_FORMATTINGRECTANGLETOP), helpstring("Retrieves or sets the distance (in pixels) between the upper borders of the control's formatting rectangle and its client area. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleTop([out, retval] OLE_YPOS_PIXELS* pValue);
		[propput, id(DISPID_RTB_FORMATTINGRECTANGLETOP), helpstring("Retrieves or sets the distance (in pixels) between the upper borders of the control's formatting rectangle and its client area. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleTop([in] OLE_YPOS_PIXELS newValue);
		/// \brief <em>Specifies the width of the control's formatting rectangle</em>
		///
		/// Retrieves or sets the width (in pixels) of the control's formatting rectangle.\n
		/// The visibility of the control's text is governed by the dimensions of its window rectangle and its
		/// formatting rectangle. The formatting rectangle is a construct maintained by the system for
		/// formatting the text displayed in the window rectangle. When the control is first displayed, the two
		/// rectangles are identical on the screen. An application can make the formatting rectangle larger
		/// than the window rectangle (thereby limiting the visibility of the control's text) or smaller than
		/// the window rectangle (thereby creating extra white space around the text).
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa FormattingRectangleHeight, FormattingRectangleLeft, FormattingRectangleTop,
		///     UseCustomFormattingRectangle, MultiLine
		[propget, id(DISPID_RTB_FORMATTINGRECTANGLEWIDTH), helpstring("Retrieves or sets the width (in pixels) of the control's formatting rectangle. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleWidth([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_RTB_FORMATTINGRECTANGLEWIDTH), helpstring("Retrieves or sets the width (in pixels) of the control's formatting rectangle. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT FormattingRectangleWidth([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Specifies whether n-ary operators in math zones are sized according to the operand</em>
		///
		/// Retrieves or sets whether n-ary operators (e.g. ∑) in math-zones are displayed in a font size that
		/// matches the height of the operand. If set to \c True, those operators grow with the operand's
		/// height; otherwise they remain in the initial size.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IRichTextFont::IsMathZone, IRichTextRange::BuildUpMath
		[propget, id(DISPID_RTB_GROWNARYOPERATORS), helpstring("Retrieves or sets whether n-ary operators (e.g. ∑) in math-zones are displayed in a font size that matches the height of the operand. Requires Rich Edit 8.0 or newer.")]
		HRESULT GrowNAryOperators([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_GROWNARYOPERATORS), helpstring("Retrieves or sets whether n-ary operators (e.g. ∑) in math-zones are displayed in a font size that matches the height of the operand. Requires Rich Edit 8.0 or newer.")]
		HRESULT GrowNAryOperators([in] VARIANT_BOOL newValue);
		// \brief <em>Controls the horizontal alignment of the control's content</em>
		//
		// Retrieves or sets the horizontal alignment of the control's content. Some of the values defined by
		// the \c HAlignmentConstants enumeration is valid.
		//
		// \attention Changing this property destroys and recreates the control window.
		//
		// \sa Text, IRichTextParagraph::HAlignment, DefaultMathZoneHAlignment, HAlignmentConstants
		//[propget, id(DISPID_RTB_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's content. Changing this property destroys and recreates the control window.")]
		//HRESULT HAlignment([out, retval] HAlignmentConstants* pValue);
		//[propput, id(DISPID_RTB_HALIGNMENT), helpstring("Retrieves or sets the horizontal alignment of the control's content. Changing this property destroys and recreates the control window.")]
		//HRESULT HAlignment([in] HAlignmentConstants newValue);
		/// \brief <em>Retrieves the imagelist containing the drag image</em>
		///
		/// Retrieves the handle to the imagelist containing the drag image that is used during a
		/// drag'n'drop operation to visualize the dragged data.
		///
		/// \sa ShowDragImage, OLEDrag, _IRichTextBoxEvents::DragMouseMove
		[propget, id(DISPID_RTB_HDRAGIMAGELIST), helpstring("Retrieves the handle to the imagelist containing the drag image that is used during a drag'n'drop operation to visualize the dragged data."), nonbrowsable]
		HRESULT hDragImageList([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Controls when the \c MouseHover event is fired</em>
		///
		/// Retrieves or sets the number of milliseconds the mouse cursor must be located over the
		/// control's client area before the \c MouseHover event is fired. If set to -1, the system hover
		/// time is used.
		///
		/// \sa _IRichTextBoxEvents::MouseHover
		[propget, id(DISPID_RTB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([out, retval] LONG* pValue);
		[propput, id(DISPID_RTB_HOVERTIME), helpstring("Retrieves or sets the number of milliseconds the mouse cursor must be located over the control's client area before the 'MouseHover' event is fired.")]
		HRESULT HoverTime([in] LONG newValue);
		/// \brief <em>Retrieves the control's window handle</em>
		///
		/// Retrieves the control's window handle.
		///
		/// \remarks This property is read-only.
		///
		/// \sa _IRichTextBoxEvents::RecreatedControlWindow, _IRichTextBoxEvents::DestroyedControlWindow
		[propget, id(DISPID_RTB_HWND), helpstring("Retrieves the control's window handle."), nonbrowsable]
		HRESULT hWnd([out, retval] OLE_HANDLE* pValue);
		/// \brief <em>Specifies the hyphenation callback function</em>
		///
		/// Retrieves or sets the address of the \c HyphenateProc implementation that will be called to
		/// hyphenate words. The address has to point to a function that has the same signature as the
		/// \c HyphenateProc prototype (see <a href="https://msdn.microsoft.com/en-us/library/bb774370.aspx">MSDN</a>).\n
		/// If set to 0, hyphenation is deactivated.
		///
		/// \remarks Hyphenation is known to work only with the native rich edit control of Windows and not
		///          with the MS Office version.
		///
		/// \sa IRichTextParagraph::Hyphenation, HyphenationWordWrapZoneWidth,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb774370.aspx">HyphenateProc</a>
		[propget, id(DISPID_RTB_HYPHENATIONFUNCTION), helpstring("Retrieves or sets the address of the 'HyphenateProc' implementation that will be called to hyphenate words. See documentation for details."), nonbrowsable]
		HRESULT HyphenationFunction([out, retval] LONG* pValue);
		[propput, id(DISPID_RTB_HYPHENATIONFUNCTION), helpstring("Retrieves or sets the address of the 'HyphenateProc' implementation that will be called to hyphenate words. See documentation for details."), nonbrowsable]
		HRESULT HyphenationFunction([in] LONG newValue);
		/// \brief <em>Controls hyphenation</em>
		///
		/// Retrieves or sets the width (in twips) of the zone, in which wrapping words is prefered over
		/// hyphenation. The zone is measured from the right margin to the left side. If there is a word
		/// delimiter (e.g. a space char) within this zone, the word that follows the delimiter will be wrapped
		/// to the next line. If there is no word delimiter within the zone, the word that exceeds the line
		/// length will be hyphenated.
		///
		/// \remarks Hyphenation is known to work only with the native rich edit control of Windows and not
		///          with the MS Office version.
		///
		/// \sa IRichTextParagraph::Hyphenation, HyphenationFunction
		[propget, id(DISPID_RTB_HYPHENATIONWORDWRAPZONEWIDTH), helpstring("Retrieves or sets the width (in twips) of the zone, in which wrapping words is prefered over hyphenation. See documentation for details.")]
		HRESULT HyphenationWordWrapZoneWidth([out, retval] SHORT* pValue);
		[propput, id(DISPID_RTB_HYPHENATIONWORDWRAPZONEWIDTH), helpstring("Retrieves or sets the width (in twips) of the zone, in which wrapping words is prefered over hyphenation. See documentation for details.")]
		HRESULT HyphenationWordWrapZoneWidth([in] SHORT newValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets the control's IME conversion mode, controlling which words are proposed by IME.
		/// IME (Input Method Editor) is a Windows feature making it easy to enter Asian characters. Any of the
		/// values defined by the \c IMEConversionModeConstants enumeration is valid.
		///
		/// \remarks This property is useful only for some input languages, for instance Japanese.
		///
		/// \sa DisableIMEOperations, TSFModeBias, IMEMode, IMEConversionModeConstants
		[propget, id(DISPID_RTB_IMECONVERSIONMODE), helpstring("Retrieves or sets the control's IME conversion mode, controlling which words are proposed by IME. This property is useful only for some input languages, for instance Japanese.")]
		HRESULT IMEConversionMode([out, retval] IMEConversionModeConstants* pValue);
		[propput, id(DISPID_RTB_IMECONVERSIONMODE), helpstring("Retrieves or sets the control's IME conversion mode, controlling which words are proposed by IME. This property is useful only for some input languages, for instance Japanese.")]
		HRESULT IMEConversionMode([in] IMEConversionModeConstants newValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets the control's IME mode. IME (Input Method Editor) is a Windows feature making it
		/// easy to enter Asian characters. Any of the values defined by the \c IMEModeConstants enumeration is
		/// valid.
		///
		/// \sa IMEConversionMode, CurrentIMECompositionMode, DisableIMEOperations, UseTextServicesFramework,
		///     IMEModeConstants
		[propget, id(DISPID_RTB_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([out, retval] IMEModeConstants* pValue);
		[propput, id(DISPID_RTB_IMEMODE), helpstring("Retrieves or sets the control's IME mode.")]
		HRESULT IMEMode([in] IMEModeConstants newValue);
		/// \brief <em>Controls how integral functions are displayed in math zones</em>
		///
		/// Retrieves or sets where the limits of an integral function are displayed in math zones. Any of the
		/// values defined by the \c LimitsLocationConstants enumeration is valid.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa NAryLimitsLocation, IRichTextFont::IsMathZone, IRichTextRange::BuildUpMath,
		///     LimitsLocationConstants
		[propget, id(DISPID_RTB_INTEGRALLIMITSLOCATION), helpstring("Retrieves or sets where the limits of an integral function are displayed in math zones. Requires Rich Edit 8.0 or newer.")]
		HRESULT IntegralLimitsLocation([out, retval] LimitsLocationConstants* pValue);
		[propput, id(DISPID_RTB_INTEGRALLIMITSLOCATION), helpstring("Retrieves or sets where the limits of an integral function are displayed in math zones. Requires Rich Edit 8.0 or newer.")]
		HRESULT IntegralLimitsLocation([in] LimitsLocationConstants newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the control's release type</em>
		///
		///   Retrieves the control's release type. This property is part of the fingerprint
		///   that uniquely identifies each software written by Timo "TimoSoft" Kunze. If set to
		///   \c True, the control was compiled for release; otherwise it was compiled for debugging.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, Programmer, Tester
		/// \endif
		[propget, id(DISPID_RTB_ISRELEASE), hidden]
		HRESULT IsRelease([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Specifies the width of the whitespace to the left of the control's content</em>
		///
		/// Retrieves or sets the width (in pixels) of the control's left margin. If set to -1, a value, that
		/// depends on the control's font, is used.
		///
		/// \sa RightMargin, Font, ShowSelectionBar, IRichTextParagraph::LeftIndent
		[propget, id(DISPID_RTB_LEFTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the control's left margin.")]
		HRESULT LeftMargin([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_RTB_LEFTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the control's left margin.")]
		HRESULT LeftMargin([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the control's IME features</em>
		///
		/// Retrieves or sets whether the control lets the client application handle all IME operations. IME
		/// (Input Method Editor) is a Windows feature making it easy to enter Asian characters. On east-asian
		/// systems the control can be directed to allow the client application to handle all IME operations,
		/// by setting this property to \c True.
		///
		/// \sa DisableIMEOperations, IMEMode, IMEConversionMode
		[propget, id(DISPID_RTB_LETCLIENTHANDLEALLIMEOPERATIONS), helpstring("Retrieves or sets whether the control lets the client application handle all IME operations. On east-asian systems the control can be directed to allow the client application to handle all IME operations, by setting this property to True.")]
		HRESULT LetClientHandleAllIMEOperations([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_LETCLIENTHANDLEALLIMEOPERATIONS), helpstring("Retrieves or sets whether the control lets the client application handle all IME operations. On east-asian systems the control can be directed to allow the client application to handle all IME operations, by setting this property to True.")]
		HRESULT LetClientHandleAllIMEOperations([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the mouse cursor used for links</em>
		///
		/// Retrieves or sets a user-defined mouse cursor that is used when the mouse cursor is located over a
		/// link, if the \c LinkMousePointer property is set to \c mpCustom.
		///
		/// \sa LinkMousePointer, MouseIcon, MousePointerConstants
		[propget, id(DISPID_RTB_LINKMOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor that is used when the mouse cursor is located over a link.")]
		HRESULT LinkMouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_RTB_LINKMOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor that is used when the mouse cursor is located over a link.")]
		HRESULT LinkMouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_RTB_LINKMOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor that is used when the mouse cursor is located over a link.")]
		HRESULT LinkMouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the mouse cursor used for links</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is located over a link.
		/// Any of the values defined by the \c MousePointerConstants enumeration is valid.
		///
		/// \sa LinkMouseIcon, MousePointer, MousePointerConstants
		[propget, id(DISPID_RTB_LINKMOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is located over a link.")]
		HRESULT LinkMousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_RTB_LINKMOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is located over a link.")]
		HRESULT LinkMousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Controls the caret</em>
		///
		/// Retrieves or sets whether the caret is a real, visible caret or just a logical one that behaves
		/// like a normal caret, but never is displayed. If set to \c True, the caret is a logical caret;
		/// otherwise a real one.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.
		///
		/// \sa ReadOnly
		[propget, id(DISPID_RTB_LOGICALCARET), helpstring("Retrieves or sets whether the caret is a real, visible caret or just a logical one that behaves like a normal caret, but never is displayed. Requires Rich Edit 7.5 or newer.")]
		HRESULT LogicalCaret([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_LOGICALCARET), helpstring("Retrieves or sets whether the caret is a real, visible caret or just a logical one that behaves like a normal caret, but never is displayed. Requires Rich Edit 7.5 or newer.")]
		HRESULT LogicalCaret([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls where automatic line breaks are inserted in math zones</em>
		///
		/// Retrieves or sets where automatic line breaks may be inserted within math zones. Any of the
		/// values defined by the \c MathLineBreakBehaviorConstants enumeration is valid.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IRichTextFont::IsMathZone, IRichTextRange::BuildUpMath, MathLineBreakBehaviorConstants
		[propget, id(DISPID_RTB_MATHLINEBREAKBEHAVIOR), helpstring("Retrieves or sets where automatic line breaks may be inserted within math zones. Requires Rich Edit 8.0 or newer.")]
		HRESULT MathLineBreakBehavior([out, retval] MathLineBreakBehaviorConstants* pValue);
		[propput, id(DISPID_RTB_MATHLINEBREAKBEHAVIOR), helpstring("Retrieves or sets where automatic line breaks may be inserted within math zones. Requires Rich Edit 8.0 or newer.")]
		HRESULT MathLineBreakBehavior([in] MathLineBreakBehaviorConstants newValue);
		/// \brief <em>Specifies the maximum length of the input</em>
		///
		/// Retrieves or sets the maximum number of characters, that the user can type or paste into the control. If set
		/// to -1, the system's default setting (64,000 characters) is used.
		///
		/// \remarks Text, that is set through the \c Text property may exceed this limit.\n
		///          Embedded COM objects count as 1 character.
		///
		/// \sa IRichTextRange::RangeLength, Text, BeepOnMaxText, _IRichTextBoxEvents::TruncatedText
		[propget, id(DISPID_RTB_MAXTEXTLENGTH), helpstring("Retrieves or sets the maximum number of characters, that the user can type or paste into the control.")]
		HRESULT MaxTextLength([out, retval] LONG* pValue);
		[propput, id(DISPID_RTB_MAXTEXTLENGTH), helpstring("Retrieves or sets the maximum number of characters, that the user can type or paste into the control.")]
		HRESULT MaxTextLength([in] LONG newValue);
		/// \brief <em>Specifies the maximum number of actions that can be stored in the control's undo queue</em>
		///
		/// Retrieves or sets the maximum number of actions that can be stored in the control's undo queue.
		///
		/// \remarks The actual maximum depends on the available memory and can be lower.
		///
		/// \sa BeginNewUndoAction, EmptyUndoBuffer, CanUndo, Undo
		[propget, id(DISPID_RTB_MAXUNDOQUEUESIZE), helpstring("Retrieves or sets the maximum number of actions that can be stored in the control's undo queue. The actual maximum depends on the available memory and can be lower.")]
		HRESULT MaxUndoQueueSize([out, retval] LONG* pValue);
		[propput, id(DISPID_RTB_MAXUNDOQUEUESIZE), helpstring("Retrieves or sets the maximum number of actions that can be stored in the control's undo queue. The actual maximum depends on the available memory and can be lower.")]
		HRESULT MaxUndoQueueSize([in] LONG newValue);
		/// \brief <em>Retrieves or sets a flag indicating whether the control's content has changed</em>
		///
		/// Retrieves or sets a flag indicating whether the control's content has changed. A value of \c True
		/// stands for changed content, a value of \c False for unchanged content.
		///
		/// \sa Text, _IRichTextBoxEvents::ContentChanged
		[propget, id(DISPID_RTB_MODIFIED), helpstring("Retrieves or sets a flag indicating whether the control's content has changed.")]
		HRESULT Modified([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_MODIFIED), helpstring("Retrieves or sets a flag indicating whether the control's content has changed.")]
		HRESULT Modified([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets a user-defined mouse cursor. It's used if \c MousePointer is set to
		/// \c mpCustom.
		///
		/// \sa MousePointer, LinkMouseIcon, MousePointerConstants
		[propget, id(DISPID_RTB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([out, retval] IPictureDisp** ppMouseIcon);
		[propput, id(DISPID_RTB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		[propputref, id(DISPID_RTB_MOUSEICON), helpstring("Retrieves or sets a user-defined mouse cursor.")]
		HRESULT MouseIcon([in] IPictureDisp* pNewMouseIcon);
		/// \brief <em>Controls the control's mouse cursor</em>
		///
		/// Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the
		/// control's client area. Any of the values defined by the \c MousePointerConstants enumeration
		/// is valid.
		///
		/// \sa MouseIcon, LinkMousePointer, MousePointerConstants
		[propget, id(DISPID_RTB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([out, retval] MousePointerConstants* pValue);
		[propput, id(DISPID_RTB_MOUSEPOINTER), helpstring("Retrieves or sets the cursor's type that's used if the mouse cursor is placed within the control's client area.")]
		HRESULT MousePointer([in] MousePointerConstants newValue);
		/// \brief <em>Specifies whether the control displays text in multiple lines</em>
		///
		/// Retrieves or sets whether the control processes carriage returns and displays the content in
		/// multiple lines. If set to \c True, the content is displayed on multiple lines; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \sa Text, ScrollBars, GetLineCount, FirstVisibleLine, IRichTextParagraph::HAlignment
		[propget, id(DISPID_RTB_MULTILINE), helpstring("Retrieves or sets whether the control processes carriage returns and displays the content on multiple lines. Changing this property destroys and recreates the control window.")]
		HRESULT MultiLine([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_MULTILINE), helpstring("Retrieves or sets whether the control processes carriage returns and displays the content on multiple lines. Changing this property destroys and recreates the control window.")]
		HRESULT MultiLine([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether multiple text ranges can be selected</em>
		///
		/// Retrieves or sets whether the control allows simultaneous selection of multiple text ranges by
		/// pressing the [CTRL] key while selecting text. If set to \c True, multiple text ranges can be
		/// selected; otherwise only one text range can be selected.
		///
		/// \remarks Requires Rich Edit 5.0 or newer.
		///
		/// \sa IRichTextRange::SubRanges, SelectedTextRange
		[propget, id(DISPID_RTB_MULTISELECT), helpstring("Retrieves or sets whether the control allows simultaneous selection of multiple text ranges by pressing the [CTRL] key while selecting text. Requires Rich Edit 5.0 or newer.")]
		HRESULT MultiSelect([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_MULTISELECT), helpstring("Retrieves or sets whether the control allows simultaneous selection of multiple text ranges by pressing the [CTRL] key while selecting text. Requires Rich Edit 5.0 or newer.")]
		HRESULT MultiSelect([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls how n-ary functions are displayed in math zones</em>
		///
		/// Retrieves or sets where the limits of a n-ary function are displayed in math zones. Any of the
		/// values defined by the \c LimitsLocationConstants enumeration is valid.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IntegralLimitsLocation, IRichTextFont::IsMathZone, IRichTextRange::BuildUpMath,
		///     LimitsLocationConstants
		[propget, id(DISPID_RTB_NARYLIMITSLOCATION), helpstring("Retrieves or sets where the limits of an n-ary function are displayed in math zones. Requires Rich Edit 8.0 or newer.")]
		HRESULT NAryLimitsLocation([out, retval] LimitsLocationConstants* pValue);
		[propput, id(DISPID_RTB_NARYLIMITSLOCATION), helpstring("Retrieves or sets where the limits of an n-ary function are displayed in math zones. Requires Rich Edit 8.0 or newer.")]
		HRESULT NAryLimitsLocation([in] LimitsLocationConstants newValue);
		/// \brief <em>Retrieves the kind of the next action in the control's redo queue</em>
		///
		/// Retrieves the kind of the action that will be redone when calling the \c Redo method. Any of the
		/// values defined by the \c UndoActionTypeConstants enumeration is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa CanRedo, Redo, NextUndoActionType, UndoActionTypeConstants
		[propget, id(DISPID_RTB_NEXTREDOACTIONTYPE), helpstring("Retrieves the kind of the action that will be redone when calling the 'Redo' method."), nonbrowsable]
		HRESULT NextRedoActionType([out, retval] UndoActionTypeConstants* pValue);
		/// \brief <em>Retrieves the kind of the next action in the control's undo queue</em>
		///
		/// Retrieves the kind of the action that will be undone when calling the \c Undo method. Any of the
		/// values defined by the \c UndoActionTypeConstants enumeration is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa CanUndo, Undo, NextRedoActionType, UndoActionTypeConstants
		[propget, id(DISPID_RTB_NEXTUNDOACTIONTYPE), helpstring("Retrieves the kind of the action that will be undone when calling the 'Undo' method."), nonbrowsable]
		HRESULT NextUndoActionType([out, retval] UndoActionTypeConstants* pValue);
		/// \brief <em>Controls how text input is accepted</em>
		///
		/// Retrieves or sets whether the sequence of typed text is verified in languages that require it,
		/// for instance Thai and Vietnamese. If set to \c True, the sequence of typed text is verified before
		/// accepting the input; otherwise the sequence is not verified and Unicode characters, that are meant
		/// to be combined to a complex character, are displayed separately.
		///
		/// \sa UseTextServicesFramework, IMEMode
		[propget, id(DISPID_RTB_NOINPUTSEQUENCECHECK), helpstring("Retrieves or sets whether the sequence of typed text is verified in languages that require it, for instance Thai and Vietnamese.")]
		HRESULT NoInputSequenceCheck([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_NOINPUTSEQUENCECHECK), helpstring("Retrieves or sets whether the sequence of typed text is verified in languages that require it, for instance Thai and Vietnamese.")]
		HRESULT NoInputSequenceCheck([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the appearance of the OLE drag images generated by the control</em>
		///
		/// Retrieves or sets the appearance of the OLE drag images generated by the control. Any of the values
		/// defined by the \c OLEDragImageStyleConstants enumeration is valid.
		///
		/// \sa SupportOLEDragImages, OLEDrag, OLEDragImageStyleConstants
		[propget, id(DISPID_RTB_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([out, retval] OLEDragImageStyleConstants* pValue);
		[propput, id(DISPID_RTB_OLEDRAGIMAGESTYLE), helpstring("Retrieves or sets the appearance of the OLE drag images generated by the control.")]
		HRESULT OLEDragImageStyle([in] OLEDragImageStyleConstants newValue);
		/// \brief <em>Specifies whether the \c ContextMenu event can be invoked using the keyboard</em>
		///
		/// Retrieves or sets whether the control fires the \c ContextMenu event if the user presses
		/// [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c True, the events get fired; otherwise not.
		///
		/// \sa _IRichTextBoxEvents::ContextMenu
		[propget, id(DISPID_RTB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_PROCESSCONTEXTMENUKEYS), helpstring("Retrieves or sets whether the control fires the 'ContextMenu' event if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU].")]
		HRESULT ProcessContextMenuKeys([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
		///
		///   Retrieves the name(s) of the control's programmer(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Tester
		/// \endif
		[propget, id(DISPID_RTB_PROGRAMMER), hidden]
		HRESULT Programmer([out, retval] BSTR* pValue);
		/// \brief <em>Specifies how subscript and superscript operators are displayed within linearized math zones</em>
		///
		/// Retrieves or sets whether subscript (_) and superscript (^) operators are displayed as themselves
		/// in math zones that are in linear format. If set to \c True, those operators are displayed as
		/// themselves; otherwise they are replaced by an arrow pointing down and an arrow pointing up.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IRichTextFont::IsMathZone, IRichTextRange::BuildDownMath
		[propget, id(DISPID_RTB_RAWSUBSCRIPTANDSUPERSCRIPTOPERATORS), helpstring("Retrieves or sets whether subscript (_) and superscript (^) operators are displayed as themselves in math zones that are in linear format. Requires Rich Edit 8.0 or newer.")]
		HRESULT RawSubScriptAndSuperScriptOperators([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_RAWSUBSCRIPTANDSUPERSCRIPTOPERATORS), helpstring("Retrieves or sets whether subscript (_) and superscript (^) operators are displayed as themselves in math zones that are in linear format. Requires Rich Edit 8.0 or newer.")]
		HRESULT RawSubScriptAndSuperScriptOperators([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the user can edit the displayed text</em>
		///
		/// Retrieves or sets whether the control accepts user input, that would change the control's content.
		/// If set to \c False, such user input is accepted; otherwise not.
		///
		/// \sa Enabled, LogicalCaret, Text
		[propget, id(DISPID_RTB_READONLY), helpstring("Retrieves or sets whether the control accepts user input, that would change the control's content.")]
		HRESULT ReadOnly([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_READONLY), helpstring("Retrieves or sets whether the control accepts user input, that would change the control's content.")]
		HRESULT ReadOnly([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control is registered as a target for OLE drag'n'drop. Any of the
		/// values defined by the \c RegisterForOLEDragDropConstants enumeration is valid.
		///
		/// \sa DetectDragDrop, SupportOLEDragImages, _IRichTextBoxEvents::OLEDragEnter,
		///     RegisterForOLEDragDropConstants
		[propget, id(DISPID_RTB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([out, retval] RegisterForOLEDragDropConstants* pValue);
		[propput, id(DISPID_RTB_REGISTERFOROLEDRAGDROP), helpstring("Retrieves or sets whether the control is registered as a target for OLE drag'n'drop.")]
		HRESULT RegisterForOLEDragDrop([in] RegisterForOLEDragDropConstants newValue);
		/// \brief <em>Retrieves the supported version of the Rich Edit API set</em>
		///
		/// The control can use the rich edit implementation of Windows and different versions of Office. The
		/// supported API set depends on the Windows version, if the native rich edit is used, and on the
		/// Office version, if the MS Office rich edit control is used. This property retrieves the version of
		/// the supported API set. Any of the values defined by the \c RichEditAPIVersionConstants enumeration
		/// is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa RichEditVersion, RichEditAPIVersionConstants
		[propget, id(DISPID_RTB_RICHEDITAPIVERSION), helpstring("The control can use the rich edit implementation of Windows and different versions of Office. This property retrieves the version of the supported API set."), nonbrowsable]
		HRESULT RichEditAPIVersion([out, retval] RichEditAPIVersionConstants* pValue);
		/// \brief <em>Retrieves the fully qualified path to the currently used rich edit library</em>
		///
		/// The control can use the rich edit implementation of Windows and different versions of Office. This
		/// property retrieves the fully qualified path to the library that implements the currently used
		/// native rich edit control.
		///
		/// \remarks This property is read-only.
		///
		/// \sa RichEditVersion, RichEditAPIVersion
		[propget, id(DISPID_RTB_RICHEDITLIBRARYPATH), helpstring("The control can use the rich edit implementation of Windows and different versions of Office. This property retrieves the fully qualified path to the library that implements the currently used native rich edit control."), nonbrowsable]
		HRESULT RichEditLibraryPath([out, retval] BSTR* pValue);
		/// \brief <em>Specifies whether to use the rich edit control of MS Office if Office is installed</em>
		///
		/// Retrieves or sets whether to use the rich edit control of Microsoft Office or the rich edit control
		/// of Microsoft Windows. Any of the values defined by the \c RichEditVersionConstants enumeration is
		/// valid.
		///
		/// \remarks The rich edit control of Microsoft Office is implemented in the file richedit20.dll, which
		///          is installed to <code>%COMMONPROGRAMFILES(x86)%\Microsoft Shared\OFFICE<em>n</em></code>.
		///          The rich edit control of Microsoft Windows is implemented in the file msftedit.dll in the
		///          system directory. Neither of both files can be redistributed.\n
		///          The rich edit control of Microsoft Office usually has more features than the rich edit
		///          control of Microsoft Windows.\n
		///          Currently the following rich edit versions can be used:
		///          - Rich Edit 4.1, native rich edit control of Windows XP, 2003, 2003 R2, Vista, 2008, 7,
		///            2008 R2.
		///          - Rich Edit 5.0, rich edit control of Office 2003.
		///          - Rich Edit 6.0, rich edit control of Office 2007.
		///          - Rich Edit 7.0, rich edit control of Office 2010.
		///          - Rich Edit 7.5, native rich edit control of Windows 8, 2012, 8.1, 2012 R2, 10.
		///          - Rich Edit 8.0, rich edit control of Office 2013, 2016.
		///
		/// \attention This property cannot be changed at runtime.
		///
		/// \remarks Although the rich edit control of Office usually has more features, some features work
		///          only with the native control of Windows. For instance hyphenation is known to work only
		///          with the native rich edit control.
		///
		/// \sa RichEditAPIVersion, RichEditLibraryPath, RichEditVersionConstants
		[propget, id(DISPID_RTB_RICHEDITVERSION), helpstring("Retrieves or sets whether to use the rich edit control of Microsoft Office or the rich edit control of Microsoft Windows. This property cannot be changed at runtime.")]
		HRESULT RichEditVersion([out, retval] RichEditVersionConstants* pValue);
		[propput, id(DISPID_RTB_RICHEDITVERSION), helpstring("Retrieves or sets whether to use the rich edit control of Microsoft Office or the rich edit control of Microsoft Windows. This property cannot be changed at runtime.")]
		HRESULT RichEditVersion([in] RichEditVersionConstants newValue);
		/// \brief <em>Specifies the control's content, including control words for formatting</em>
		///
		/// Retrieves or sets the control's content, including RTF control words for formatting.
		///
		/// \sa Text, IRichTextFont, IRichTextParagraph, IRichTextRange::RichText
		[propget, id(DISPID_RTB_RICHTEXT), helpstring("Retrieves or sets the control's content, including RTF control words for formatting."), nonbrowsable]
		HRESULT RichText([out, retval] BSTR* pValue);
		[propput, id(DISPID_RTB_RICHTEXT), helpstring("Retrieves or sets the control's content, including RTF control words for formatting."), nonbrowsable]
		HRESULT RichText([in] BSTR newValue);
		/// \brief <em>Specifies the width of the whitespace to the right of the control's content</em>
		///
		/// Retrieves or sets the width (in pixels) of the control's right margin. If set to -1, a value, that
		/// depends on the control's font, is used.
		///
		/// \sa LeftMargin, Font, IRichTextParagraph::RightIndent
		[propget, id(DISPID_RTB_RIGHTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the control's right margin.")]
		HRESULT RightMargin([out, retval] OLE_XSIZE_PIXELS* pValue);
		[propput, id(DISPID_RTB_RIGHTMARGIN), helpstring("Retrieves or sets the width (in pixels) of the control's right margin.")]
		HRESULT RightMargin([in] OLE_XSIZE_PIXELS newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features. Any combination of the values defined by the
		/// \c RightToLeftConstants enumeration is valid.
		///
		/// \attention On Windows XP, changing this property destroys and recreates the control window.\n
		///            Setting or clearing the \c rtlText flag destroys and recreates the control window.
		///
		/// \sa IMEMode, IRichTextParagraph::RightToLeft, RightToLeftMathZones,
		///     _IRichTextBoxEvents::WritingDirectionChanged, RightToLeftConstants
		[propget, id(DISPID_RTB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([out, retval] RightToLeftConstants* pValue);
		[propput, id(DISPID_RTB_RIGHTTOLEFT), helpstring("Enables or disables bidirectional features.")]
		HRESULT RightToLeft([in] RightToLeftConstants newValue);
		/// \brief <em>Controls the control's right-to-left features</em>
		///
		/// Enables or disables bidirectional features of math zones within right-to-left paragraphs. If set to
		/// \c True, math-zones in right-to-left paragraphs will have right-to-left layout as well; otherwise
		/// not.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IRichTextParagraph::RightToLeft, RightToLeft, IRichTextFont::IsMathZone,
		///     IRichTextRange::BuildUpMath
		[propget, id(DISPID_RTB_RIGHTTOLEFTMATHZONES), helpstring("Enables or disables bidirectional features of math zones within right-to-left paragraphs. Requires Rich Edit 8.0 or newer.")]
		HRESULT RightToLeftMathZones([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_RIGHTTOLEFTMATHZONES), helpstring("Enables or disables bidirectional features of math zones within right-to-left paragraphs. Requires Rich Edit 8.0 or newer.")]
		HRESULT RightToLeftMathZones([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies the scrollbars to show</em>
		///
		/// Retrieves or sets the scrollbars to show. Any combination of the values defined by the
		/// \c ScrollBarsConstants enumeration is valid.
		///
		/// \sa AlwaysShowScrollBars, AutoScrolling, MultiLine, Scroll, _IRichTextBoxEvents::Scrolling,
		///     ScrollBarsConstants
		[propget, id(DISPID_RTB_SCROLLBARS), helpstring("Retrieves or sets the scrollbars to show.")]
		HRESULT ScrollBars([out, retval] ScrollBarsConstants* pValue);
		[propput, id(DISPID_RTB_SCROLLBARS), helpstring("Retrieves or sets the scrollbars to show.")]
		HRESULT ScrollBars([in] ScrollBarsConstants newValue);
		/// \brief <em>Controls automatic scrolling</em>
		///
		/// Retrieves or sets whether the control scrolls automatically to character position 0 when it loses
		/// the keyboard focus. If set to \c True, the control scrolls to top when losing focus; otherwise not.
		///
		/// \sa ScrollBars, IRichTextRange::ScrollIntoView, Scroll
		[propget, id(DISPID_RTB_SCROLLTOTOPONKILLFOCUS), helpstring("Retrieves or sets whether the control scrolls automatically to character position 0 when it loses the keyboard focus.")]
		HRESULT ScrollToTopOnKillFocus([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_SCROLLTOTOPONKILLFOCUS), helpstring("Retrieves or sets whether the control scrolls automatically to character position 0 when it loses the keyboard focus.")]
		HRESULT ScrollToTopOnKillFocus([in] VARIANT_BOOL newValue);
		// \brief <em>Retrieves the currently selected text</em>
		//
		// \remarks If \c MultiSelect is enabled, this property refers only to the active sub-range.\n
		//          This property is read-only.
		//
		// \sa SelectedTextRange, MultiSelect, TextRange, ReplaceSelectedText, AutoSelectWordOnTrackSelection,
		//     Text
		//[propget, id(DISPID_RTB_SELECTEDTEXT), helpstring("Retrieves the currently selected text. This property is read-only."), nonbrowsable]
		//HRESULT SelectedText([out, retval] BSTR* pValue);
		/// \brief <em>Retrieves a \c TextRange object for the currently selected text</em>
		///
		/// \remarks This property is read-only.
		///
		/// \sa IRichTextRange, MultiSelect, TextRange
		[propget, id(DISPID_RTB_SELECTEDTEXTRANGE), helpstring("Retrieves a 'TextRange' object for the currently selected text. This property is read-only."), nonbrowsable]
		HRESULT SelectedTextRange([out, retval] IRichTextRange** ppTextRange);
		/// \brief <em>Retrieves what kind of data the current selection contains</em>
		///
		/// Retrieves what kind of data the current selection contains. Any combination of the values defined
		/// by the \c SelectionTypeConstants enumeration is valid.
		///
		/// \remarks This property is read-only.
		///
		/// \sa SelectedTextRange, MultiSelect, SelectionTypeConstants
		[propget, id(DISPID_RTB_SELECTIONTYPE), helpstring("Retrieves what kind of data the current selection contains.")]
		HRESULT SelectionType([out, retval] SelectionTypeConstants* pValue);
		/// \brief <em>Controls the visibility of the control's drag image</em>
		///
		/// Retrieves or sets whether the drag image is currently visible or hidden. If set to \c True, it
		/// is visible; otherwise it is hidden.
		///
		/// \sa hDragImageList, SupportOLEDragImages, _IRichTextBoxEvents::DragMouseMove
		[propget, id(DISPID_RTB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_SHOWDRAGIMAGE), helpstring("Retrieves or sets whether the drag image is currently visible."), nonbrowsable]
		HRESULT ShowDragImage([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether to show a narrow bar for selecting whole lines</em>
		///
		/// Retrieves or sets whether the control adds space to the left margin where the cursor changes to a
		/// right-up arrow, allowing the user to select full lines of text. If set to \c True, the selection
		/// bar is displayed; otherwise not.
		///
		/// \sa LeftMargin
		[propget, id(DISPID_RTB_SHOWSELECTIONBAR), helpstring("Retrieves or sets whether the control adds space to the left margin where the cursor changes to a right-up arrow, allowing the user to select full lines of text.")]
		HRESULT ShowSelectionBar([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_SHOWSELECTIONBAR), helpstring("Retrieves or sets whether the control adds space to the left margin where the cursor changes to a right-up arrow, allowing the user to select full lines of text.")]
		HRESULT ShowSelectionBar([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls whether a space is inserted automatically between dropped text and a word boundary</em>
		///
		/// Retrieves or sets whether a space character is inserted automatically when text is being dropped
		/// right before or right after a word. If set to \c True, the space character is inserted
		/// automatically; otherwise not.
		///
		/// \remarks Requires Rich Edit 7.5 or newer.
		///
		/// \sa DropWordsOnWordBoundariesOnly, RegisterForOLEDragDrop
		[propget, id(DISPID_RTB_SMARTSPACINGONDROP), helpstring("Retrieves or sets whether a space character is inserted automatically when text is being dropped right before or right after a word. Requires Rich Edit 7.5 or newer.")]
		HRESULT SmartSpacingOnDrop([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_SMARTSPACINGONDROP), helpstring("Retrieves or sets whether a space character is inserted automatically when text is being dropped right before or right after a word. Requires Rich Edit 7.5 or newer.")]
		HRESULT SmartSpacingOnDrop([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls the control's behavior in drag'n'drop operations</em>
		///
		/// Retrieves or sets whether the control creates an \c IDropTargetHelper object, so that a drag image
		/// can be displayed during OLE drag'n'drop. If set to \c True, the control creates the object;
		/// otherwise not.
		///
		/// \remarks Requires shell32.dll version 5.0 or higher.
		///
		/// \sa RegisterForOLEDragDrop, ShowDragImage, OLEDragImageStyle, FinishOLEDragDrop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		[propget, id(DISPID_RTB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_SUPPORTOLEDRAGIMAGES), helpstring("Retrieves or sets whether the control creates an 'IDropTargetHelper' object, so that a drag image can be displayed during OLE drag'n'drop. Requires shell32.dll version 5.0 or higher.")]
		HRESULT SupportOLEDragImages([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls automatic font switching</em>
		///
		/// Retrieves or sets whether the control changes to another font when the user explicitly changes to
		/// a different keyboard layout and starts typing text. If set to \c True, the font is switched
		/// automatically; otherwise not.
		///
		/// \sa UseDualFontMode, IMEMode, IRichTextRange::Font
		[propget, id(DISPID_RTB_SWITCHFONTONIMEINPUT), helpstring("Retrieves or sets whether the control changes to another font when the user explicitly changes to a different keyboard layout and starts typing text.")]
		HRESULT SwitchFontOnIMEInput([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_SWITCHFONTONIMEINPUT), helpstring("Retrieves or sets whether the control changes to another font when the user explicitly changes to a different keyboard layout and starts typing text.")]
		HRESULT SwitchFontOnIMEInput([in] VARIANT_BOOL newValue);
		/// \if PRIVATEDOC
		///   \brief <em>Retrieves the name(s) of the control's tester(s)</em>
		///
		///   Retrieves the name(s) of the control's tester(s). This property is part of the
		///   fingerprint that uniquely identifies each software written by Timo "TimoSoft" Kunze.
		///
		///   \remarks This property is hidden and read-only.
		///
		///   \sa AppID, AppName, AppShortName, Build, CharSet, IsRelease, Programmer
		/// \endif
		[propget, id(DISPID_RTB_TESTER), hidden]
		HRESULT Tester([out, retval] BSTR* pValue);
		/// \brief <em>Specifies the control's content</em>
		///
		/// Retrieves or sets the control's content. It is the plain text, without RTF formatting.
		///
		/// \remarks This is the control's default property.
		///
		/// \sa RichText, TextRange, IRichTextRange::RangeLength, MaxTextLength, TextFlow, LoadFromFile,
		///     SaveToFile, IRichTextParagraph::HAlignment, MultiLine, Font, _IRichTextBoxEvents::TextChanged
		[propget, id(DISPID_RTB_TEXT), helpstring("Retrieves or sets the control's content. It is the plain text, without RTF formatting."), bindable, displaybind, requestedit, defaultbind]
		HRESULT Text([out, retval] BSTR* pValue);
		[propput, id(DISPID_RTB_TEXT), helpstring("Retrieves or sets the control's content. It is the plain text, without RTF formatting."), bindable, displaybind, requestedit, defaultbind]
		HRESULT Text([in] BSTR newValue);
		/// \brief <em>Specifies the text flow direction</em>
		///
		/// Retrieves or sets a value specifying how the text flows. Any of the values defined by the
		/// \c TextFlowConstants enumeration is valid.
		///
		/// \sa TextOrientation, Text, TextFlowConstants
		[propget, id(DISPID_RTB_TEXTFLOW), helpstring("Retrieves or sets a value specifying how the text flows.")]
		HRESULT TextFlow([out, retval] TextFlowConstants* pValue);
		[propput, id(DISPID_RTB_TEXTFLOW), helpstring("Retrieves or sets a value specifying how the text flows.")]
		HRESULT TextFlow([in] TextFlowConstants newValue);
		// \brief <em>Retrieves the length of the text</em>
		//
		// Retrieves the length of the text specified by the \c Text property.
		//
		// \remarks This property is read-only.
		//
		// \sa MaxTextLength, Text
		//[propget, id(DISPID_RTB_TEXTLENGTH), helpstring("Retrieves the length of the text specified by the 'Text' property. This property is read-only."), nonbrowsable]
		//HRESULT TextLength([out, retval] LONG* pValue);
		/// \brief <em>Specifies whether text is written in lines or columns</em>
		///
		/// Retrieves or sets a value that specifies whether the control's text is organized in lines or
		/// columns. By default text is written in horizontal lines, from left to right and top to bottom. Some
		/// languages, e.g. traditional Chinese andtraditional Japanese, are written in vertical columns, from
		/// top to bottom and right to left.\n
		/// Any of the values defined by the \c TextOrientationConstants enumeration is valid.
		///
		/// \sa IMEMode, TextFlow, Text, TextOrientationConstants
		[propget, id(DISPID_RTB_TEXTORIENTATION), helpstring("Retrieves or sets a value that specifies whether the control's text is organized in lines or columns.")]
		HRESULT TextOrientation([out, retval] TextOrientationConstants* pValue);
		[propput, id(DISPID_RTB_TEXTORIENTATION), helpstring("Retrieves or sets a value that specifies whether the control's text is organized in lines or columns.")]
		HRESULT TextOrientation([in] TextOrientationConstants newValue);
		/// \brief <em>Retrieves a \c TextRange object for the specified range of text</em>
		///
		/// \param[in] rangeStart The zero-based index of the character at which the range starts.
		/// \param[in] rangeEnd The zero-based index of the first character after the end of the range.
		///
		/// \remarks This property is read-only.\n
		///          If \c rangeStart is set to 0 and \c rangeEnd is set to -1, the range includes the whole
		///          content of the control.
		///
		/// \sa IRichTextRange, Text, SelectedTextRange
		[propget, id(DISPID_RTB_TEXTRANGE), helpstring("Retrieves a 'TextRange' object for the specified range of text. This property is read-only."), nonbrowsable]
		HRESULT TextRange([in, defaultvalue(0)] LONG rangeStart, [in, defaultvalue(-1)] LONG rangeEnd, [out, retval] IRichTextRange** ppTextRange);
		/// \brief <em>Specifies the control's Text Services Framework (TSF) mode bias</em>
		///
		/// Retrieves or sets the control's Text Services Framework (TSF) mode bias, controlling which strings
		/// are proposed by IME. IME (Input Method Editor) is a Windows feature making it easy to enter Asian
		/// characters. Any of the values defined by the \c TSFModeBiasConstants enumeration is valid.
		///
		/// \sa IMEMode, IMEConversionMode, TSFModeBiasConstants
		[propget, id(DISPID_RTB_TSFMODEBIAS), helpstring("Retrieves or sets the control's Text Services Framework (TSF) mode bias, controlling which words are proposed by IME.")]
		HRESULT TSFModeBias([out, retval] TSFModeBiasConstants* pValue);
		[propput, id(DISPID_RTB_TSFMODEBIAS), helpstring("Retrieves or sets the control's Text Services Framework (TSF) mode bias, controlling which words are proposed by IME.")]
		HRESULT TSFModeBias([in] TSFModeBiasConstants newValue);
		/// \brief <em>Controls how selected text is drawn</em>
		///
		/// Retrieves or sets whether the background acetate color is used for drawing the selection
		/// background. If set to \c True, the background acetate color is used; otherwise classic Windows
		/// colors are used.
		///
		/// \remarks Requires Rich Edit 6.0 or newer.
		///
		/// \sa BackColor
		[propget, id(DISPID_RTB_USEBKACETATECOLORFORTEXTSELECTION), helpstring("Retrieves or sets whether the background acetate color is used for drawing the selection background. Requires Rich Edit 6.0 or newer.")]
		HRESULT UseBkAcetateColorForTextSelection([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_USEBKACETATECOLORFORTEXTSELECTION), helpstring("Retrieves or sets whether the background acetate color is used for drawing the selection background. Requires Rich Edit 6.0 or newer.")]
		HRESULT UseBkAcetateColorForTextSelection([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether to activate built-in spell-checking of Windows</em>
		///
		/// Retrieves or sets whether the built-in spell-checking of Windows is activated. If set to \c True,
		/// built-in spell-checking is activated; otherwise not.
		///
		/// \remarks Requires Rich Edit 7.5 and Windows 8 or newer.
		///
		/// \sa UseTouchKeyboardAutoCorrection, IRichTextFont::Locale
		[propget, id(DISPID_RTB_USEBUILTINSPELLCHECKING), helpstring("Retrieves or sets whether the built-in spell-checking of Windows is activated. Requires Rich Edit 7.5 and Windows 8 or newer.")]
		HRESULT UseBuiltInSpellChecking([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_USEBUILTINSPELLCHECKING), helpstring("Retrieves or sets whether the built-in spell-checking of Windows is activated. Requires Rich Edit 7.5 and Windows 8 or newer.")]
		HRESULT UseBuiltInSpellChecking([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls which formatting rectangle the control is using</em>
		///
		/// Retrieves or sets whether the control uses the formatting rectangle defined by the
		/// \c FormattingRectangle* properties.\n
		/// The visibility of the control's text is governed by the dimensions of its window rectangle and its
		/// formatting rectangle. The formatting rectangle is a construct maintained by the system for
		/// formatting the text displayed in the window rectangle. When an edit control is first displayed, the
		/// two rectangles are identical on the screen. An application can make the formatting rectangle larger
		/// than the window rectangle (thereby limiting the visibility of the control's text) or smaller than
		/// the window rectangle (thereby creating extra white space around the text).\n
		/// If this property is set to \c False, the formatting rectangle is set to its default values.
		/// Otherwise it's defined by the \c FormattingRectangle* properties.
		///
		/// \remarks This property is ignored, if the \c MultiLine property is set to \c False.
		///
		/// \sa FormattingRectangleHeight, FormattingRectangleLeft, FormattingRectangleTop,
		///     FormattingRectangleWidth, MultiLine
		[propget, id(DISPID_RTB_USECUSTOMFORMATTINGRECTANGLE), helpstring("Retrieves or sets whether the control uses the formatting rectangle defined by the 'FormattingRectangle*' properties. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT UseCustomFormattingRectangle([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_USECUSTOMFORMATTINGRECTANGLE), helpstring("Retrieves or sets whether the control uses the formatting rectangle defined by the 'FormattingRectangle*' properties. This property is ignored, if the 'MultiLine' property is set to 'False'.")]
		HRESULT UseCustomFormattingRectangle([in] VARIANT_BOOL newValue);
		/// \brief <em>Controls automatic font switching</em>
		///
		/// Retrieves or sets whether the control switches to an English font for ASCII text and to an Asian
		/// font for Asian text. If set to \c True, the font is switched automatically depending on the kind of
		/// text. This is the so-called dual font mode. If set to \c False, the same font (usually an Asian
		/// font) is used for all text.
		///
		/// \sa SwitchFontOnIMEInput, IMEMode, IRichTextRange::Font
		[propget, id(DISPID_RTB_USEDUALFONTMODE), helpstring("Retrieves or sets whether the control switches to an English font for ASCII text and to an Asian font for Asian text (dual font mode).")]
		HRESULT UseDualFontMode([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_USEDUALFONTMODE), helpstring("Retrieves or sets whether the control switches to an English font for ASCII text and to an Asian font for Asian text (dual font mode).")]
		HRESULT UseDualFontMode([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether nested fractions in math zones are displayed in a smaller font</em>
		///
		/// Retrieves or sets whether nested fractions within math zones are displayed in a smaller font or in
		/// normal font size. If set to \c True, a smaller font is used; otherwise not.
		///
		/// \remarks Requires Rich Edit 8.0 or newer.
		///
		/// \sa IRichTextFont::Size, IRichTextFont::IsMathZone, IRichTextRange::BuildUpMath
		[propget, id(DISPID_RTB_USESMALLERFONTFORNESTEDFRACTIONS), helpstring("Retrieves or sets whether nested fractions within math zones are displayed in a smaller font or in normal font size. Requires Rich Edit 8.0 or newer.")]
		HRESULT UseSmallerFontForNestedFractions([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_USESMALLERFONTFORNESTEDFRACTIONS), helpstring("Retrieves or sets whether nested fractions within math zones are displayed in a smaller font or in normal font size. Requires Rich Edit 8.0 or newer.")]
		HRESULT UseSmallerFontForNestedFractions([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control uses Windows Text Services Framework</em>
		///
		/// Retrieves or sets whether the control uses
		/// <a href="https://msdn.microsoft.com/en-us/library/ms629032.aspx">Windows Text Services Framework</a>
		/// (TSF). If set to \c True, TSF is used; otherwise not.
		///
		/// \sa IMEMode, AllowInputThroughTSF, AllowObjectInsertionThroughTSF, AllowTSFProofingTips,
		///     AllowTSFSmartTags,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms629032.aspx">Text Services Framework</a>
		[propget, id(DISPID_RTB_USETEXTSERVICESFRAMEWORK), helpstring("Retrieves or sets whether the control uses Windows Text Services Framework.")]
		HRESULT UseTextServicesFramework([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_USETEXTSERVICESFRAMEWORK), helpstring("Retrieves or sets whether the control uses Windows Text Services Framework.")]
		HRESULT UseTextServicesFramework([in] VARIANT_BOOL newValue);
		// \brief <em>Specifies whether to activate auto-correction for touch input</em>
		//
		// Retrieves or sets whether the built-in auto-correction of Windows is used when text is entered via
		// a touch screen keyboard. If set to \c True, built-in auto-correction is activated; otherwise not.
		//
		// \remarks Requires Rich Edit 7.5 and Windows 8 or newer.
		//
		// \sa UseBuiltInSpellChecking, IRichTextFont::Locale
		//[propget, id(DISPID_RTB_USETOUCHKEYBOARDAUTOCORRECTION), helpstring("Retrieves or sets whether the built-in auto-correction of Windows is used when text is entered via a touch screen keyboard. Requires Rich Edit 7.5 and Windows 8 or newer.")]
		//HRESULT UseTouchKeyboardAutoCorrection([out, retval] VARIANT_BOOL* pValue);
		//[propput, id(DISPID_RTB_USETOUCHKEYBOARDAUTOCORRECTION), helpstring("Retrieves or sets whether the built-in auto-correction of Windows is used when text is entered via a touch screen keyboard. Requires Rich Edit 7.5 and Windows 8 or newer.")]
		//HRESULT UseTouchKeyboardAutoCorrection([in] VARIANT_BOOL newValue);
		/// \brief <em>Specifies whether the control is drawn using the Windows Theming Engine</em>
		///
		/// Retrieves or sets whether the control draws itself using the Windows Theming engine. For instance
		/// this affects the appearance of the control's borders.\n
		/// If set to \c True, the theming engine is used; otherwise not.
		///
		/// \attention Changing this property destroys and recreates the control window.
		///
		/// \remarks Requires Rich Edit 6.0 or newer.
		///
		/// \sa Appearance, BorderStyle
		[propget, id(DISPID_RTB_USEWINDOWSTHEMES), helpstring("Retrieves or sets whether the control draws itself using the Windows Theming engine. Changing this property destroys and recreates the control window. Requires Rich Edit 6.0 or newer.")]
		HRESULT UseWindowsThemes([out, retval] VARIANT_BOOL* pValue);
		[propput, id(DISPID_RTB_USEWINDOWSTHEMES), helpstring("Retrieves or sets whether the control draws itself using the Windows Theming engine. Changing this property destroys and recreates the control window. Requires Rich Edit 6.0 or newer.")]
		HRESULT UseWindowsThemes([in] VARIANT_BOOL newValue);
		/// \brief <em>Retrieves the control's version</em>
		///
		/// \remarks This property is read-only.
		[propget, id(DISPID_RTB_VERSION), helpstring("Retrieves the control's version."), nonbrowsable]
		HRESULT Version([out, retval] BSTR* pValue);
		/// \brief <em>Controls word processing</em>
		///
		/// Retrieves or sets the function that is responsible to tell the control where a word starts and
		/// where it ends. This property takes the address of a function having the following signature:\n
		/// \code
		///   FindWorkBreak(ByVal pText As Long, ByVal startPosition As Long, ByVal textLength As Long, ByVal flags As Long) As Long
		/// \endcode
		/// The \c pText argument is a pointer to the control's text. In ANSI builds of the control, this text
		/// is encoded in ANSI; otherwise it's encoded in Unicode.\n
		/// The \c startPosition argument specifies the (zero-based) position within the text, at which the
		/// function should begin checking for a word break.\n
		/// The \c textLength argument specifies the length of the text pointed to by \c pText in characters.\n
		/// The \c flags argument specifies the action to be taken by the function. This can be one of the
		/// following values:
		/// - \c WB_CLASSIFY Retrieve the character class and word break flags of the character at the
		///   specified position.
		/// - \c WB_ISDELIMITER Check whether the character at the specified position is a delimiter.
		/// - \c WB_LEFT Find the beginning of a word to the left of the specified position.
		/// - \c WB_LEFTBREAK Find the end-of-word delimiter to the left of the specified position.
		/// - \c WB_MOVEWORDLEFT Find the beginning of a word to the left of the specified position. This value
		///   is used during [CTRL]+[LEFT] key processing.
		/// - \c WB_MOVEWORDRIGHT Find the beginning of a word to the right of the specified position. This
		///   value is used during [CTRL]+[RIGHT] key processing.
		/// - \c WB_RIGHT Find the beginning of a word to the right of the specified position. This is useful
		///   in right-aligned rich edit controls.
		/// - \c WB_RIGHTBREAK Find the end-of-word delimiter to the right of the specified position. This is
		///   useful in right-aligned rich edit controls.
		///
		/// If the \c flags parameter specifies \c WB_CLASSIFY, the return value is the character class and
		/// word break flags of the character at the specified position.\n
		/// If the \c flags parameter specifies \c WB_ISDELIMITER and the character at the specified position
		/// is a delimiter, the function must return a non-zero value.\n
		/// If the \c flags parameter specifies \c WB_ISDELIMITER and the character at the specified position
		/// is not a delimiter, the function must return zero.\n
		/// If the \c flags parameter specifies \c WB_LEFT or \c WB_RIGHT, the function must return the
		/// (zero-based) index to the beginning of a word in the specified text.\n\n
		/// If this property is set to 0, the system's internal function is used.
		///
		/// \sa Text, IRichTextParagraph::HAlignment,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms672125.aspx">EditWordBreakProc</a>
		[propget, id(DISPID_RTB_WORDBREAKFUNCTION), helpstring("Retrieves or sets the function that is responsible to tell the control where a word starts and where it ends."), nonbrowsable]
		HRESULT WordBreakFunction([out, retval] LONG* pValue);
		[propput, id(DISPID_RTB_WORDBREAKFUNCTION), helpstring("Retrieves or sets the function that is responsible to tell the control where a word starts and where it ends."), nonbrowsable]
		HRESULT WordBreakFunction([in] LONG newValue);
		/// \brief <em>Specifies the zoom ratio</em>
		///
		/// Retrieves or sets the zoom ratio. Any value between 1/64 and 64 is valid. If set to 0, no zooming
		/// is applied.
		///
		/// \sa Font
		[propget, id(DISPID_RTB_ZOOMRATIO), helpstring("Retrieves or sets the zoom ratio. Any value between 1/64 and 64 is valid. If set to 0, no zooming is applied.")]
		HRESULT ZoomRatio([out, retval] DOUBLE* pValue);
		[propput, id(DISPID_RTB_ZOOMRATIO), helpstring("Retrieves or sets the zoom ratio. Any value between 1/64 and 64 is valid. If set to 0, no zooming is applied.")]
		HRESULT ZoomRatio([in] DOUBLE newValue);

		/// \brief <em>Displays the control's credits</em>
		///
		/// Displays some information about this control and its author.
		[id(DISPID_RTB_ABOUT), helpstring("Displays some information about this control and its author.")]
		HRESULT About(void);
		/// \brief <em>Closes the current undo action and starts a new one</em>
		///
		/// Stops the control from collecting additional typing actions into the current undo action. The
		/// control stores the next typing action, if any, into a new action in the undo queue.\n
		/// The control groups consecutive typing actions, including characters deleted by using the
		/// [BACKSPACE] key, into a single undo action until one of the following events occurs:
		/// - \c BeginNewUndoAction is called.
		/// - The control loses focus.
		/// - The user moves the current selection, either by using the arrow keys or by clicking the mouse.
		/// - The user presses the [DEL] key.
		/// - The user performs any other action, such as a paste operation that does not involve typing.
		///
		/// \sa CanUndo, Undo, EmptyUndoBuffer, MaxUndoQueueSize
		[id(DISPID_RTB_BEGINNEWUNDOACTION), helpstring("Stops the control from collecting additional typing actions into the current undo action. The control stores the next typing action, if any, into a new action in the undo queue.")]
		HRESULT BeginNewUndoAction(void);
		/// \brief <em>Determines whether data can be copied to the clipboard</em>
		///
		/// \return \c True if data can be copied (i.e. there is a selection); otherwise \c False.
		///
		/// \sa Copy, Paste
		[id(DISPID_RTB_CANCOPY), helpstring("Determines whether data can be copied to the clipboard (i.e. there is a selection).")]
		HRESULT CanCopy([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Determines whether there are any actions in the control's redo queue</em>
		///
		/// \return \c True if there are actions in the redo queue; otherwise \c False.
		///
		/// \sa Redo, CanUndo, NextRedoActionType, EmptyUndoBuffer
		[id(DISPID_RTB_CANREDO), helpstring("Determines whether there are any actions in the control's redo queue.")]
		HRESULT CanRedo([out, retval] VARIANT_BOOL* pValue);
		/// \brief <em>Determines whether there are any actions in the control's undo queue</em>
		///
		/// \return \c True if there are actions in the undo queue; otherwise \c False.
		///
		/// \sa Undo, CanRedo, NextUndoActionType, BeginNewUndoAction, EmptyUndoBuffer
		[id(DISPID_RTB_CANUNDO), helpstring("Determines whether there are any actions in the control's undo queue.")]
		HRESULT CanUndo([out, retval] VARIANT_BOOL* pValue);
		// \brief <em>Retrieves the specified character's position in client coordinates</em>
		//
		// Retrieves the position (in pixels) of the specified character within the control's client area.
		//
		// \param[in] characterIndex The zero-based index of the character within the control, for which to
		//            retrieve the position. If the character is a line delimiter, the returned coordinates
		//            indicate a point just beyond the last visible character in the line. If the specified
		//            index is greater than the index of the last character in the control, the function
		//            fails.
		// \param[out] x The x-coordinate (in pixels) of the character relative to the control's upper-left
		//             corner.
		// \param[out] y The y-coordinate (in pixels) of the character relative to the control's upper-left
		//             corner.
		//
		// \sa PositionToCharIndex
		//[id(DISPID_RTB_CHARINDEXTOPOSITION), helpstring("Retrieves the position (in pixels) of the specified character within the control's client area.")]
		//HRESULT CharIndexToPosition([in] LONG characterIndex, [in, out, defaultvalue(0)] OLE_XPOS_PIXELS* x, [in, out, defaultvalue(0)] OLE_YPOS_PIXELS* y);
		/// \brief <em>Raises the ShouldResizeControlWindow event</em>
		///
		/// Checks whether the control's content is smaller or larger than the control's window size and raises
		/// the \c ShouldResizeControlWindow event.
		///
		/// \sa _IRichTextBoxEvents::ShouldResizeControlWindow
		[id(DISPID_RTB_CHECKFOROPTIMALCONTROLWINDOWSIZE), helpstring("Checks whether the control's content is smaller or larger than the control's window size and raises the 'ShouldResizeControlWindow' event.")]
		HRESULT CheckForOptimalControlWindowSize(void);
		/// \brief <em>Closes the Text Services Framework (TSF) keyboard</em>
		///
		/// Closes the Text Services Framework (TSF) keyboard.
		///
		/// \sa OpenTSFKeyboard
		[id(DISPID_RTB_CLOSETSFKEYBOARD), helpstring("Closes the Text Services Framework (TSF) keyboard.")]
		HRESULT CloseTSFKeyboard(void);
		/// \brief <em>Starts a new document</em>
		///
		/// Starts a new document, resetting any input.
		///
		/// \sa LoadFromFile, SaveToFile, get_Text
		[id(DISPID_RTB_CREATENEWDOCUMENT), helpstring("Starts a new document, resetting any input.")]
		HRESULT CreateNewDocument(void);
		/// \brief <em>Clears the control's undo and redo queues</em>
		///
		/// \sa CanUndo, Undo, BeginNewUndoAction, MaxUndoQueueSize
		[id(DISPID_RTB_EMPTYUNDOBUFFER), helpstring("Clears the control's undo and redo queues.")]
		HRESULT EmptyUndoBuffer(void);
		/// \brief <em>Finishes a pending drop operation</em>
		///
		/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop event has been
		/// handled. This order is intended by Microsoft Windows. However, if a message box is displayed from
		/// within the \c OLEDragDrop event, or the drop operation cannot be performed asynchronously and takes
		/// a long time, it may be desirable to remove the drag image earlier.\n
		/// This method will break the intended order and finish the drag'n'drop operation (including removal
		/// of the drag image) immediately.
		///
		/// \remarks This method will fail if not called from the \c OLEDragDrop event handler or if no drag
		///          images are used.
		///
		/// \sa _IRichTextBoxEvents::OLEDragDrop, SupportOLEDragImages
		[id(DISPID_RTB_FINISHOLEDRAGDROP), helpstring("Finishes a pending drop operation from within the 'OLEDragDrop' event, removing the drag image, but breaking the intended order. See documentation for details.")]
		HRESULT FinishOLEDragDrop(void);
		/// \brief <em>Deactivates screen updating</em>
		///
		/// Disables automatic redrawing of the control. Disabling redraw while doing large changes on the
		/// control may increase performance.\n
		/// On each call the internal freeze counter is <strong>incremented</strong>. As long as this counter
		/// is nonzero, the control is not redrawn.
		///
		/// \return The updated freeze count.
		///
		/// \sa Unfreeze
		[id(DISPID_RTB_FREEZE), helpstring("Disables automatic redrawing of the control. On each call the internal freeze counter is incremented. As long as this counter is nonzero, the control is not redrawn.")]
		HRESULT Freeze([out, retval] LONG* pNewCount);
		/// \brief <em>Retrieves the current IME composition text</em>
		///
		/// Retrieves the text currently being composed by the Input Method Editor (IME).
		///
		/// \param[in] textType The type of text to retrieve. Any of the values defined by the
		///            \c IMECompositionTextType enumeration is valid.
		///
		/// \return The currently composed string.
		///
		/// \sa IMEMode, CurrentIMECompositionMode, IMECompositionTextType
		[id(DISPID_RTB_GETCURRENTIMECOMPOSITIONTEXT), helpstring("Retrieves the text currently being composed by the Input Method Editor (IME).")]
		HRESULT GetCurrentIMECompositionText([in, defaultvalue(imecttFinalComposedString)] IMECompositionTextType textType, [out, retval] BSTR* pCompositionText);
		// \brief <em>Retrieves the zero-based index of the first character of the specified line</em>
		//
		// \param[in] lineIndex The zero-based index of the line to retrieve the first character for. If set
		//            to -1, the index of the line containing the caret is used.
		//
		// \return The zero-based index of the first character of the line. -1 if the specified line index is
		//         greater than the total number of lines.
		//
		// \sa GetLineFromChar, MultiLine
		//[id(DISPID_RTB_GETFIRSTCHAROFLINE), helpstring("Retrieves the zero-based index of the first character of the specified line.")]
		//HRESULT GetFirstCharOfLine([in] LONG lineIndex, [out, retval] LONG* pValue);
		// \brief <em>Retrieves the text of the specified line</em>
		//
		// \param[in] lineIndex The zero-based index of the line to retrieve the text for.
		//
		// \return The line's text.
		//
		// \sa GetLineLength, MultiLine, Text
		//[id(DISPID_RTB_GETLINE), helpstring("Retrieves the text of the specified line.")]
		//HRESULT GetLine([in] LONG lineIndex, [out, retval] BSTR* pValue);
		/// \brief <em>Retrieves the number of lines in the control</em>
		///
		/// \return The number of lines.
		///
		/// \sa FirstVisibleLine, MultiLine
		[id(DISPID_RTB_GETLINECOUNT), helpstring("Retrieves the number of lines in the control.")]
		HRESULT GetLineCount([out, retval] LONG* pValue);
		// \brief <em>Retrieves the zero-based index of the line that contains the specified character</em>
		//
		// \param[in] characterIndex The zero-based index of the character within the control. If set to
		//            -1, the index of the character at which the selection begins, is used. If there's no
		//            selection, the index of the character next to the caret is used.
		//
		// \return The zero-based index of the line containing the character.
		//
		// \sa FirstVisibleChar, GetFirstCharOfLine, MultiLine, SelectionStart
		//[id(DISPID_RTB_GETLINEFROMCHAR), helpstring("Retrieves the zero-based index of the line that contains the specified character.")]
		//HRESULT GetLineFromChar([in] LONG characterIndex, [out, retval] LONG* pValue);
		// \brief <em>Retrieves the number of characters in the specified line</em>
		//
		// \param[in] lineIndex The zero-based index of the line to retrieve the length for. If set to -1, the
		//            number of unselected characters on lines containing selected characters is retrieved.
		//            E. g. if the selection extended from the fourth character of one line through the eighth
		//            character from the end of the next line, the return value would be 10 (three characters
		//            on the first line and seven on the next).
		//
		// \return The number of characters in the line.
		//
		// \sa GetLine, MultiLine
		//[id(DISPID_RTB_GETLINELENGTH), helpstring("Retrieves the number of characters in the specified line.")]
		//HRESULT GetLineLength([in] LONG lineIndex, [out, retval] LONG* pValue);
		// \brief <em>Retrieves the current selection's start and end</em>
		//
		// Retrieves the zero-based character indices of the current selection's start and end.
		//
		// \param[out] selectionStart The zero-based index of the character at which the selection starts.
		// \param[out] selectionEnd The zero-based index of the first unselected character after the end of
		//             the selection.
		//
		// \remarks If \c MultiSelect is activated, the text range returned by this method refers to the
		//          active sub-range.
		//
		// \sa SetSelection, ReplaceSelectedText, SelectedText, SelectedTextRange, MultiSelect
		//[id(DISPID_RTB_GETSELECTION), helpstring("Retrieves the zero-based character indices of the current selection's start and end.")]
		//HRESULT GetSelection([in, out, defaultvalue(0)] LONG* selectionStart, [in, out, defaultvalue(0)] LONG* selectionEnd);
		/// \brief <em>Hit-tests the specified point</em>
		///
		/// Retrieves the control's parts that lie below the point ('x'; 'y').
		///
		/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the
		///            control's upper-left corner.
		/// \param[in,out] hitTestDetails Receives a value specifying the exact part of the control the
		///                specified point lies in. Any of the values defined by the \c HitTestConstants
		///                enumeration is valid.
		///
		/// \return The text range that the specified point belongs to. \c Nothing, if no text was "hit".
		///
		/// \sa IRichTextRange, HitTestConstants
		[id(DISPID_RTB_HITTEST), helpstring("Retrieves the control's parts that lie below the point ('x'; 'y').")]
		HRESULT HitTest([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out] HitTestConstants* hitTestDetails, [out, retval] IRichTextRange** ppHitRange);
		/// \brief <em>Loads rich text from a file</em>
		///
		/// Loads rich text from a file. It can be a plain text file, or a rtf file.
		///
		/// \param[in] file The file to load.
		/// \param[in] fileCreationDisposition Specifies how to open the file. Any of the values defined by the
		///            \c FileCreationDispositionConstants enumeration is valid.
		/// \param[in] fileType The type of the file to load. Any of the values defined by the
		///            \c FileTypeConstants enumeration is valid.
		/// \param[in] fileAccessOptions Further options to apply. Any combination of the values defined by the
		///            \c FileAccessOptionConstants enumeration is valid.
		/// \param[in] codePage The code page to use for the file. If set to 0, the ANSI code page (\c CP_ACP)
		///            will be used unless the file begins with a Unicode BOM (0xFEFF), in which case the file
		///            is considered to be Unicode.
		///
		/// \return \c True if the file could be loaded; otherwise \c False.
		///
		/// \sa SaveToFile, CreateNewDocument, Text, FileCreationDispositionConstants, FileTypeConstants,
		///     FileAccessOptionConstants
		[id(DISPID_RTB_LOADFROMFILE), helpstring("Loads rich text from a file. It can be a plain text file, or a rtf file.")]
		HRESULT LoadFromFile([in] BSTR file, [in, defaultvalue(fcdOpenExisting)] FileCreationDispositionConstants fileCreationDisposition, [in, defaultvalue(ftyAutoDetect)] FileTypeConstants fileType, [in, defaultvalue(faoDefault)] FileAccessOptionConstants fileAccessOptions, [in, defaultvalue(0)] LONG codePage, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Enters OLE drag'n'drop mode</em>
		///
		/// \param[in] pDataObject A pointer to the \c IDataObject implementation to use during OLE
		///            drag'n'drop. If not specified, the control's own implementation is used.
		/// \param[in] supportedEffects A bit field defining all drop effects you want to support. Any
		///            combination of the values defined by the \c OLEDropEffectConstants enumeration
		///            (except \c odeScroll) is valid.
		/// \param[in] hWndToAskForDragImage The handle of the window, that will receive the
		///            \c DI_GETDRAGIMAGE message to specify the drag image to use. If -1, the control
		///            creates the drag image itself. If \c SupportOLEDragImages is set to \c False, no
		///            drag image is used.
		/// \param[in] draggedTextRange The range of text to drag. This parameter is used to generate the
		///            drag image, if \c hWndToAskForDragImage is set to -1.
		/// \param[in] itemCountToDisplay The number to display in the item count label of Aero drag images.
		///            If set to 0 or 1, no item count label is displayed. If set to any value larger than 1,
		///            this value is displayed in the item count label.
		///
		/// \return The performed drop effect. Any of the values defined by the \c OLEDropEffectConstants
		///         enumeration (except \c odeScroll) is valid.
		///
		/// \sa IRichTextRange, _IRichTextBoxEvents::BeginDrag, _IRichTextBoxEvents::BeginRDrag,
		///     _IRichTextBoxEvents::OLEStartDrag, _IRichTextBoxEvents::OLEGiveFeedback,
		///     _IRichTextBoxEvents::OLEQueryContinueDrag,
		///     SupportOLEDragImages, OLEDragImageStyle, OLEDropEffectConstants,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
		[id(DISPID_RTB_OLEDRAG), helpstring("Enters OLE drag'n'drop mode.")]
		HRESULT OLEDrag([in, defaultvalue(NULL)] LONG* pDataObject, [in, defaultvalue(odeCopyOrMove)] OLEDropEffectConstants supportedEffects, [in, defaultvalue(-1)] OLE_HANDLE hWndToAskForDragImage, [in, defaultvalue(NULL)] IRichTextRange* draggedTextRange, [in, defaultvalue(0)] LONG itemCountToDisplay, [out, retval] OLEDropEffectConstants* pPerformedEffects);
		/// \brief <em>Opens the Text Services Framework (TSF) keyboard</em>
		///
		/// Opens the Text Services Framework (TSF) keyboard.
		///
		/// \sa CloseTSFKeyboard
		[id(DISPID_RTB_OPENTSFKEYBOARD), helpstring("Opens the Text Services Framework (TSF) keyboard.")]
		HRESULT OpenTSFKeyboard(void);
		// \brief <em>Retrieves the character closest to the specified position</em>
		//
		// Retrieves the zero-based index of the character nearest the specified position.
		//
		// \param[in] x The x-coordinate (in pixels) of the position to retrieve the nearest character for. It
		//            is relative to the control's upper-left corner.
		// \param[in] y The y-coordinate (in pixels) of the position to retrieve the nearest character for. It
		//            is relative to the control's upper-left corner.
		// \param[out] characterIndex The zero-based index of the character within the control, that is
		//             nearest to the specified position. If the specified point is beyond the last character
		//             in the control, this value indicates the last character in the control. The index
		//             indicates the line delimiter if the specified point is beyond the last visible
		//             character in a line.
		// \param[out] lineIndex The zero-based index of the line, that contains the character specified by
		//             the \c characterIndex parameter.
		//
		// \remarks If a point outside the bounds of the control is passed, the function fails.
		//
		// \sa CharIndexToPosition
		//[id(DISPID_RTB_POSITIONTOCHARINDEX), helpstring("Retrieves the zero-based index of the character nearest the specified position.")]
		//HRESULT PositionToCharIndex([in] OLE_XPOS_PIXELS x, [in] OLE_YPOS_PIXELS y, [in, out, defaultvalue(0)] LONG* characterIndex, [in, out, defaultvalue(0)] LONG* lineIndex);
		/// \brief <em>Redoes the next action(s) in the control's redo queue</em>
		///
		/// \param[in] numberOfActions The count of actions to redo.
		///
		/// \return The count of actions that actually have been redone.
		///
		/// \sa CanRedo, Undo, NextRedoActionType, EmptyUndoBuffer
		[id(DISPID_RTB_REDO), helpstring("Redoes the next action(s) in the control's redo queue.")]
		HRESULT Redo([in, defaultvalue(1)] LONG numberOfActions, [out, retval] LONG* pCount);
		/// \brief <em>Advises the control to redraw itself</em>
		[id(DISPID_RTB_REFRESH), helpstring("Advises the control to redraw itself.")]
		HRESULT Refresh(void);
		// \brief <em>Replaces the currently selected text</em>
		//
		// Replaces the control's currently selected text.
		//
		// \param[in] replacementText The text that replaces the currently selected text.
		// \param[in] undoable If \c True, this action is inserted into the control's undo queue; otherwise
		//            not.
		//
		// \remarks If \c MultiSelect is activated, only the text of the active sub-range is replaced.
		//
		// \sa SelectedTextRange, IRichTextRange::Text
		//[id(DISPID_RTB_REPLACESELECTEDTEXT), helpstring("Replaces the control's currently selected text.")]
		//HRESULT ReplaceSelectedText([in] BSTR replacementText, [in, defaultvalue(0)] VARIANT_BOOL undoable);
		/// \brief <em>Saves rich text to a file</em>
		///
		/// Saves rich text to a file. It can be a plain text file, or a rtf file.
		///
		/// \param[in] file The file to save to. If not specified, the document's current filename is used. If
		///            this is not specified as well, the method fails.
		/// \param[in] fileCreationDisposition Specifies how to save the file. Any of the values defined by the
		///            \c FileCreationDispositionConstants enumeration is valid.
		/// \param[in] fileType The format to save the file in. Any of the values defined by the
		///            \c FileTypeConstants enumeration is valid.
		/// \param[in] fileAccessOptions Further options to apply. Any combination of the values defined by the
		///            \c FileAccessOptionConstants enumeration is valid.
		/// \param[in] codePage The code page to use for the file. Common values are 0 (\c CP_ACP, ANSI code
		///            page) and 65001 (UTF-8 code page).
		///
		/// \return \c True if the file could be saved; otherwise \c False.
		///
		/// \sa LoadFromFile, CreateNewDocument, Text, FileCreationDispositionConstants, FileTypeConstants,
		///     FileAccessOptionConstants
		[id(DISPID_RTB_SAVETOFILE), helpstring("Saves rich text to a file. It can be a plain text file, or a rtf file.")]
		HRESULT SaveToFile([in, defaultvalue("")] BSTR file, [in, defaultvalue(0)] FileCreationDispositionConstants fileCreationDisposition, [in, defaultvalue(ftyAutoDetect)] FileTypeConstants fileType, [in, defaultvalue(faoDefault)] FileAccessOptionConstants fileAccessOptions, [in, defaultvalue(0)] LONG codePage, [out, retval] VARIANT_BOOL* pSucceeded);
		/// \brief <em>Scrolls the control</em>
		///
		/// \param[in] axis The axis which is to be scrolled. Any combination of the values defined by the
		///            \c ScrollAxisConstants enumeration is valid.
		/// \param[in] directionAndIntensity The intensity and direction of the action. Any of the values
		///            defined by the \c ScrollDirectionConstants enumeration is valid.
		/// \param[in] linesToScrollVertically The number of lines to scroll vertically. This parameter is
		///            ignored, if \c directionAndIntensity is not set to \c sdCustom.
		/// \param[in] charactersToScrollHorizontally The number of characters to scroll horizontally. This
		///            parameter is ignored, if \c directionAndIntensity is not set to \c sdCustom.
		///
		/// \remarks This method has no effect if the \c MultiLine property is set to \c False.
		///
		/// \sa IRichTextRange::ScrollIntoView, ScrollToTopOnKillFocus, ScrollBars, AutoScrolling, MultiLine,
		///     _IRichTextBoxEvents::Scrolling, ScrollAxisConstants, ScrollDirectionConstants
		[id(DISPID_RTB_SCROLL), helpstring("Scrolls the control. This method has no effect if the 'MultiLine' property is set to 'False'.")]
		HRESULT Scroll([in] ScrollAxisConstants axis, [in] ScrollDirectionConstants directionAndIntensity, [in, defaultvalue(0)] LONG linesToScrollVertically, [in, defaultvalue(0)] LONG charactersToScrollHorizontally);
		// \brief <em>Scrolls the control so that the caret is visible</em>
		//
		// Ensures that the control's caret is visible by scrolling the control if necessary.
		//
		// \sa Scroll, ScrollToTopOnKillFocus, ScrollBars, AutoScrolling, MultiLine,
		//     _IRichTextBoxEvents::Scrolling
		//[id(DISPID_RTB_SCROLLCARETINTOVIEW), helpstring("Ensures that the control's caret is visible by scrolling the control if necessary.")]
		//HRESULT ScrollCaretIntoView(void);
		// \brief <em>Sets the selection's start and end</em>
		//
		// Sets the zero-based character indices of the selection's start and end.
		//
		// \param[in] selectionStart The zero-based index of the character at which the selection starts. If
		//            set to -1, the current selection is cleared.
		// \param[in] selectionEnd The zero-based index of the first unselected character after the end of
		//            the selection.
		//
		// \remarks To select all text in the control, set \c selectionStart to 0 and \c selectionEnd to -1.\n
		//          If \c MultiSelect is enabled, this method replaces only the active sub-range.
		//
		// \sa GetSelection, ReplaceSelectedText, SelectedText, SelectedTextRange, MultiSelect
		//[id(DISPID_RTB_SETSELECTION), helpstring("Sets the zero-based character indices of the selection's start and end.")]
		//HRESULT SetSelection([in] LONG selectionStart, [in] LONG selectionEnd);
		/// \brief <em>Sets the target device</em>
		///
		/// Sets the device context and the line width (in twips) that the control will optimize output for.
		/// The device context usually is a printer. The line width can be set to the width of a paper format
		/// like DIN A4. It has to be in twips though and the client application should ensure that the target
		/// device supports this format.
		///
		/// \param[in] hDC The handle of the device context to optimize output for.
		/// \param[in] lineWidth The line width (in twips) to use.
		///
		/// \remarks Setting both parameters to 0 will make words wrap on the control boundaries.\n
		///          Setting \c hDC to NULL and \c lineWidth to 1 will disable word-wrapping.
		///
		/// \sa AutoScrolling, ScrollBars
		[id(DISPID_RTB_SETTARGETDEVICE), helpstring("Sets the device context and the line width (in twips) that the control will optimize output for.")]
		HRESULT SetTargetDevice([in] OLE_HANDLE hDC, [in] LONG lineWidth);
		/// \brief <em>Displays the IME reconversion dialog</em>
		///
		/// Invokes the Input Method Editor (IME) reconversion dialog box.
		///
		/// \sa IMEMode
		[id(DISPID_RTB_STARTIMERECONVERSION), helpstring("Invokes the Input Method Editor (IME) reconversion dialog box.")]
		HRESULT StartIMEReconversion(void);
		/// \brief <em>Undoes the last action(s) in the control's undo queue</em>
		///
		/// \param[in] numberOfActions The count of actions to undo. This parameter can also be set to some
		///            special values:
		///            - 0 - Stops collecting undo actions and empties the undo buffer.
		///            - -1 - Restarts undo again.
		///            - -9999995 - Suspends collecting undo actions.
		///            - -9999994 - Resumes collecting undo actions.
		///
		/// \return The count of actions that actually have been undone.
		///
		/// \sa CanUndo, Redo, NextUndoActionType, BeginNewUndoAction, EmptyUndoBuffer, MaxUndoQueueSize
		[id(DISPID_RTB_UNDO), helpstring("Undoes the last action(s) in the control's undo queue.")]
		HRESULT Undo([in, defaultvalue(1)] LONG numberOfActions, [out, retval] LONG* pCount);
		/// \brief <em>Activates screen updating</em>
		///
		/// Enables automatic redrawing of the control. Disabling redraw while doing large changes on the
		/// control may increase performance.\n
		/// On each call the internal freeze counter is <strong>decremented</strong>. As long as this counter
		/// is nonzero, the control is not redrawn.
		///
		/// \return The updated freeze count.
		///
		/// \sa Freeze
		[id(DISPID_RTB_UNFREEZE), helpstring("Enables automatic redrawing of the control. On each call the internal freeze counter is decremented. As long as this counter is nonzero, the control is not redrawn.")]
		HRESULT Unfreeze([out, retval] LONG* pNewCount);
	};


	/// \interface _IRichTextBoxEvents
	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c RichTextBox class' events interface</em>
	///
	/// This interface defines all events the \c RichTextBox class may raise.
	///
	/// \sa IRichTextBox
	[
		uuid(E52B742D-4AC0-47ED-A16E-8AFDCA3B6B93),
		helpstring("IRichTextBox-event-interface")
	]
	dispinterface _IRichTextBoxEvents
	{
		properties:
		methods:
			/// \brief <em>The control's text was changed</em>
			///
			/// Will be fired after the control's content was changed.
			///
			/// \remarks This is the control's default event.\n
			///          This event may be disabled.
			///
			/// \sa IRichTextBox::Text
			[id(DISPID_RTBE_TEXTCHANGED), helpstring("Will be fired after the control's content was changed. This event may be disabled.")]
			void TextChanged(void);
			/// \brief <em>The user seems to want to drag text</em>
			///
			/// Will be fired if the user seems to want to drag text using the left mouse button.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the text that the user wants to drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbLeftButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies in.
			///            Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa IRichTextBox::OLEDrag, IRichTextBox::DetectDragDrop, BeginRDrag, HitTestConstants
			[id(DISPID_RTBE_BEGINDRAG), helpstring("Will be fired if the user seems to want to drag text using the left mouse button.")]
			void BeginDrag(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user seems to want to drag text</em>
			///
			/// Will be fired if the user seems to want to drag text using the right mouse button.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the text that the user wants to drag.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid, but usually it is just
			///            \c vbRightButton.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies in.
			///            Some of the values defined by the \c HitTestConstants enumeration are valid.
			///
			/// \sa IRichTextBox::OLEDrag, IRichTextBox::DetectDragDrop, BeginDrag, HitTestConstants
			[id(DISPID_RTBE_BEGINRDRAG), helpstring("Will be fired if the user seems to want to drag text using the right mouse button.")]
			void BeginRDrag(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the left mouse button.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the clicked text.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa DblClick, MClick, RClick, XClick, HitTestConstants, IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_CLICK), helpstring("Will be fired if the user clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void Click(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The context menu should be displayed</em>
			///
			/// Will be fired if the control's context menu should be displayed. The client application can
			/// either pass the generated context menu back to the control which will display it, or it can
			/// display the menu itself, passing no menu back to the control.
			///
			/// \param[in] menuType Specifies which kind of menu is being requested. Some combinations of the
			///            values defined by the \c MenuTypeConstants enumeration are valid.
			/// \param[in] textRange A \c IRichTextRange object wrapping the selected text.
			/// \param[in] selectionType Specifies what kind of data the current selection contains. Any
			///            combination of the values defined by the \c SelectionTypeConstants enumeration is
			///            valid.
			/// \param[in] oleObject A \c IRichOLEObject object wrapping the (first) embedded OLE object within
			///            the current selection. May be \c Nothing.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the menu's proposed position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the menu's proposed position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in] isRightMouseDrop If \c True, the context menu for a drag'n'drop operation with the
			///            right mouse button should be generated. If \c False, the context menu request has been
			///            triggered by a normal right click or by pressing the context menu key (or
			///            [SHIFT]+[F10]) on the keyboard.
			/// \param[in] draggedData A \c IOLEDataObject object that holds the dragged data. May be \c Nothing.
			/// \param[in,out] hMenuToDisplay Receives the handle of the context menu to display. The menu will
			///                be destroyed by the control after use.
			///
			/// \sa RClick, IRichTextRange, IRichOLEObject, IOLEDataObject, MenuTypeConstants,
			///     SelectionTypeConstants, HitTestConstants
			[id(DISPID_RTBE_CONTEXTMENU), helpstring("Will be fired if the control's context menu should be displayed. The client application can either pass the generated context menu back to the control which will display it, or it can display the menu itself, passing no menu back to the control.")]
			void ContextMenu(MenuTypeConstants menuType, IRichTextRange* TextRange, SelectionTypeConstants selectionType, IRichOLEObject* OLEObject, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL isRightMouseDrop, IOLEDataObject* draggedData, OLE_HANDLE* hMenuToDisplay);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the left mouse
			/// button.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the double-clicked text.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa Click, MDblClick, RDblClick, XDblClick, HitTestConstants, IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_DBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the left mouse button. This event may be disabled.")]
			void DblClick(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was destroyed</em>
			///
			/// Will be fired after the control window was destroyed.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa RecreatedControlWindow, IRichTextBox::hWnd
			[id(DISPID_RTBE_DESTROYEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed.")]
			void DestroyedControlWindow(LONG hWnd);
			/// \brief <em>A drag'n'drop operation has completed</em>
			///
			/// Will be fired after a drag'n'drop operation has completed.
			///
			/// \remarks This event is raised only if the \c RegisterForOLEDragDrop property is set to
			///          \c rfoddNativeDragDrop.
			///
			/// \sa RegisterForOLEDragDrop, OLECompleteDrag
			[id(DISPID_RTBE_DRAGDROPDONE), helpstring("Will be fired after a drag'n'drop operation has completed. This event is raised only if the 'RegisterForOLEDragDrop' property is set to 'rfoddNativeDragDrop'.")]
			void DragDropDone(void);
			/// \brief <em>The data object for copy'n'paste is required</em>
			///
			/// Will be fired on copy'n'paste operations to determine the data object that will be used to store
			/// the data during the operation. A default object will be provided, but it may be replaced by the
			/// client application with a custom object.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the text that the operation is performed
			///            on.
			/// \param[in] operationType Specifies the kind of operation that will take place. Some of the values
			///            defined by the \c ClipboardOperationTypeConstants enumeration are valid.
			/// \param[in,out] pDataObject A pointer to an implementation of \c IDataObject that is used to
			///                transfer data during the operation. The client application may change the pointer
			///                to a custom implementation of \c IDataObject.
			/// \param[in,out] useCustomDataObject Must be set to \c True, if the data object has been replaced
			///                with a custom implementation.
			///
			/// \sa QueryAcceptData, IRichTextRange, ClipboardOperationTypeConstants,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>
			[id(DISPID_RTBE_GETDATAOBJECT), helpstring("Will be fired on copy'n'paste operations to determine the data object that will be used to store the data during the operation.")]
			void GetDataObject(IRichTextRange* TextRange, ClipboardOperationTypeConstants operationType, LONG* pDataObject, VARIANT_BOOL* useCustomDataObject);
			/// \brief <em>The preferred drop effect is required during a drag'n'drop operation</em>
			///
			/// Will be fired during drag'n'drop operations to determine the client application's preferred drop
			/// effect. Usually the preferred effect is chosen depending on the pressed modifier keys (Shift,
			/// Ctrl, Alt).
			///
			/// \param[in] getSourceEffects If \c True, the event is raised to determine the effects allowed by
			///            the drag source. Otherwise it is raised to determine the effects allowed by the drop
			///            target.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in,out] skipDefaultProcessing Must be set to \c True to prevent the native rich edit
			///                control chose an effect on its own.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDrop, OLEDropEffectConstants
			[id(DISPID_RTBE_GETDRAGDROPEFFECT), helpstring("Will be fired during drag'n'drop operations to determine the client application's preferred drop effect. Usually the preferred effect is chosen depending on the pressed modifier keys (Shift, Ctrl, Alt).")]
			void GetDragDropEffect(VARIANT_BOOL getSourceEffects, SHORT button, SHORT shift, OLEDropEffectConstants* effect, VARIANT_BOOL* skipDefaultProcessing);
			/// \brief <em>An embedded OLE object is about to be inserted</em>
			///
			/// Will be fired before a new embedded OLE object is inserted.
			///
			/// \param[in] textRange The insertion position at which the new object is about to be inserted.
			/// \param[in,out] classID The class identifier (\c CLSID) of the object that is about to be
			///                inserted.
			/// \param[in] pStorage The \c IStorage object holding the object data.
			/// \param[in,out] cancelInsertion If set to \c True, insertion is aborted, i. e. the object
			///                isn't inserted. If set to \c False, the object is inserted.
			///
			/// \sa RemovingObject, IRichTextRange, IRichOLEObject::ClassID,
			///     <a href="https://msdn.microsoft.com/en-us/library/aa380015.aspx">IStorage</a>
			[id(DISPID_RTBE_INSERTINGOLEOBJECT), helpstring("Will be fired before a new embedded OLE object is inserted.")]
			void InsertingOLEObject(IRichTextRange* TextRange, BSTR* ClassID, LONG pStorage, VARIANT_BOOL* cancelInsertion);
			/// \brief <em>A key was pressed while the control has the focus</em>
			///
			/// Will be fired if the user presses a key while the control has the focus.
			///
			/// \param[in,out] keyCode The pressed key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyUp, KeyPress, IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_KEYDOWN), helpstring("Will be fired if the user presses a key while the control has the focus. This event may be disabled.")]
			void KeyDown(SHORT* keyCode, SHORT shift);
			/// \brief <em>An alphanumeric key was pressed and released while the control has the focus</em>
			///
			/// Will be fired if the user presses and releases an alphanumeric key while the control has the
			/// focus.
			///
			/// \param[in,out] keyAscii The pressed key's ASCII code.
			///
			/// \remarks You may set \c keyAscii to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyUp, IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_KEYPRESS), helpstring("Will be fired if the user presses and releases an alphanumeric key while the control has the focus. This event may be disabled.")]
			void KeyPress(SHORT* keyAscii);
			/// \brief <em>A key was released while the control has the focus</em>
			///
			/// Will be fired if the user releases a key while the control has the focus.
			///
			/// \param[in,out] keyCode The released key. Any of the values defined by VB's
			///                \c KeyCodeConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			///
			/// \remarks You may set \c keyCode to 0 to eat the message.\n
			///          This event may be disabled.
			///
			/// \sa KeyDown, KeyPress, IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_KEYUP), helpstring("Will be fired if the user releases a key while the control has the focus. This event may be disabled.")]
			void KeyUp(SHORT* keyCode, SHORT shift);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the middle mouse button.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the clicked text.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MDblClick, Click, RClick, XClick, HitTestConstants, IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_MCLICK), helpstring("Will be fired if the user clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MClick(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the middle mouse
			/// button.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the double-clicked text.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MClick, DblClick, RDblClick, XDblClick, HitTestConstants, IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_MDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the middle mouse button. This event may be disabled.")]
			void MDblClick(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was pressed over the control's client area</em>
			///
			/// Will be fired if the user presses a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the text that the mouse cursor is
			///            located over.
			/// \param[in] button The pressed mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseUp, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants, HitTestConstants,
			///     IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_MOUSEDOWN), helpstring("Will be fired if the user presses a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseDown(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area</em>
			///
			/// Will be fired if the user moved the mouse cursor into the control's client area.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the text that the mouse cursor is
			///            located over.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseLeave, MouseHover, MouseMove, ExtendedMouseButtonConstants, HitTestConstants,
			///     IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_MOUSEENTER), helpstring("Will be fired if the user moved the mouse cursor into the control's client area. This event may be disabled.")]
			void MouseEnter(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved into the control's client area a specified period of time before</em>
			///
			/// Will be fired if the mouse cursor has been located over the control's client area for the number
			/// of milliseconds specified by the \c IRichTextBox::HoverTime property.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the text that the mouse cursor is
			///            located over.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseMove, IRichTextBox::HoverTime, ExtendedMouseButtonConstants,
			///     HitTestConstants, IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_MOUSEHOVER), helpstring("Will be fired if the mouse cursor has been located over the control's client area for the number of milliseconds specified by the 'HoverTime' property. This event may be disabled.")]
			void MouseHover(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved out of the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor out of the control's client area.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the text that the mouse cursor is
			///            located over.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseHover, MouseMove, ExtendedMouseButtonConstants, HitTestConstants,
			///     IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_MOUSELEAVE), helpstring("Will be fired if the user moves the mouse cursor out of the control's client area. This event may be disabled.")]
			void MouseLeave(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse cursor was moved over the control's client area</em>
			///
			/// Will be fired if the user moves the mouse cursor over the control's client area.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the text that the mouse cursor is
			///            located over.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseEnter, MouseLeave, MouseDown, MouseUp, MouseWheel, ExtendedMouseButtonConstants,
			///     HitTestConstants, IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_MOUSEMOVE), helpstring("Will be fired if the user moves the mouse cursor over the control's client area. This event may be disabled.")]
			void MouseMove(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>A mouse button was released over the control's client area</em>
			///
			/// Will be fired if the user releases a mouse button while the mouse cursor is located over the
			/// control's client area.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the text that the mouse cursor is
			///            located over.
			/// \param[in] button The released mouse button. Any of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the
			///            control's upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseDown, Click, MClick, RClick, XClick, ExtendedMouseButtonConstants, HitTestConstants,
			///     IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_MOUSEUP), helpstring("Will be fired if the user releases a mouse button while the mouse cursor is located over the control's client area. This event may be disabled.")]
			void MouseUp(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The mouse wheel was rotated over the control's client area</em>
			///
			/// Will be fired if the user rotates the mouse wheel over the control's client area.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the text that the mouse cursor is
			///            located over.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
			///            is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position
			///            lies in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
			///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
			/// \param[in] wheelDelta The distance the wheel has been rotated.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa MouseMove, ExtendedMouseButtonConstants, HitTestConstants, ScrollAxisConstants,
			///     IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_MOUSEWHEEL), helpstring("Will be fired if the user rotates the mouse wheel over the control's client area. This event may be disabled.")]
			void MouseWheel(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, ScrollAxisConstants scrollAxis, SHORT wheelDelta);
			/// \brief <em>An OLE drag'n'drop operation was completed</em>
			///
			/// Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully.
			///
			/// \param[in] data The object that holds the dragged data. The drop target may have added data to
			///            it.
			/// \param[in] performedEffect The performed drop effect. Any of the values (except \c odeScroll)
			///            defined by the \c OLEDropEffectConstants enumeration is valid.
			///
			/// \remarks This event is raised only if the drag'n'drop operation has been initiated by calling
			///          \c OLEDrag.
			///
			/// \sa IRichTextBox::OLEDrag, OLEStartDrag, IOLEDataObject::GetData, DragDropDone
			[id(DISPID_RTBE_OLECOMPLETEDRAG), helpstring("Will be fired after OLE drag'n'drop if the drag'n'drop operation was completed successfully. This event is raised only if the drag'n'drop operation has been initiated by calling 'OLEDrag'.")]
			void OLECompleteDrag(IOLEDataObject* data, OLEDropEffectConstants performedEffect);
			/// \brief <em>The data was dropped onto the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor
			/// is located over the control's client area.
			///
			/// \param[in] data The dropped data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target finally
			///                executed.
			/// \param[in] dropTarget The text range (an insertion point) that is the current target of the
			///            drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragLeave, GetDragDropEffect, MouseUp,
			///     IRichTextBox::RegisterForOLEDragDrop, IRichTextBox::FinishOLEDragDrop,
			///     OLEDropEffectConstants, HitTestConstants
			[id(DISPID_RTBE_OLEDRAGDROP), helpstring("Will be fired during OLE drag'n'drop if the user completes the operation while the mouse cursor is located over the control's client area.")]
			void OLEDragDrop(IOLEDataObject* data, OLEDropEffectConstants* effect, IRichTextRange* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The data was dragged into the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] dropTarget The text range (an insertion point) that is the current target of the
			///            drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                control auto-scrolls to the left; if set to a value greater than 0, the control
			///                auto-scrolls to the right. The higher/lower the value is, the faster the control
			///                scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the control
			///                auto-scrolls upwardly; if set to a value greater than 0, the control auto-scrolls
			///                downwards. The higher/lower the value is, the faster the control scrolls.
			///
			/// \sa OLEDragMouseMove, OLEDragLeave, OLEDragDrop, GetDragDropEffect, MouseEnter,
			///     IRichTextBox::RegisterForOLEDragDrop, OLEDropEffectConstants,
			///     IRichTextBox::DragScrollTimeBase, HitTestConstants
			[id(DISPID_RTBE_OLEDRAGENTER), helpstring("Will be fired during OLE drag'n'drop if the user moved the mouse cursor into the control's client area.")]
			void OLEDragEnter(IOLEDataObject* data, OLEDropEffectConstants* effect, IRichTextRange* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity, HitTestConstants hitTestDetails);
			/// \brief <em>The user has dragged the data into a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop
			/// target window.
			///
			/// \param[in] hWndPotentialTarget The potential drop target window's handle.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragLeavePotentialTarget, IRichTextBox::OLEDrag
			[id(DISPID_RTBE_OLEDRAGENTERPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor into a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragEnterPotentialTarget(LONG hWndPotentialTarget);
			/// \brief <em>The data was dragged out of the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor out of the control's
			/// client area or if the user canceled the drag'n'drop operation.
			///
			/// \param[in] data The dragged data.
			/// \param[in] dropTarget The text range (an insertion point) that is the current target of the
			///            drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks Don't forget to release any references that you hold to the data object.
			///
			/// \sa OLEDragEnter, OLEDragMouseMove, OLEDragDrop, MouseLeave,
			///     IRichTextBox::RegisterForOLEDragDrop, HitTestConstants
			[id(DISPID_RTBE_OLEDRAGLEAVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area or if the user canceled the drag'n'drop operation.")]
			void OLEDragLeave(IOLEDataObject* data, IRichTextRange* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user has dragged the data out of a potential drop target window during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop
			/// target window.
			///
			/// \remarks Requires Windows Vista or newer.
			///
			/// \sa OLEDragEnterPotentialTarget, IRichTextBox::OLEDrag
			[id(DISPID_RTBE_OLEDRAGLEAVEPOTENTIALTARGET), helpstring("Will be fired during OLE drag'n'drop if the user dragged the mouse cursor out of a potential drop target window. Requires Windows Vista or newer.")]
			void OLEDragLeavePotentialTarget(void);
			/// \brief <em>The data was dragged over the control during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's
			/// client area.
			///
			/// \param[in] data The dragged data.
			/// \param[in,out] effect On entry, a bit field of the drop effects (defined by the
			///                \c OLEDropEffectConstants enumeration) supported by the drag source. On
			///                return, this paramter must be set to the drop effect that the target wants
			///                to be used on drop.
			/// \param[in] dropTarget The text range (an insertion point) that is the current target of the
			///            drag'n'drop operation.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the mouse cursor's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that the mouse cursor's position lies
			///            in. Any of the values defined by the \c HitTestConstants enumeration is valid.
			/// \param[in,out] autoHScrollVelocity The speed multiplier for horizontal auto-scrolling. If set
			///                to 0, horizontal auto-scrolling is disabled; if set to a value less than 0, the
			///                control auto-scrolls to the left; if set to a value greater than 0, the control
			///                auto-scrolls to the right. The higher/lower the value is, the faster the control
			///                scrolls.
			/// \param[in,out] autoVScrollVelocity The speed multiplier for vertical auto-scrolling. If set to
			///                vertical auto-scrolling is disabled; if set to a value less than 0, the control
			///                auto-scrolls upwardly; if set to a value greater than 0, the control auto-scrolls
			///                downwards. The higher/lower the value is, the faster the control scrolls.
			///
			/// \sa OLEDragEnter, OLEDragLeave, OLEDragDrop, GetDragDropEffect, MouseMove,
			///     IRichTextBox::RegisterForOLEDragDrop, OLEDropEffectConstants,
			///     IRichTextBox::DragScrollTimeBase, HitTestConstants
			[id(DISPID_RTBE_OLEDRAGMOUSEMOVE), helpstring("Will be fired during OLE drag'n'drop if the user moves the mouse cursor over the control's client area.")]
			void OLEDragMouseMove(IOLEDataObject* data, OLEDropEffectConstants* effect, IRichTextRange* dropTarget, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, LONG* autoHScrollVelocity, LONG* autoVScrollVelocity);
			/// \brief <em>The mouse cursor needs to be updated during OLE drag'n'drop</em>
			///
			/// Will be fired during OLE drag'n'drop if the mouse cursor should be updated to visualize the
			/// current drop effect.
			///
			/// \param[in] effect The current drop effect. It is chosen by the potential drop target.
			///            Any of the values defined by the \c OLEDropEffectConstants enumeration is valid.
			/// \param[in,out] useDefaultCursors If set to \c True, the system's default mouse cursors are
			///                used to visualize the various drop effects. If set to \c False, custom
			///                mouse cursors are used. You must set the custom cursor within the handler of
			///                this event.
			///
			/// \sa IRichTextBox::OLEDrag, OLEQueryContinueDrag, OLEDropEffectConstants
			[id(DISPID_RTBE_OLEGIVEFEEDBACK), helpstring("Will be fired during OLE drag'n'drop if the mouse cursor should be updated.")]
			void OLEGiveFeedback(OLEDropEffectConstants effect, VARIANT_BOOL* useDefaultCursors);
			/// \brief <em>The drag source should decide how to proceed with the OLE drag'n'drop operation</em>
			///
			/// Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed. It
			/// gives the drag source the chance to cancel or complete the drag'n'drop operation.
			///
			/// \param[in] pressedEscape If \c True, the user has pressed the \c ESC key since the last time
			///            this event was fired.
			/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
			///            \c MouseButtonConstants enumeration is valid.
			/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
			///            defined by VB's \c ShiftConstants enumeration is valid.
			/// \param[in,out] actionToContinueWith Indicates whether to continue, cancel or complete the
			///                drag'n'drop operation. Any of the values defined by the
			///                \c OLEActionToContinueWithConstants enumeration is valid.
			///
			/// \sa IRichTextBox::OLEDrag, OLEGiveFeedback, OLEActionToContinueWithConstants
			[id(DISPID_RTBE_OLEQUERYCONTINUEDRAG), helpstring("Will be fired during OLE drag'n'drop if the keyboard or mouse button state has changed.")]
			void OLEQueryContinueDrag(VARIANT_BOOL pressedEscape, SHORT button, SHORT shift, OLEActionToContinueWithConstants* actionToContinueWith);
			/// \brief <em>Data has been stored in the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data in the specified format has been written into the
			/// dragged data object.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the data object has received data for.
			///            Valid values are those defined by VB's \c ClipBoardConstants enumeration, but also any
			///            other format that has been registered using the \c RegisterClipboardFormat API
			///            function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLESetData, IOLEDataObject::GetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_RTBE_OLERECEIVEDNEWDATA), helpstring("Will be fired during OLE drag'n'drop if data in the specified format has been written into the dragged data object.")]
			void OLEReceivedNewData(IOLEDataObject* data, LONG formatID, LONG Index, LONG dataOrViewAspect);
			/// \brief <em>Data is requested from the data object</em>
			///
			/// Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data
			/// format, that you've chosen to support (in the \c OLEStartDrag event), but for which you didn't
			/// provide any data so far.\n
			/// Call the provided object's \c SetData method to provide the data. If you chose to not support
			/// this data format, simply do nothing.
			///
			/// \param[in] data The object that holds the dragged data.
			/// \param[in] formatID An integer value specifying the format the drop target is requesting data
			///            for. Valid values are those defined by VB's \c ClipBoardConstants enumeration, but
			///            also any other format that has been registered using the \c RegisterClipboardFormat
			///            API function.
			/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's
			///            \c lindex member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS
			///            require multiple \c FORMATETC structs for the same format. In such cases each struct
			///            of this format will have a separate index.
			/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC
			///            struct's \c dwAspect member. Any of the \c DVASPECT_* values defined by the
			///            Microsoft&reg; Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
			///
			/// \remarks This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa OLEStartDrag, IOLEDataObject::SetData,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
			[id(DISPID_RTBE_OLESETDATA), helpstring("Will be fired during OLE drag'n'drop if data is requested from the dragged data object in a data format, that you've chosen to support (in the 'OLEStartDrag' event), but for which you didn't provide any data so far.")]
			void OLESetData(IOLEDataObject* data, LONG formatID, LONG Index, LONG dataOrViewAspect);
			/// \brief <em>The container holding the dragged data needs to be filled up</em>
			///
			/// Will be fired after you called the \c OLEDrag method to determine the data you're offering. You
			/// must call the provided object's \c SetData method for each data format you're offering data in.
			///
			/// \param[in] data The object that holds the dragged data.
			///
			/// \remarks This event is raised only if the drag'n'drop operation has been initiated by calling
			///          \c OLEDrag.\n
			///          This event won't be fired if a custom \c IDataObject implementation was passed to
			///          the \c OLEDrag method.
			///
			/// \sa IRichTextBox::OLEDrag, OLESetData, OLECompleteDrag, IOLEDataObject::SetData
			[id(DISPID_RTBE_OLESTARTDRAG), helpstring("Will be fired after you called the 'OLEDrag' method to determine the data you're offering. This event is raised only if the drag'n'drop operation has been initiated by calling 'OLEDrag'.")]
			void OLEStartDrag(IOLEDataObject* data);
			/// \brief <em>Data needs to be accepted or refused during a copy'n'paste or drag'n'drop operation</em>
			///
			/// Will be fired on copy'n'paste and drag'n'drop operations to determine whether the client
			/// application accepts the copied or dragged data.
			///
			/// \param[in] data The object that holds the copied or dragged data.
			/// \param[in,out] formatID An integer value specifying the format in which the copied or dragged
			///                data will be pasted or dropped. The client application may change the format to
			///                any other format provided by the data object.\n
			///                Valid values are those defined by VB's \c ClipBoardConstants enumeration, but
			///                also any other format that has been registered using the
			///                \c RegisterClipboardFormat API function.
			/// \param[in] operationType Specifies the kind of operation that will take place. Some of the values
			///            defined by the \c ClipboardOperationTypeConstants enumeration are valid.
			/// \param[in] performOperation If \c True, the operation is actually being performed; otherwise the
			///            event is fired only to check whether the data would be accepted or refused.
			/// \param[in] hMetafilePicture A handle to a metafile image that should be used to display the
			///            inserted object as icon.
			/// \param[in,out] acceptData Specifies whether to accept or refuse the provided data or whether to
			///                let the native rich edit control decide. Any of the values defined by the
			///                \c QueryAcceptDataConstants enumeration is valid.
			///
			/// \sa GetDataObject, IOLEDataObject, ClipboardOperationTypeConstants, QueryAcceptDataConstants,
			///     <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>
			[id(DISPID_RTBE_QUERYACCEPTDATA), helpstring("Will be fired on copy'n'paste and drag'n'drop operations to determine whether the client application accepts the copied or dragged data.")]
			void QueryAcceptData(IOLEDataObject* data, LONG* formatID, ClipboardOperationTypeConstants operationType, VARIANT_BOOL performOperation, OLE_HANDLE hMetafilePicture, QueryAcceptDataConstants* acceptData);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using the right mouse button.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the clicked text.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa ContextMenu, RDblClick, Click, MClick, XClick, HitTestConstants, IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_RCLICK), helpstring("Will be fired if the user clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RClick(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using the right mouse
			/// button.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the double-clicked text.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa RClick, DblClick, MDblClick, XDblClick, HitTestConstants, IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_RDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using the right mouse button. This event may be disabled.")]
			void RDblClick(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The control window was recreated</em>
			///
			/// Will be fired after the control window was destroyed and recreated.\n
			/// Some properties can't be changed after the control window was created. If such a property is
			/// changed and the control window already exists, it is destroyed and recreated.
			///
			/// \param[in] hWnd The control's window handle.
			///
			/// \sa DestroyedControlWindow, IRichTextBox::hWnd
			[id(DISPID_RTBE_RECREATEDCONTROLWINDOW), helpstring("Will be fired after the control window was destroyed and recreated.")]
			void RecreatedControlWindow(LONG hWnd);
			/// \brief <em>An embedded OLE object is about to be removed</em>
			///
			/// Will be fired before an embedded OLE object is removed.
			///
			/// \param[in] OLEObject The object that is about to be removed.
			/// \param[in,out] reserved Reserved for future use. Do not use.
			///
			/// \sa InsertingObject, IRichOLEObject
			[id(DISPID_RTBE_REMOVINGOLEOBJECT), helpstring("Will be fired before an embedded OLE object is removed.")]
			void RemovingOLEObject(IRichOLEObject* OLEObject, VARIANT_BOOL* reserved);
			/// \brief <em>The control window was resized</em>
			///
			/// Will be fired after the control window was resized.
			[id(DISPID_RTBE_RESIZEDCONTROLWINDOW), helpstring("Will be fired after the control window was resized.")]
			void ResizedControlWindow(void);
			/// \brief <em>The control is being scrolled</em>
			///
			/// Will be fired if the control is being scrolled.
			///
			/// \param[in] axis The axis which is scrolled. Any of the values defined by the
			///            \c ScrollAxisConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IRichTextBox::MultiLine, IRichTextBox::ScrollBars, IRichTextBox::DisabledEvents,
			///     ScrollAxisConstants
			[id(DISPID_RTBE_SCROLLING), helpstring("Will be fired if the control is being scrolled. This event may be disabled.")]
			void Scrolling(ScrollAxisConstants axis);
			/// \brief <em>The current selection has changed</em>
			///
			/// Will be fired if the control's current selection has changed.
			///
			/// \param[in] selectedTextRange A \c IRichTextRange object wrapping the (new) selected text.
			/// \param[in] selectionType Specifies what kind of data the current selection contains. Any
			///            combination of the values defined by the \c SelectionTypeConstants enumeration is
			///            valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IRichTextRange, IRichTextBox::SelectedTextRange, SelectionTypeConstants
			[id(DISPID_RTBE_SELECTIONCHANGED), helpstring("Will be fired if the control's current selection has changed. This event may be disabled.")]
			void SelectionChanged(IRichTextRange* SelectedTextRange, SelectionTypeConstants selectionType);
			/// \brief <em>The control's window size is not optimal anymore to display the control's content</em>
			///
			/// Will be fired if the control's content is smaller or larger than the control's window size.
			///
			/// \param[in] suggestedControlSize The rectangle that the control should be resized to.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa IRichTextBox::CheckForOptimalControlWindowSize, RECTANGLE
			[id(DISPID_RTBE_SHOULDRESIZECONTROLWINDOW), helpstring("Will be fired if the control's content is smaller or larger than the control's window size. This event may be disabled.")]
			void ShouldResizeControlWindow(RECTANGLE* suggestedControlSize);
			/// \brief <em>The text, that was entered into the control, got truncated</em>
			///
			/// Will be fired if the text, that was entered into the control, got truncated. This happens in the
			/// following situations:
			/// - The control's resulting text would have been longer than allowed by the \c MaxTextLength
			///   property.
			///
			/// \sa IRichTextBox::Text, IRichTextBox::MaxTextLength
			[id(DISPID_RTBE_TRUNCATEDTEXT), helpstring("Will be fired if the text, that was entered into the control, got truncated.")]
			void TruncatedText(void);
			/// \brief <em>The control's writing direction has been changed by the user</em>
			///
			/// Will be fired if the control's writing direction has been changed by the user.
			///
			/// \param[in] newWritingDirection The control's new writing direction. Any of the values defined by
			///            the \c WritingDirectionConstants enumeration is valid.
			///
			/// \remarks Due to limitations of Microsoft Windows, this event is not raised if the writing
			///          direction is changed using the control's default context menu.
			///
			/// \sa IRichTextBox::RightToLeft, WritingDirectionConstants
			//[id(DISPID_RTBE_WRITINGDIRECTIONCHANGED), helpstring("Will be fired if the control's writing direction has been changed by the user.")]
			//void WritingDirectionChanged(WritingDirectionConstants newWritingDirection);
			/// \brief <em>The user clicked into the control's client area</em>
			///
			/// Will be fired if the user clicks into the control's client area using one of the extended mouse
			/// buttons.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the clicked text.
			/// \param[in] button The mouse buttons that were pressed during the click. This should always
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click.
			///            Any combination of the values defined by VB's \c ShiftConstants enumeration is
			///            valid.
			/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the values
			///            defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XDblClick, Click, MClick, RClick, ExtendedMouseButtonConstants, HitTestConstants,
			///     IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_XCLICK), helpstring("Will be fired if the user clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XClick(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
			/// \brief <em>The user double-clicked into the control's client area</em>
			///
			/// Will be fired if the user double-clicks into the control's client area using one of the extended
			/// mouse buttons.
			///
			/// \param[in] textRange A \c IRichTextRange object wrapping the double-clicked text.
			/// \param[in] button The mouse buttons that were pressed during the double-click. This should
			///            be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
			/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the
			///            double-click. Any combination of the values defined by VB's \c ShiftConstants
			///            enumeration is valid.
			/// \param[in] x The x-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] y The y-coordinate (in twips) of the double-click's position relative to the control's
			///            upper-left corner.
			/// \param[in] hitTestDetails Specifies the part of the control that was double-clicked. Any of the
			///            values defined by the \c HitTestConstants enumeration is valid.
			///
			/// \remarks This event may be disabled.
			///
			/// \sa XClick, DblClick, MDblClick, RDblClick, ExtendedMouseButtonConstants, HitTestConstants,
			///     IRichTextBox::DisabledEvents
			[id(DISPID_RTBE_XDBLCLICK), helpstring("Will be fired if the user double-clicks into the control's client area using one of the extended mouse buttons. This event may be disabled.")]
			void XDblClick(IRichTextRange* TextRange, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	};


	/// \author Timo "TimoSoft" Kunze
	/// \brief <em>The \c RichTextBox class</em>
	///
	/// The control's main COM class. It implements the \c IRichTextBox and
	/// \c _IRichTextBoxEvents interfaces.
	///
	/// \sa IRichTextBox, _IRichTextBoxEvents
	[
		uuid(B13805F0-F513-4978-9BB9-0B2BA6C3E01D),
		version(1.0),
		helpstring("RichTextBox Control 1.0 (ANSI)")
	]
	coclass RichTextBox
	{
		[default] interface IRichTextBox;
		[default, source] dispinterface _IRichTextBoxEvents;
	};


	[
		uuid(F05C208D-25DE-43A6-9A22-F5967142C2F5),
		version(1.0),
		noncreatable,
		helpstring("CommonProperties Class 1.0 (ANSI)"),
		hidden
	]
	coclass CommonProperties
	{
		[default] interface IUnknown;
	};
};
